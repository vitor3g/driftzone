diff --git a/node_modules/@zhobo63/imgui-ts/src/font.ts b/node_modules/@zhobo63/imgui-ts/src/font.ts
index a9e1e3d..1999422 100644
--- a/node_modules/@zhobo63/imgui-ts/src/font.ts
+++ b/node_modules/@zhobo63/imgui-ts/src/font.ts
@@ -1,186 +1,180 @@
-import { ImFont, ImFontGlyph } from './imgui'
+// @ts-nocheck
+import { ImFont, ImFontGlyph } from './imgui';
 import { Texture } from './imgui_impl';
 import { ImGui_Impl } from './index';
 
-const FONT_SPACE=5;
-const FONT_SIZE_EXTEND=2;
+const FONT_SPACE = 5;
+const FONT_SIZE_EXTEND = 2;
 
-function GetFontName(font:ImFont):string
-{
-    return font.FontStyle + " " + font.FontSize + "px " + font.FontName;
+function GetFontName(font: ImFont): string {
+  return font.FontStyle + " " + font.FontSize + "px " + font.FontName;
 }
 
-export class TexturePage
-{
-    constructor(tex_size:number, font:ImFont)
-    {
-        let font_size=font.FontSize;
-        this.FontName= GetFontName(font);
-        this.Scale=ImGui_Impl.font_scale;
-        this.TextureSize=tex_size;
-        this.FontSize=font_size;
-        this.SpaceX=font.SpaceX;
-        this.FontImageSize=Math.ceil((font_size+FONT_SPACE)*this.Scale);
-        this.Ascent=font.Ascent;
-        this.Descent=font.Descent;
-
-        this.PixelData=new Uint16Array(tex_size*tex_size);
-
-        this.CharsPerRow=Math.floor(tex_size/this.FontImageSize);
-        this.MaxCharCount=this.CharsPerRow*this.CharsPerRow;
-        this.Current=0;
-        if(!ImGui_Impl.gl)  {
-            console.log("ImGui_Impl.gl is not ready")
-            return;
-        }
-        let gl=ImGui_Impl.gl;
-        this.Texure=new Texture();
-        this.Texure._srcType=gl.UNSIGNED_SHORT_4_4_4_4;
-        if(this.Scale==ImGui_Impl.canvas_scale) {
-            this.Texure._minFilter=gl.NEAREST;
-            this.Texure._magFilter=gl.NEAREST;
-        }
-        this.Texure.Update(this.PixelData, {width:tex_size, height:tex_size});
+export class TexturePage {
+  constructor(tex_size: number, font: ImFont) {
+    let font_size = font.FontSize;
+    this.FontName = GetFontName(font);
+    this.Scale = ImGui_Impl.font_scale;
+    this.TextureSize = tex_size;
+    this.FontSize = font_size;
+    this.SpaceX = font.SpaceX;
+    this.FontImageSize = Math.ceil((font_size + FONT_SPACE) * this.Scale);
+    this.Ascent = font.Ascent;
+    this.Descent = font.Descent;
+
+    this.PixelData = new Uint16Array(tex_size * tex_size);
+
+    this.CharsPerRow = Math.floor(tex_size / this.FontImageSize);
+    this.MaxCharCount = this.CharsPerRow * this.CharsPerRow;
+    this.Current = 0;
+    if (!ImGui_Impl.gl) {
+      console.log("ImGui_Impl.gl is not ready")
+      return;
     }
-
-    Destroy()
-    {
-        this.Texure.Destroy();
+    let gl = ImGui_Impl.gl;
+    this.Texure = new Texture();
+    this.Texure._srcType = gl.UNSIGNED_SHORT_4_4_4_4;
+    if (this.Scale == ImGui_Impl.canvas_scale) {
+      this.Texure._minFilter = gl.NEAREST;
+      this.Texure._magFilter = gl.NEAREST;
     }
-
-    Create(glyph:ImFontGlyph, ctx: CanvasRenderingContext2D):ImFontGlyph {
-        const image_size=this.FontImageSize;
-        const cur=this.Current;
-        this.Current++;
-        const ix=cur%this.CharsPerRow;
-        const iy=Math.floor(cur/this.CharsPerRow);
-        const px=ix*(image_size);
-        const py=iy*(image_size);
-        const text=String.fromCharCode(glyph.Char);
-        glyph.TextureID=this.Texure._texture;
-
-        ctx.save();
-        ctx.canvas.width=image_size;
-        ctx.canvas.height=image_size;
-        ctx.textAlign='left';
-        ctx.textBaseline='top';
-        ctx.font=this.FontName;
-        ctx.clearRect(0,0,image_size,image_size);
-        ctx.scale(this.Scale, this.Scale);
-        let m=ctx.measureText(text);
-        ctx.fillText(text, 1, 1);
-        //ctx.strokeRect(0,0,image_size-FONT_SPACE, image_size-FONT_SPACE);
-        ctx.restore();
-        const img_data=ctx.getImageData(0,0,image_size, image_size);
-        const img_data_u32=new Uint32Array(img_data.data.buffer);
-
-        for(let y=0;y<image_size;y++)   {
-            for(let x=0;x<image_size;x++)   {
-                this.PixelData[(py+y)*this.TextureSize+px+x]=0xFFF0|
-                (((img_data_u32[y*image_size+x]>>24)&0xFF)>>4);
-            }
-        }        
-        let w=m.width<=this.FontSize?m.width:m.actualBoundingBoxRight-m.actualBoundingBoxLeft;
-        if(glyph.Char==0)   {
-            w=this.FontSize+1;
-        }
-        glyph.X0=0;
-        glyph.Y0=this.Descent;
-        glyph.X1=w+FONT_SIZE_EXTEND;
-        glyph.Y1=this.FontSize+FONT_SIZE_EXTEND;
-        glyph.AdvanceX=(w)+(glyph.Char<256?this.SpaceX[0]:this.SpaceX[1]);
-        let uv_scale=1.0/(this.TextureSize);
-        glyph.U0=(px)*uv_scale;
-        glyph.V0=(py+this.Ascent*this.Scale)*uv_scale;
-        glyph.U1=(px+glyph.X1*this.Scale)*uv_scale;
-        glyph.V1=glyph.V0+(glyph.Y1*this.Scale)*uv_scale;
-
-        this.Dirty=true;
-        return glyph;
+    this.Texure.Update(this.PixelData, { width: tex_size, height: tex_size });
+  }
+
+  Destroy() {
+    this.Texure.Destroy();
+  }
+
+  Create(glyph: ImFontGlyph, ctx: CanvasRenderingContext2D): ImFontGlyph {
+    const image_size = this.FontImageSize;
+    const cur = this.Current;
+    this.Current++;
+    const ix = cur % this.CharsPerRow;
+    const iy = Math.floor(cur / this.CharsPerRow);
+    const px = ix * (image_size);
+    const py = iy * (image_size);
+    const text = String.fromCharCode(glyph.Char);
+    glyph.TextureID = this.Texure._texture;
+
+    ctx.save();
+    ctx.canvas.width = image_size;
+    ctx.canvas.height = image_size;
+    ctx.textAlign = 'left';
+    ctx.textBaseline = 'top';
+    ctx.font = this.FontName;
+    ctx.clearRect(0, 0, image_size, image_size);
+    ctx.scale(this.Scale, this.Scale);
+    let m = ctx.measureText(text);
+    ctx.fillText(text, 1, 1);
+    //ctx.strokeRect(0,0,image_size-FONT_SPACE, image_size-FONT_SPACE);
+    ctx.restore();
+    const img_data = ctx.getImageData(0, 0, image_size, image_size);
+    const img_data_u32 = new Uint32Array(img_data.data.buffer);
+
+    for (let y = 0; y < image_size; y++) {
+      for (let x = 0; x < image_size; x++) {
+        this.PixelData[(py + y) * this.TextureSize + px + x] = 0xFFF0 |
+          (((img_data_u32[y * image_size + x] >> 24) & 0xFF) >> 4);
+      }
     }
-
-    UpdateTexture() {
-        this.Dirty=false;
-        console.log(this.FontName + " UpdateTexture " + this.Current + "/" + this.MaxCharCount);
-        this.Texure.Update(this.PixelData);
+    let w = m.width <= this.FontSize ? m.width : m.actualBoundingBoxRight - m.actualBoundingBoxLeft;
+    if (glyph.Char == 0) {
+      w = this.FontSize + 1;
     }
-
-    get IsAvailable():boolean {return this.Current<this.MaxCharCount;}    
-
-    FontName:string;
-    Scale:number;
-    TextureSize:number;
-    FontSize:number;
-    FontImageSize:number;
-    PixelData:Uint16Array;
-    Current:number;
-    MaxCharCount:number;
-    CharsPerRow:number;
-    Texure:Texture;
-    Dirty:boolean=false;
-    SpaceX:number[];
-    Ascent:number=0;
-    Descent:number=0;
+    glyph.X0 = 0;
+    glyph.Y0 = this.Descent;
+    glyph.X1 = w + FONT_SIZE_EXTEND;
+    glyph.Y1 = this.FontSize + FONT_SIZE_EXTEND;
+    glyph.AdvanceX = (w) + (glyph.Char < 256 ? this.SpaceX[0] : this.SpaceX[1]);
+    let uv_scale = 1.0 / (this.TextureSize);
+    glyph.U0 = (px) * uv_scale;
+    glyph.V0 = (py + this.Ascent * this.Scale) * uv_scale;
+    glyph.U1 = (px + glyph.X1 * this.Scale) * uv_scale;
+    glyph.V1 = glyph.V0 + (glyph.Y1 * this.Scale) * uv_scale;
+
+    this.Dirty = true;
+    return glyph;
+  }
+
+  UpdateTexture() {
+    this.Dirty = false;
+    console.log(this.FontName + " UpdateTexture " + this.Current + "/" + this.MaxCharCount);
+    this.Texure.Update(this.PixelData);
+  }
+
+  get IsAvailable(): boolean { return this.Current < this.MaxCharCount; }
+
+  FontName: string;
+  Scale: number;
+  TextureSize: number;
+  FontSize: number;
+  FontImageSize: number;
+  PixelData: Uint16Array;
+  Current: number;
+  MaxCharCount: number;
+  CharsPerRow: number;
+  Texure: Texture;
+  Dirty: boolean = false;
+  SpaceX: number[];
+  Ascent: number = 0;
+  Descent: number = 0;
 }
 
-export class Font
-{
-    constructor()
-    {
-        let canvas=document.createElement("canvas");
-        canvas.style.backgroundColor="transparent";
-        canvas.style.position='absolute';
-        canvas.style.top='0px';
-        canvas.style.left='0px';
-        canvas.style.borderWidth='0';
-        canvas.style.borderStyle='none';
-        canvas.style.pointerEvents='none';
-        
-        this.canvas=canvas;
-        this.ctx=canvas.getContext("2d", {willReadFrequently:true}) as CanvasRenderingContext2D;
+export class Font {
+  constructor() {
+    let canvas = document.createElement("canvas");
+    canvas.style.backgroundColor = "transparent";
+    canvas.style.position = 'absolute';
+    canvas.style.top = '0px';
+    canvas.style.left = '0px';
+    canvas.style.borderWidth = '0';
+    canvas.style.borderStyle = 'none';
+    canvas.style.pointerEvents = 'none';
+
+    this.canvas = canvas;
+    this.ctx = canvas.getContext("2d", { willReadFrequently: true }) as CanvasRenderingContext2D;
+  }
+
+  Destroy() {
+    this.texturePage.forEach(page => {
+      page.Destroy();
+    })
+    this.texturePage = [];
+  }
+
+  Create(glyph: ImFontGlyph, font: ImFont): ImFontGlyph {
+    let fontname = GetFontName(font);
+    let page: TexturePage | null = null;
+    for (let page2 of this.texturePage) {
+      if (page2.IsAvailable && page2.FontName == fontname) {
+        page = page2;
+        break;
+      }
     }
-
-    Destroy() {
-        this.texturePage.forEach(page=>{
-            page.Destroy();
-        })
-        this.texturePage=[];
+    if (!page) {
+      page = new TexturePage(512, font);
+      this.texturePage.push(page);
     }
-
-    Create(glyph: ImFontGlyph, font:ImFont):ImFontGlyph
-    {
-        let fontname=GetFontName(font);
-        let page:TexturePage|null=null;
-        for(let page2 of this.texturePage)   {
-            if(page2.IsAvailable && page2.FontName==fontname)  {
-                page=page2;
-                break;
-            }
-        }
-        if(!page)  {
-            page=new TexturePage(512, font);
-            this.texturePage.push(page);
-        }
-        this.canvas.width=font.FontSize;
-        this.canvas.height=font.FontSize;
-        this.dirty=true;
-        return page.Create(glyph, this.ctx);
-    }
-    async UpdateTexture() {
-        if(!this.dirty)
-            return;
-        console.log("Font UpdateTexture begin");
-        this.texturePage.forEach(page=>{
-            if(page.Dirty)  {
-                page.UpdateTexture();
-            }
-        })
-        console.log("Font UpdateTexture end");
-        this.dirty=false;
-    }
-
-    texturePage:TexturePage[]=[];
-    canvas: HTMLCanvasElement;
-    ctx: CanvasRenderingContext2D;
-    dirty:boolean=false;
+    this.canvas.width = font.FontSize;
+    this.canvas.height = font.FontSize;
+    this.dirty = true;
+    return page.Create(glyph, this.ctx);
+  }
+  async UpdateTexture() {
+    if (!this.dirty)
+      return;
+    console.log("Font UpdateTexture begin");
+    this.texturePage.forEach(page => {
+      if (page.Dirty) {
+        page.UpdateTexture();
+      }
+    })
+    console.log("Font UpdateTexture end");
+    this.dirty = false;
+  }
+
+  texturePage: TexturePage[] = [];
+  canvas: HTMLCanvasElement;
+  ctx: CanvasRenderingContext2D;
+  dirty: boolean = false;
 }
diff --git a/node_modules/@zhobo63/imgui-ts/src/imgui.ts b/node_modules/@zhobo63/imgui-ts/src/imgui.ts
index e627ce0..1be0b75 100644
--- a/node_modules/@zhobo63/imgui-ts/src/imgui.ts
+++ b/node_modules/@zhobo63/imgui-ts/src/imgui.ts
@@ -1,3 +1,5 @@
+// @ts-nocheck
+
 export interface XY { x: number, y: number; }
 export interface XYZ extends XY { z: number; }
 export interface XYZW extends XYZ { w: number; }
@@ -10,121 +12,121 @@ export { Bind };
 
 let bind: Bind.Module;
 
-export let FLT_MIN:number;
-export let FLT_MAX:number;
-
-export default async function(value?: Partial<Bind.Module>): Promise<void> {
-    return new Promise<void>((resolve: () => void) => {
-        Bind.default(value).then((value: Bind.Module): void => {
-            bind = value;
-            FLT_MIN=bind.FLT_MIN;
-            FLT_MAX=bind.FLT_MAX;
-            resolve();
-        });
+export let FLT_MIN: number;
+export let FLT_MAX: number;
+
+export default async function (value?: Partial<Bind.Module>): Promise<void> {
+  return new Promise<void>((resolve: () => void) => {
+    Bind.default(value).then((value: Bind.Module): void => {
+      bind = value;
+      FLT_MIN = bind.FLT_MIN;
+      FLT_MAX = bind.FLT_MAX;
+      resolve();
     });
+  });
 }
 
 export { bind };
 
 function import_Scalar(sca: XY | XYZ | XYZW | Bind.ImAccess<number> | Bind.ImScalar<number> | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number> | Bind.interface_ImVec4): Bind.ImScalar<number> {
-    if (Array.isArray(sca)) { return [ sca[0] ]; }
-    if (typeof sca === "function") { return [ sca() ]; }
-    return [ sca.x ];
+  if (Array.isArray(sca)) { return [sca[0]]; }
+  if (typeof sca === "function") { return [sca()]; }
+  return [sca.x];
 }
 
 function export_Scalar(tuple: Bind.ImScalar<number>, sca: XY | XYZ | XYZW | Bind.ImAccess<number> | Bind.ImScalar<number> | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number> | Bind.interface_ImVec4): void {
-    if (Array.isArray(sca)) { sca[0] = tuple[0]; return; }
-    if (typeof sca === "function") { sca(tuple[0]); return; }
-    sca.x = tuple[0];
+  if (Array.isArray(sca)) { sca[0] = tuple[0]; return; }
+  if (typeof sca === "function") { sca(tuple[0]); return; }
+  sca.x = tuple[0];
 }
 
 function import_Vector2(vec: XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number> | Bind.interface_ImVec4): Bind.ImTuple2<number> {
-    if (Array.isArray(vec)) { return [ vec[0], vec[1] ]; }
-    return [ vec.x, vec.y ];
+  if (Array.isArray(vec)) { return [vec[0], vec[1]]; }
+  return [vec.x, vec.y];
 }
 
 function export_Vector2(tuple: Bind.ImTuple2<number>, vec: XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number> | Bind.interface_ImVec4): void {
-    if (Array.isArray(vec)) { vec[0] = tuple[0]; vec[1] = tuple[1]; return; }
-    vec.x = tuple[0]; vec.y = tuple[1];
+  if (Array.isArray(vec)) { vec[0] = tuple[0]; vec[1] = tuple[1]; return; }
+  vec.x = tuple[0]; vec.y = tuple[1];
 }
 
 function import_Vector3(vec: XYZ | XYZW | Bind.ImTuple3<number> | Bind.ImTuple4<number> | Bind.interface_ImVec4): Bind.ImTuple3<number> {
-    if (Array.isArray(vec)) { return [ vec[0], vec[1], vec[2] ]; }
-    return [ vec.x, vec.y, vec.z ];
+  if (Array.isArray(vec)) { return [vec[0], vec[1], vec[2]]; }
+  return [vec.x, vec.y, vec.z];
 }
 
 function export_Vector3(tuple: Bind.ImTuple3<number>, vec: XYZ | XYZW | Bind.ImTuple3<number> | Bind.ImTuple4<number> | Bind.interface_ImVec4): void {
-    if (Array.isArray(vec)) { vec[0] = tuple[0]; vec[1] = tuple[1]; vec[2] = tuple[2]; return; }
-    vec.x = tuple[0]; vec.y = tuple[1]; vec.z = tuple[2];
+  if (Array.isArray(vec)) { vec[0] = tuple[0]; vec[1] = tuple[1]; vec[2] = tuple[2]; return; }
+  vec.x = tuple[0]; vec.y = tuple[1]; vec.z = tuple[2];
 }
 
 function import_Vector4(vec: XYZW | Bind.ImTuple3<number> | Bind.ImTuple4<number> | Bind.interface_ImVec4): Bind.ImTuple4<number> {
-    if (Array.isArray(vec)) { return [ vec[0], vec[1], vec[2], vec[3] || 0 ]; }
-    return [ vec.x, vec.y, vec.z, vec.w ];
+  if (Array.isArray(vec)) { return [vec[0], vec[1], vec[2], vec[3] || 0]; }
+  return [vec.x, vec.y, vec.z, vec.w];
 }
 
 function export_Vector4(tuple: Bind.ImTuple4<number>, vec: XYZW | Bind.ImTuple3<number> | Bind.ImTuple4<number> | Bind.interface_ImVec4): void {
-    if (Array.isArray(vec)) { vec[0] = tuple[0]; vec[1] = tuple[1]; vec[2] = tuple[2]; vec[3] = tuple[3]; return; }
-    vec.x = tuple[0]; vec.y = tuple[1]; vec.z = tuple[2]; vec.w = tuple[3];
+  if (Array.isArray(vec)) { vec[0] = tuple[0]; vec[1] = tuple[1]; vec[2] = tuple[2]; vec[3] = tuple[3]; return; }
+  vec.x = tuple[0]; vec.y = tuple[1]; vec.z = tuple[2]; vec.w = tuple[3];
 }
 
 function import_Color3(col: RGB | RGBA | Bind.ImTuple3<number> | Bind.ImTuple4<number> | Bind.interface_ImVec4): Bind.ImTuple3<number> {
-    if (Array.isArray(col)) { return [ col[0], col[1], col[2] ]; }
-    if ("r" in col) { return [ col.r, col.g, col.b ]; }
-    return [ col.x, col.y, col.z ];
+  if (Array.isArray(col)) { return [col[0], col[1], col[2]]; }
+  if ("r" in col) { return [col.r, col.g, col.b]; }
+  return [col.x, col.y, col.z];
 }
 
 function export_Color3(tuple: Bind.ImTuple3<number>, col: RGB | RGBA | Bind.ImTuple3<number> | Bind.ImTuple4<number> | Bind.interface_ImVec4): void {
-    if (Array.isArray(col)) { col[0] = tuple[0]; col[1] = tuple[1]; col[2] = tuple[2]; return; }
-    if ("r" in col) { col.r = tuple[0]; col.g = tuple[1]; col.b = tuple[2]; return; }
-    col.x = tuple[0]; col.y = tuple[1]; col.z = tuple[2];
+  if (Array.isArray(col)) { col[0] = tuple[0]; col[1] = tuple[1]; col[2] = tuple[2]; return; }
+  if ("r" in col) { col.r = tuple[0]; col.g = tuple[1]; col.b = tuple[2]; return; }
+  col.x = tuple[0]; col.y = tuple[1]; col.z = tuple[2];
 }
 
 function import_Color4(col: RGBA | Bind.ImTuple4<number> | Bind.interface_ImVec4 | RGBA): Bind.ImTuple4<number> {
-    if (Array.isArray(col)) { return [ col[0], col[1], col[2], col[3] ]; }
-    if ("r" in col) { return [ col.r, col.g, col.b, col.a ]; }
-    return [ col.x, col.y, col.z, col.w ];
+  if (Array.isArray(col)) { return [col[0], col[1], col[2], col[3]]; }
+  if ("r" in col) { return [col.r, col.g, col.b, col.a]; }
+  return [col.x, col.y, col.z, col.w];
 }
 
 function export_Color4(tuple: Bind.ImTuple4<number>, col: RGBA | Bind.ImTuple4<number> | Bind.interface_ImVec4 | RGBA): void {
-    if (Array.isArray(col)) { col[0] = tuple[0]; col[1] = tuple[1]; col[2] = tuple[2]; col[3] = tuple[3]; return; }
-    if ("r" in col) { col.r = tuple[0]; col.g = tuple[1]; col.b = tuple[2]; col.a = tuple[3]; return; }
-    col.x = tuple[0]; col.y = tuple[1]; col.z = tuple[2]; col.w = tuple[3];
+  if (Array.isArray(col)) { col[0] = tuple[0]; col[1] = tuple[1]; col[2] = tuple[2]; col[3] = tuple[3]; return; }
+  if ("r" in col) { col.r = tuple[0]; col.g = tuple[1]; col.b = tuple[2]; col.a = tuple[3]; return; }
+  col.x = tuple[0]; col.y = tuple[1]; col.z = tuple[2]; col.w = tuple[3];
 }
 
 export var isMobile = {
-    Android: function() {
-        return navigator.userAgent.match(/Android/i);
-    },
-    BlackBerry: function() {
-        return navigator.userAgent.match(/BlackBerry/i);
-    },
-    iOS: function() {
-        return navigator.userAgent.match(/iPhone|iPad|iPod/i);
-    },
-    Opera: function() {
-        return navigator.userAgent.match(/Opera Mini/i);
-    },
-    Windows: function() {
-        return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);
-    },
-    any: function() {
-        return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());
-    },
-    isPortrait: function() {
-        return window.innerHeight > window.innerWidth;
-    },
+  Android: function () {
+    return navigator.userAgent.match(/Android/i);
+  },
+  BlackBerry: function () {
+    return navigator.userAgent.match(/BlackBerry/i);
+  },
+  iOS: function () {
+    return navigator.userAgent.match(/iPhone|iPad|iPod/i);
+  },
+  Opera: function () {
+    return navigator.userAgent.match(/Opera Mini/i);
+  },
+  Windows: function () {
+    return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);
+  },
+  any: function () {
+    return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());
+  },
+  isPortrait: function () {
+    return window.innerHeight > window.innerWidth;
+  },
 };
 
 //import * as config from "./imconfig";
 
-export { IMGUI_VERSION as VERSION }
+export { IMGUI_VERSION as VERSION };
 export const IMGUI_VERSION: string = "1.80"; // bind.IMGUI_VERSION;
-export { IMGUI_VERSION_NUM as VERSION_NUM }
+export { IMGUI_VERSION_NUM as VERSION_NUM };
 export const IMGUI_VERSION_NUM: number = 18000; // bind.IMGUI_VERSION_NUM;
 
 // #define IMGUI_CHECKVERSION()        ImGui::DebugCheckVersionAndDataLayout(IMGUI_VERSION, sizeof(ImGuiIO), sizeof(ImGuiStyle), sizeof(ImVec2), sizeof(ImVec4), sizeof(ImDrawVert))
-export { IMGUI_CHECKVERSION as CHECKVERSION }
+export { IMGUI_CHECKVERSION as CHECKVERSION };
 export function IMGUI_CHECKVERSION(): boolean { return DebugCheckVersionAndDataLayout(IMGUI_VERSION, bind.ImGuiIOSize, bind.ImGuiStyleSize, bind.ImVec2Size, bind.ImVec4Size, bind.ImDrawVertSize, bind.ImDrawIdxSize); }
 
 export const IMGUI_HAS_TABLE: boolean = true;
@@ -132,278 +134,278 @@ export const IMGUI_HAS_TABLE: boolean = true;
 export function ASSERT(c: any): asserts c { if (!c) { throw new Error(); } }
 export function IM_ASSERT(c: any): asserts c { if (!c) { throw new Error(); } }
 
-export { IM_ARRAYSIZE as ARRAYSIZE }
+export { IM_ARRAYSIZE as ARRAYSIZE };
 export function IM_ARRAYSIZE(_ARR: ArrayLike<any> | ImStringBuffer): number {
-    if (_ARR instanceof ImStringBuffer) {
-        return _ARR.size;
-    } else {
-        return _ARR.length;
-    }
+  if (_ARR instanceof ImStringBuffer) {
+    return _ARR.size;
+  } else {
+    return _ARR.length;
+  }
 }
 
-export { ImStringBuffer as StringBuffer }
+export { ImStringBuffer as StringBuffer };
 export class ImStringBuffer {
-    constructor(public size: number, public buffer: string = "") {}
+  constructor(public size: number, public buffer: string = "") {}
 }
 
-export type ImAccess<T> = Bind.ImAccess<T>; export { ImAccess as Access }
-export type ImScalar<T> = Bind.ImScalar<T>; export { ImScalar as Scalar }
-export type ImTuple2<T> = Bind.ImTuple2<T>; export { ImTuple2 as Tuple2 }
-export type ImTuple3<T> = Bind.ImTuple3<T>; export { ImTuple3 as Tuple3 }
-export type ImTuple4<T> = Bind.ImTuple4<T>; export { ImTuple4 as Tuple4 }
+export type ImAccess<T> = Bind.ImAccess<T>; export { ImAccess as Access };
+export type ImScalar<T> = Bind.ImScalar<T>; export { ImScalar as Scalar };
+export type ImTuple2<T> = Bind.ImTuple2<T>; export { ImTuple2 as Tuple2 };
+export type ImTuple3<T> = Bind.ImTuple3<T>; export { ImTuple3 as Tuple3 };
+export type ImTuple4<T> = Bind.ImTuple4<T>; export { ImTuple4 as Tuple4 };
 
-export { ImTextureID as TextureID }
+export { ImTextureID as TextureID };
 export type ImTextureID = WebGLTexture;
-export { ImGuiID as ID }
+export { ImGuiID as ID };
 export type ImGuiID = Bind.ImGuiID;
 
 // Flags for ImGui::Begin()
 export { ImGuiWindowFlags as WindowFlags };
 export enum ImGuiWindowFlags {
-    None                   = 0,
-    NoTitleBar             = 1 << 0,   // Disable title-bar
-    NoResize               = 1 << 1,   // Disable user resizing with the lower-right grip
-    NoMove                 = 1 << 2,   // Disable user moving the window
-    NoScrollbar            = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programatically)
-    NoScrollWithMouse      = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
-    NoCollapse             = 1 << 5,   // Disable user collapsing window by double-clicking on it
-    AlwaysAutoResize       = 1 << 6,   // Resize every window to its content every frame
-    NoBackground           = 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
-    NoSavedSettings        = 1 << 8,   // Never load/save settings in .ini file
-    NoMouseInputs          = 1 << 9,   // Disable catching mouse or keyboard inputs, hovering test with pass through.
-    MenuBar                = 1 << 10,  // Has a menu-bar
-    HorizontalScrollbar    = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
-    NoFocusOnAppearing     = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state
-    NoBringToFrontOnFocus  = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programatically giving it focus)
-    AlwaysVerticalScrollbar= 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)
-    AlwaysHorizontalScrollbar= 1 << 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
-    AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
-    NoNavInputs            = 1 << 18,  // No gamepad/keyboard navigation within the window
-    NoNavFocus             = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)
-    UnsavedDocument        = 1 << 20,  // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker.
-    NoNav                  = NoNavInputs | NoNavFocus,
-    NoDecoration           = NoTitleBar | NoResize | NoScrollbar | NoCollapse,
-    NoInputs               = NoMouseInputs | NoNavInputs | NoNavFocus,
-
-    // [Internal]
-    NavFlattened           = 1 << 23,  // (WIP) Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)
-    ChildWindow            = 1 << 24,  // Don't use! For internal use by BeginChild()
-    Tooltip                = 1 << 25,  // Don't use! For internal use by BeginTooltip()
-    Popup                  = 1 << 26,  // Don't use! For internal use by BeginPopup()
-    Modal                  = 1 << 27,  // Don't use! For internal use by BeginPopupModal()
-    ChildMenu              = 1 << 28,   // Don't use! For internal use by BeginMenu()
+  None = 0,
+  NoTitleBar = 1 << 0,   // Disable title-bar
+  NoResize = 1 << 1,   // Disable user resizing with the lower-right grip
+  NoMove = 1 << 2,   // Disable user moving the window
+  NoScrollbar = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programatically)
+  NoScrollWithMouse = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
+  NoCollapse = 1 << 5,   // Disable user collapsing window by double-clicking on it
+  AlwaysAutoResize = 1 << 6,   // Resize every window to its content every frame
+  NoBackground = 1 << 7,   // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
+  NoSavedSettings = 1 << 8,   // Never load/save settings in .ini file
+  NoMouseInputs = 1 << 9,   // Disable catching mouse or keyboard inputs, hovering test with pass through.
+  MenuBar = 1 << 10,  // Has a menu-bar
+  HorizontalScrollbar = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
+  NoFocusOnAppearing = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state
+  NoBringToFrontOnFocus = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programatically giving it focus)
+  AlwaysVerticalScrollbar = 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)
+  AlwaysHorizontalScrollbar = 1 << 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
+  AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
+  NoNavInputs = 1 << 18,  // No gamepad/keyboard navigation within the window
+  NoNavFocus = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)
+  UnsavedDocument = 1 << 20,  // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker.
+  NoNav = NoNavInputs | NoNavFocus,
+  NoDecoration = NoTitleBar | NoResize | NoScrollbar | NoCollapse,
+  NoInputs = NoMouseInputs | NoNavInputs | NoNavFocus,
+
+  // [Internal]
+  NavFlattened = 1 << 23,  // (WIP) Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)
+  ChildWindow = 1 << 24,  // Don't use! For internal use by BeginChild()
+  Tooltip = 1 << 25,  // Don't use! For internal use by BeginTooltip()
+  Popup = 1 << 26,  // Don't use! For internal use by BeginPopup()
+  Modal = 1 << 27,  // Don't use! For internal use by BeginPopupModal()
+  ChildMenu = 1 << 28,   // Don't use! For internal use by BeginMenu()
 }
 
 // Flags for ImGui::InputText()
 export { ImGuiInputTextFlags as InputTextFlags };
 export enum ImGuiInputTextFlags {
-    None                = 0,
-    CharsDecimal        = 1 << 0,   // Allow 0123456789.+-*/
-    CharsHexadecimal    = 1 << 1,   // Allow 0123456789ABCDEFabcdef
-    CharsUppercase      = 1 << 2,   // Turn a..z into A..Z
-    CharsNoBlank        = 1 << 3,   // Filter out spaces, tabs
-    AutoSelectAll       = 1 << 4,   // Select entire text when first taking mouse focus
-    EnterReturnsTrue    = 1 << 5,   // Return 'true' when Enter is pressed (as opposed to when the value was modified)
-    CallbackCompletion  = 1 << 6,   // Call user function on pressing TAB (for completion handling)
-    CallbackHistory     = 1 << 7,   // Call user function on pressing Up/Down arrows (for history handling)
-    CallbackAlways      = 1 << 8,   // Call user function every time. User code may query cursor position, modify text buffer.
-    CallbackCharFilter  = 1 << 9,   // Call user function to filter character. Modify data->EventChar to replace/filter input, or return 1 to discard character.
-    AllowTabInput       = 1 << 10,  // Pressing TAB input a '\t' character into the text field
-    CtrlEnterForNewLine = 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).
-    NoHorizontalScroll  = 1 << 12,  // Disable following the cursor horizontally
-    AlwaysInsertMode    = 1 << 13,  // Insert mode
-    ReadOnly            = 1 << 14,  // Read-only mode
-    Password            = 1 << 15,  // Password mode, display all characters as '*'
-    NoUndoRedo          = 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().
-    CharsScientific     = 1 << 17,  // Allow 0123456789.+-*/eE (Scientific notation input)
-    CallbackResize      = 1 << 18,  // Allow buffer capacity resize + notify when the string wants to be resized (for string types which hold a cache of their Size) (see misc/stl/imgui_stl.h for an example of using this)
-    CallbackEdit        = 1 << 19,  // Callback on any edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)
-    // [Internal]
-    Multiline           = 1 << 20,   // For internal use by InputTextMultiline()
-    NoMarkEdited        = 1 << 21,   // For internal use by functions using InputText() before reformatting data
+  None = 0,
+  CharsDecimal = 1 << 0,   // Allow 0123456789.+-*/
+  CharsHexadecimal = 1 << 1,   // Allow 0123456789ABCDEFabcdef
+  CharsUppercase = 1 << 2,   // Turn a..z into A..Z
+  CharsNoBlank = 1 << 3,   // Filter out spaces, tabs
+  AutoSelectAll = 1 << 4,   // Select entire text when first taking mouse focus
+  EnterReturnsTrue = 1 << 5,   // Return 'true' when Enter is pressed (as opposed to when the value was modified)
+  CallbackCompletion = 1 << 6,   // Call user function on pressing TAB (for completion handling)
+  CallbackHistory = 1 << 7,   // Call user function on pressing Up/Down arrows (for history handling)
+  CallbackAlways = 1 << 8,   // Call user function every time. User code may query cursor position, modify text buffer.
+  CallbackCharFilter = 1 << 9,   // Call user function to filter character. Modify data->EventChar to replace/filter input, or return 1 to discard character.
+  AllowTabInput = 1 << 10,  // Pressing TAB input a '\t' character into the text field
+  CtrlEnterForNewLine = 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).
+  NoHorizontalScroll = 1 << 12,  // Disable following the cursor horizontally
+  AlwaysInsertMode = 1 << 13,  // Insert mode
+  ReadOnly = 1 << 14,  // Read-only mode
+  Password = 1 << 15,  // Password mode, display all characters as '*'
+  NoUndoRedo = 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().
+  CharsScientific = 1 << 17,  // Allow 0123456789.+-*/eE (Scientific notation input)
+  CallbackResize = 1 << 18,  // Allow buffer capacity resize + notify when the string wants to be resized (for string types which hold a cache of their Size) (see misc/stl/imgui_stl.h for an example of using this)
+  CallbackEdit = 1 << 19,  // Callback on any edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)
+  // [Internal]
+  Multiline = 1 << 20,   // For internal use by InputTextMultiline()
+  NoMarkEdited = 1 << 21,   // For internal use by functions using InputText() before reformatting data
 }
 
 // Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()
 export { ImGuiTreeNodeFlags as TreeNodeFlags };
 export enum ImGuiTreeNodeFlags {
-    None                 = 0,
-    Selected             = 1 << 0,   // Draw as selected
-    Framed               = 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)
-    AllowItemOverlap     = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one
-    NoTreePushOnOpen     = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
-    NoAutoOpenOnLog      = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
-    DefaultOpen          = 1 << 5,   // Default node to be open
-    OpenOnDoubleClick    = 1 << 6,   // Need double-click to open node
-    OpenOnArrow          = 1 << 7,   // Only open when clicking on the arrow part. If OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.
-    Leaf                 = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes).
-    Bullet               = 1 << 9,   // Display a bullet instead of arrow
-    FramePadding         = 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().
-    SpanAvailWidth       = 1 << 11,  // Extend hit box to the right-most edge, even if not framed. This is not the default in order to allow adding other items on the same line. In the future we may refactor the hit system to be front-to-back, allowing natural overlaps and then this can become the default.
-    SpanFullWidth        = 1 << 12,  // Extend hit box to the left-most and right-most edges (bypass the indented area).
-    NavLeftJumpsBackHere = 1 << 13,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)
-    CollapsingHeader     = Framed | NoTreePushOnOpen | NoAutoOpenOnLog,
+  None = 0,
+  Selected = 1 << 0,   // Draw as selected
+  Framed = 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)
+  AllowItemOverlap = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one
+  NoTreePushOnOpen = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
+  NoAutoOpenOnLog = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
+  DefaultOpen = 1 << 5,   // Default node to be open
+  OpenOnDoubleClick = 1 << 6,   // Need double-click to open node
+  OpenOnArrow = 1 << 7,   // Only open when clicking on the arrow part. If OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.
+  Leaf = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes).
+  Bullet = 1 << 9,   // Display a bullet instead of arrow
+  FramePadding = 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().
+  SpanAvailWidth = 1 << 11,  // Extend hit box to the right-most edge, even if not framed. This is not the default in order to allow adding other items on the same line. In the future we may refactor the hit system to be front-to-back, allowing natural overlaps and then this can become the default.
+  SpanFullWidth = 1 << 12,  // Extend hit box to the left-most and right-most edges (bypass the indented area).
+  NavLeftJumpsBackHere = 1 << 13,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)
+  CollapsingHeader = Framed | NoTreePushOnOpen | NoAutoOpenOnLog,
 }
 
 export { ImGuiPopupFlags as PopupFlags };
 export enum ImGuiPopupFlags {
-    None                    = 0,
-    MouseButtonLeft         = 0,        // For BeginPopupContext*(): open on Left Mouse release. Guaranteed to always be == 0 (same as ImGuiMouseButton_Left)
-    MouseButtonRight        = 1,        // For BeginPopupContext*(): open on Right Mouse release. Guaranteed to always be == 1 (same as ImGuiMouseButton_Right)
-    MouseButtonMiddle       = 2,        // For BeginPopupContext*(): open on Middle Mouse release. Guaranteed to always be == 2 (same as ImGuiMouseButton_Middle)
-    MouseButtonMask_        = 0x1F,
-    MouseButtonDefault_     = 1,
-    NoOpenOverExistingPopup = 1 << 5,   // For OpenPopup*(), BeginPopupContext*(): don't open if there's already a popup at the same level of the popup stack
-    NoOpenOverItems         = 1 << 6,   // For BeginPopupContextWindow(): don't return true when hovering items, only when hovering empty space
-    AnyPopupId              = 1 << 7,   // For IsPopupOpen(): ignore the ImGuiID parameter and test for any popup.
-    AnyPopupLevel           = 1 << 8,   // For IsPopupOpen(): search/test at any level of the popup stack (default test in the current level)
-    AnyPopup                = AnyPopupId | AnyPopupLevel
+  None = 0,
+  MouseButtonLeft = 0,        // For BeginPopupContext*(): open on Left Mouse release. Guaranteed to always be == 0 (same as ImGuiMouseButton_Left)
+  MouseButtonRight = 1,        // For BeginPopupContext*(): open on Right Mouse release. Guaranteed to always be == 1 (same as ImGuiMouseButton_Right)
+  MouseButtonMiddle = 2,        // For BeginPopupContext*(): open on Middle Mouse release. Guaranteed to always be == 2 (same as ImGuiMouseButton_Middle)
+  MouseButtonMask_ = 0x1F,
+  MouseButtonDefault_ = 1,
+  NoOpenOverExistingPopup = 1 << 5,   // For OpenPopup*(), BeginPopupContext*(): don't open if there's already a popup at the same level of the popup stack
+  NoOpenOverItems = 1 << 6,   // For BeginPopupContextWindow(): don't return true when hovering items, only when hovering empty space
+  AnyPopupId = 1 << 7,   // For IsPopupOpen(): ignore the ImGuiID parameter and test for any popup.
+  AnyPopupLevel = 1 << 8,   // For IsPopupOpen(): search/test at any level of the popup stack (default test in the current level)
+  AnyPopup = AnyPopupId | AnyPopupLevel
 }
 
 // Flags for ImGui::Selectable()
 export { ImGuiSelectableFlags as SelectableFlags };
 export enum ImGuiSelectableFlags {
-    None               = 0,
-    DontClosePopups    = 1 << 0,   // Clicking this don't close parent popup window
-    SpanAllColumns     = 1 << 1,   // Selectable frame can span all columns (text will still fit in current column)
-    AllowDoubleClick   = 1 << 2,   // Generate press events on double clicks too
-    Disabled           = 1 << 3,   // Cannot be selected, display greyed out text
-    AllowItemOverlap   = 1 << 4    // (WIP) Hit testing to allow subsequent widgets to overlap this one
+  None = 0,
+  DontClosePopups = 1 << 0,   // Clicking this don't close parent popup window
+  SpanAllColumns = 1 << 1,   // Selectable frame can span all columns (text will still fit in current column)
+  AllowDoubleClick = 1 << 2,   // Generate press events on double clicks too
+  Disabled = 1 << 3,   // Cannot be selected, display greyed out text
+  AllowItemOverlap = 1 << 4    // (WIP) Hit testing to allow subsequent widgets to overlap this one
 }
 
 // Flags for ImGui::BeginCombo()
 export { ImGuiComboFlags as ComboFlags };
 export enum ImGuiComboFlags {
-    None                    = 0,
-    PopupAlignLeft          = 1 << 0,   // Align the popup toward the left by default
-    HeightSmall             = 1 << 1,   // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()
-    HeightRegular           = 1 << 2,   // Max ~8 items visible (default)
-    HeightLarge             = 1 << 3,   // Max ~20 items visible
-    HeightLargest           = 1 << 4,   // As many fitting items as possible
-    NoArrowButton           = 1 << 5,   // Display on the preview box without the square arrow button
-    NoPreview               = 1 << 6,   // Display only a square arrow button
-    HeightMask_             = HeightSmall | HeightRegular | HeightLarge | HeightLargest,
+  None = 0,
+  PopupAlignLeft = 1 << 0,   // Align the popup toward the left by default
+  HeightSmall = 1 << 1,   // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()
+  HeightRegular = 1 << 2,   // Max ~8 items visible (default)
+  HeightLarge = 1 << 3,   // Max ~20 items visible
+  HeightLargest = 1 << 4,   // As many fitting items as possible
+  NoArrowButton = 1 << 5,   // Display on the preview box without the square arrow button
+  NoPreview = 1 << 6,   // Display only a square arrow button
+  HeightMask_ = HeightSmall | HeightRegular | HeightLarge | HeightLargest,
 }
 
 // Flags for ImGui::BeginTabBar()
 export { ImGuiTabBarFlags as TabBarFlags };
 export enum ImGuiTabBarFlags {
-    None                           = 0,
-    Reorderable                    = 1 << 0,   // Allow manually dragging tabs to re-order them + New tabs are appended at the end of list
-    AutoSelectNewTabs              = 1 << 1,   // Automatically select new tabs when they appear
-    TabListPopupButton             = 1 << 2,
-    NoCloseWithMiddleMouseButton   = 1 << 3,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
-    NoTabListScrollingButtons      = 1 << 4,
-    NoTooltip                      = 1 << 5,   // Disable tooltips when hovering a tab
-    FittingPolicyResizeDown        = 1 << 6,   // Resize tabs when they don't fit
-    FittingPolicyScroll            = 1 << 7,   // Add scroll buttons when tabs don't fit
-    FittingPolicyMask_             = FittingPolicyResizeDown | FittingPolicyScroll,
-    FittingPolicyDefault_          = FittingPolicyResizeDown
+  None = 0,
+  Reorderable = 1 << 0,   // Allow manually dragging tabs to re-order them + New tabs are appended at the end of list
+  AutoSelectNewTabs = 1 << 1,   // Automatically select new tabs when they appear
+  TabListPopupButton = 1 << 2,
+  NoCloseWithMiddleMouseButton = 1 << 3,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
+  NoTabListScrollingButtons = 1 << 4,
+  NoTooltip = 1 << 5,   // Disable tooltips when hovering a tab
+  FittingPolicyResizeDown = 1 << 6,   // Resize tabs when they don't fit
+  FittingPolicyScroll = 1 << 7,   // Add scroll buttons when tabs don't fit
+  FittingPolicyMask_ = FittingPolicyResizeDown | FittingPolicyScroll,
+  FittingPolicyDefault_ = FittingPolicyResizeDown
 };
 
 // Flags for ImGui::BeginTabItem()
 export { ImGuiTabItemFlags as TabItemFlags };
 export enum ImGuiTabItemFlags {
-    None                          = 0,
-    UnsavedDocument               = 1 << 0,   // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it without flicker.
-    SetSelected                   = 1 << 1,   // Trigger flag to programatically make the tab selected when calling BeginTabItem()
-    NoCloseWithMiddleMouseButton  = 1 << 2,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
-    NoPushId                      = 1 << 3,   // Don't call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem()
-    NoTooltip                     = 1 << 4,   // Disable tooltip for the given tab
-    NoReorder                     = 1 << 5,   // Disable reordering this tab or having another tab cross over this tab
-    Leading                       = 1 << 6,   // Enforce the tab position to the left of the tab bar (after the tab list popup button)
-    Trailing                      = 1 << 7    // Enforce the tab position to the right of the tab bar (before the scrolling buttons)
+  None = 0,
+  UnsavedDocument = 1 << 0,   // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it without flicker.
+  SetSelected = 1 << 1,   // Trigger flag to programatically make the tab selected when calling BeginTabItem()
+  NoCloseWithMiddleMouseButton = 1 << 2,   // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
+  NoPushId = 1 << 3,   // Don't call PushID(tab->ID)/PopID() on BeginTabItem()/EndTabItem()
+  NoTooltip = 1 << 4,   // Disable tooltip for the given tab
+  NoReorder = 1 << 5,   // Disable reordering this tab or having another tab cross over this tab
+  Leading = 1 << 6,   // Enforce the tab position to the left of the tab bar (after the tab list popup button)
+  Trailing = 1 << 7    // Enforce the tab position to the right of the tab bar (before the scrolling buttons)
 }
 
 export { ImGuiTableFlags as TableFlags };
 export enum ImGuiTableFlags {
-    // Features
-    None                       = 0,
-    Resizable                  = 1 << 0,   // Enable resizing columns.
-    Reorderable                = 1 << 1,   // Enable reordering columns in header row (need calling TableSetupColumn() + TableHeadersRow() to display headers)
-    Hideable                   = 1 << 2,   // Enable hiding/disabling columns in context menu.
-    Sortable                   = 1 << 3,   // Enable sorting. Call TableGetSortSpecs() to obtain sort specs. Also see ImGuiTableFlags_SortMulti and ImGuiTableFlags_SortTristate.
-    NoSavedSettings            = 1 << 4,   // Disable persisting columns order, width and sort settings in the .ini file.
-    ContextMenuInBody          = 1 << 5,   // Right-click on columns body/contents will display table context menu. By default it is available in TableHeadersRow().
-    // Decorations
-    RowBg                      = 1 << 6,   // Set each RowBg color with ImGuiCol_TableRowBg or ImGuiCol_TableRowBgAlt (equivalent of calling TableSetBgColor with ImGuiTableBgFlags_RowBg0 on each row manually)
-    BordersInnerH              = 1 << 7,   // Draw horizontal borders between rows.
-    BordersOuterH              = 1 << 8,   // Draw horizontal borders at the top and bottom.
-    BordersInnerV              = 1 << 9,   // Draw vertical borders between columns.
-    BordersOuterV              = 1 << 10,  // Draw vertical borders on the left and right sides.
-    BordersH                   = BordersInnerH | BordersOuterH, // Draw horizontal borders.
-    BordersV                   = BordersInnerV | BordersOuterV, // Draw vertical borders.
-    BordersInner               = BordersInnerV | BordersInnerH, // Draw inner borders.
-    BordersOuter               = BordersOuterV | BordersOuterH, // Draw outer borders.
-    Borders                    = BordersInner | BordersOuter,   // Draw all borders.
-    NoBordersInBody            = 1 << 11,  // [ALPHA] Disable vertical borders in columns Body (borders will always appears in Headers). -> May move to style
-    NoBordersInBodyUntilResize = 1 << 12,  // [ALPHA] Disable vertical borders in columns Body until hovered for resize (borders will always appears in Headers). -> May move to style
-    // Sizing Policy (read above for defaults)
-    SizingFixedFit             = 1 << 13,  // Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching contents width.
-    SizingFixedSame            = 2 << 13,  // Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching the maximum contents width of all columns. Implicitly enable ImGuiTableFlags_NoKeepColumnsVisible.
-    SizingStretchProp          = 3 << 13,  // Columns default to _WidthStretch with default weights proportional to each columns contents widths.
-    SizingStretchSame          = 4 << 13,  // Columns default to _WidthStretch with default weights all equal, unless overriden by TableSetupColumn().
-    // Sizing Extra Options
-    NoHostExtendX              = 1 << 16,  // Make outer width auto-fit to columns, overriding outer_size.x value. Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.
-    NoHostExtendY              = 1 << 17,  // Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX/ScrollY are disabled. Data below the limit will be clipped and not visible.
-    NoKeepColumnsVisible       = 1 << 18,  // Disable keeping column always minimally visible when ScrollX is off and table gets too small. Not recommended if columns are resizable.
-    PreciseWidths              = 1 << 19,  // Disable distributing remainder width to stretched columns (width allocation on a 100-wide table with 3 columns: Without this flag: 33,33,34. With this flag: 33,33,33). With larger number of columns, resizing will appear to be less smooth.
-    // Clipping
-    NoClip                     = 1 << 20,  // Disable clipping rectangle for every individual columns (reduce draw command count, items will be able to overflow into other columns). Generally incompatible with TableSetupScrollFreeze().
-    // Padding
-    PadOuterX                  = 1 << 21,  // Default if BordersOuterV is on. Enable outer-most padding. Generally desirable if you have headers.
-    NoPadOuterX                = 1 << 22,  // Default if BordersOuterV is off. Disable outer-most padding.
-    NoPadInnerX                = 1 << 23,  // Disable inner padding between columns (double inner padding if BordersOuterV is on, single inner padding if BordersOuterV is off).
-    // Scrolling
-    ScrollX                    = 1 << 24,  // Enable horizontal scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size. Changes default sizing policy. Because this create a child window, ScrollY is currently generally recommended when using ScrollX.
-    ScrollY                    = 1 << 25,  // Enable vertical scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size.
-    // Sorting
-    SortMulti                  = 1 << 26,  // Hold shift when clicking headers to sort on multiple column. TableGetSortSpecs() may return specs where (SpecsCount > 1).
-    SortTristate               = 1 << 27,  // Allow no sorting, disable default sorting. TableGetSortSpecs() may return specs where (SpecsCount == 0).
-
-    // [Internal] Combinations and masks
-    SizingMask_                = SizingFixedFit | SizingFixedSame | SizingStretchProp | SizingStretchSame
+  // Features
+  None = 0,
+  Resizable = 1 << 0,   // Enable resizing columns.
+  Reorderable = 1 << 1,   // Enable reordering columns in header row (need calling TableSetupColumn() + TableHeadersRow() to display headers)
+  Hideable = 1 << 2,   // Enable hiding/disabling columns in context menu.
+  Sortable = 1 << 3,   // Enable sorting. Call TableGetSortSpecs() to obtain sort specs. Also see ImGuiTableFlags_SortMulti and ImGuiTableFlags_SortTristate.
+  NoSavedSettings = 1 << 4,   // Disable persisting columns order, width and sort settings in the .ini file.
+  ContextMenuInBody = 1 << 5,   // Right-click on columns body/contents will display table context menu. By default it is available in TableHeadersRow().
+  // Decorations
+  RowBg = 1 << 6,   // Set each RowBg color with ImGuiCol_TableRowBg or ImGuiCol_TableRowBgAlt (equivalent of calling TableSetBgColor with ImGuiTableBgFlags_RowBg0 on each row manually)
+  BordersInnerH = 1 << 7,   // Draw horizontal borders between rows.
+  BordersOuterH = 1 << 8,   // Draw horizontal borders at the top and bottom.
+  BordersInnerV = 1 << 9,   // Draw vertical borders between columns.
+  BordersOuterV = 1 << 10,  // Draw vertical borders on the left and right sides.
+  BordersH = BordersInnerH | BordersOuterH, // Draw horizontal borders.
+  BordersV = BordersInnerV | BordersOuterV, // Draw vertical borders.
+  BordersInner = BordersInnerV | BordersInnerH, // Draw inner borders.
+  BordersOuter = BordersOuterV | BordersOuterH, // Draw outer borders.
+  Borders = BordersInner | BordersOuter,   // Draw all borders.
+  NoBordersInBody = 1 << 11,  // [ALPHA] Disable vertical borders in columns Body (borders will always appears in Headers). -> May move to style
+  NoBordersInBodyUntilResize = 1 << 12,  // [ALPHA] Disable vertical borders in columns Body until hovered for resize (borders will always appears in Headers). -> May move to style
+  // Sizing Policy (read above for defaults)
+  SizingFixedFit = 1 << 13,  // Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching contents width.
+  SizingFixedSame = 2 << 13,  // Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching the maximum contents width of all columns. Implicitly enable ImGuiTableFlags_NoKeepColumnsVisible.
+  SizingStretchProp = 3 << 13,  // Columns default to _WidthStretch with default weights proportional to each columns contents widths.
+  SizingStretchSame = 4 << 13,  // Columns default to _WidthStretch with default weights all equal, unless overriden by TableSetupColumn().
+  // Sizing Extra Options
+  NoHostExtendX = 1 << 16,  // Make outer width auto-fit to columns, overriding outer_size.x value. Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.
+  NoHostExtendY = 1 << 17,  // Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX/ScrollY are disabled. Data below the limit will be clipped and not visible.
+  NoKeepColumnsVisible = 1 << 18,  // Disable keeping column always minimally visible when ScrollX is off and table gets too small. Not recommended if columns are resizable.
+  PreciseWidths = 1 << 19,  // Disable distributing remainder width to stretched columns (width allocation on a 100-wide table with 3 columns: Without this flag: 33,33,34. With this flag: 33,33,33). With larger number of columns, resizing will appear to be less smooth.
+  // Clipping
+  NoClip = 1 << 20,  // Disable clipping rectangle for every individual columns (reduce draw command count, items will be able to overflow into other columns). Generally incompatible with TableSetupScrollFreeze().
+  // Padding
+  PadOuterX = 1 << 21,  // Default if BordersOuterV is on. Enable outer-most padding. Generally desirable if you have headers.
+  NoPadOuterX = 1 << 22,  // Default if BordersOuterV is off. Disable outer-most padding.
+  NoPadInnerX = 1 << 23,  // Disable inner padding between columns (double inner padding if BordersOuterV is on, single inner padding if BordersOuterV is off).
+  // Scrolling
+  ScrollX = 1 << 24,  // Enable horizontal scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size. Changes default sizing policy. Because this create a child window, ScrollY is currently generally recommended when using ScrollX.
+  ScrollY = 1 << 25,  // Enable vertical scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size.
+  // Sorting
+  SortMulti = 1 << 26,  // Hold shift when clicking headers to sort on multiple column. TableGetSortSpecs() may return specs where (SpecsCount > 1).
+  SortTristate = 1 << 27,  // Allow no sorting, disable default sorting. TableGetSortSpecs() may return specs where (SpecsCount == 0).
+
+  // [Internal] Combinations and masks
+  SizingMask_ = SizingFixedFit | SizingFixedSame | SizingStretchProp | SizingStretchSame
 }
 
 // Flags for ImGui::TableSetupColumn()
 export { ImGuiTableColumnFlags as TableColumnFlags };
 export enum ImGuiTableColumnFlags {
-    // Input configuration flags
-    None                  = 0,
-    DefaultHide           = 1 << 0,   // Default as a hidden/disabled column.
-    DefaultSort           = 1 << 1,   // Default as a sorting column.
-    WidthStretch          = 1 << 2,   // Column will stretch. Preferable with horizontal scrolling disabled (default if table sizing policy is _SizingStretchSame or _SizingStretchProp).
-    WidthFixed            = 1 << 3,   // Column will not stretch. Preferable with horizontal scrolling enabled (default if table sizing policy is _SizingFixedFit and table is resizable).
-    NoResize              = 1 << 4,   // Disable manual resizing.
-    NoReorder             = 1 << 5,   // Disable manual reordering this column, this will also prevent other columns from crossing over this column.
-    NoHide                = 1 << 6,   // Disable ability to hide/disable this column.
-    NoClip                = 1 << 7,   // Disable clipping for this column (all NoClip columns will render in a same draw command).
-    NoSort                = 1 << 8,   // Disable ability to sort on this field (even if ImGuiTableFlags_Sortable is set on the table).
-    NoSortAscending       = 1 << 9,   // Disable ability to sort in the ascending direction.
-    NoSortDescending      = 1 << 10,  // Disable ability to sort in the descending direction.
-    NoHeaderWidth         = 1 << 11,  // Disable header text width contribution to automatic column width.
-    PreferSortAscending   = 1 << 12,  // Make the initial sort direction Ascending when first sorting on this column (default).
-    PreferSortDescending  = 1 << 13,  // Make the initial sort direction Descending when first sorting on this column.
-    IndentEnable          = 1 << 14,  // Use current Indent value when entering cell (default for column 0).
-    IndentDisable         = 1 << 15,  // Ignore current Indent value when entering cell (default for columns > 0). Indentation changes _within_ the cell will still be honored.
-
-    // Output status flags, read-only via TableGetColumnFlags()
-    IsEnabled             = 1 << 20,  // Status: is enabled == not hidden by user/api (referred to as "Hide" in _DefaultHide and _NoHide) flags.
-    IsVisible             = 1 << 21,  // Status: is visible == is enabled AND not clipped by scrolling.
-    IsSorted              = 1 << 22,  // Status: is currently part of the sort specs
-    IsHovered             = 1 << 23,  // Status: is hovered by mouse
-
-    // [Internal] Combinations and masks
-    WidthMask_            = WidthStretch | WidthFixed,
-    IndentMask_           = IndentEnable | IndentDisable,
-    StatusMask_           = IsEnabled | IsVisible | IsSorted | IsHovered,
-    NoDirectResize_       = 1 << 30   // [Internal] Disable user resizing this column directly (it may however we resized indirectly from its left edge)
+  // Input configuration flags
+  None = 0,
+  DefaultHide = 1 << 0,   // Default as a hidden/disabled column.
+  DefaultSort = 1 << 1,   // Default as a sorting column.
+  WidthStretch = 1 << 2,   // Column will stretch. Preferable with horizontal scrolling disabled (default if table sizing policy is _SizingStretchSame or _SizingStretchProp).
+  WidthFixed = 1 << 3,   // Column will not stretch. Preferable with horizontal scrolling enabled (default if table sizing policy is _SizingFixedFit and table is resizable).
+  NoResize = 1 << 4,   // Disable manual resizing.
+  NoReorder = 1 << 5,   // Disable manual reordering this column, this will also prevent other columns from crossing over this column.
+  NoHide = 1 << 6,   // Disable ability to hide/disable this column.
+  NoClip = 1 << 7,   // Disable clipping for this column (all NoClip columns will render in a same draw command).
+  NoSort = 1 << 8,   // Disable ability to sort on this field (even if ImGuiTableFlags_Sortable is set on the table).
+  NoSortAscending = 1 << 9,   // Disable ability to sort in the ascending direction.
+  NoSortDescending = 1 << 10,  // Disable ability to sort in the descending direction.
+  NoHeaderWidth = 1 << 11,  // Disable header text width contribution to automatic column width.
+  PreferSortAscending = 1 << 12,  // Make the initial sort direction Ascending when first sorting on this column (default).
+  PreferSortDescending = 1 << 13,  // Make the initial sort direction Descending when first sorting on this column.
+  IndentEnable = 1 << 14,  // Use current Indent value when entering cell (default for column 0).
+  IndentDisable = 1 << 15,  // Ignore current Indent value when entering cell (default for columns > 0). Indentation changes _within_ the cell will still be honored.
+
+  // Output status flags, read-only via TableGetColumnFlags()
+  IsEnabled = 1 << 20,  // Status: is enabled == not hidden by user/api (referred to as "Hide" in _DefaultHide and _NoHide) flags.
+  IsVisible = 1 << 21,  // Status: is visible == is enabled AND not clipped by scrolling.
+  IsSorted = 1 << 22,  // Status: is currently part of the sort specs
+  IsHovered = 1 << 23,  // Status: is hovered by mouse
+
+  // [Internal] Combinations and masks
+  WidthMask_ = WidthStretch | WidthFixed,
+  IndentMask_ = IndentEnable | IndentDisable,
+  StatusMask_ = IsEnabled | IsVisible | IsSorted | IsHovered,
+  NoDirectResize_ = 1 << 30   // [Internal] Disable user resizing this column directly (it may however we resized indirectly from its left edge)
 }
 
 // Flags for ImGui::TableNextRow()
 export { ImGuiTableRowFlags as TableRowFlags };
 export enum ImGuiTableRowFlags {
-    None                         = 0,
-    Headers                      = 1 << 0    // Identify header row (set default background color + width of its contents accounted different for auto column width)
+  None = 0,
+  Headers = 1 << 0    // Identify header row (set default background color + width of its contents accounted different for auto column width)
 }
 
 // Enum for ImGui::TableSetBgColor()
@@ -417,54 +419,54 @@ export enum ImGuiTableRowFlags {
 // If you set the color of RowBg1 or ColumnBg1 target, your color will blend over the RowBg0 color.
 export { ImGuiTableBgTarget as TableBgTarget };
 export enum ImGuiTableBgTarget {
-    None                         = 0,
-    RowBg0                       = 1,        // Set row background color 0 (generally used for background, automatically set when ImGuiTableFlags_RowBg is used)
-    RowBg1                       = 2,        // Set row background color 1 (generally used for selection marking)
-    CellBg                       = 3         // Set cell background color (top-most color)
+  None = 0,
+  RowBg0 = 1,        // Set row background color 0 (generally used for background, automatically set when ImGuiTableFlags_RowBg is used)
+  RowBg1 = 2,        // Set row background color 1 (generally used for selection marking)
+  CellBg = 3         // Set cell background color (top-most color)
 }
 
 // Flags for ImGui::IsWindowFocused()
 export { ImGuiFocusedFlags as FocusedFlags };
 export enum ImGuiFocusedFlags {
-    None                          = 0,
-    ChildWindows                  = 1 << 0,   // IsWindowFocused(): Return true if any children of the window is focused
-    RootWindow                    = 1 << 1,   // IsWindowFocused(): Test from root window (top most parent of the current hierarchy)
-    AnyWindow                     = 1 << 2,   // IsWindowFocused(): Return true if any window is focused
-    RootAndChildWindows           = RootWindow | ChildWindows,
+  None = 0,
+  ChildWindows = 1 << 0,   // IsWindowFocused(): Return true if any children of the window is focused
+  RootWindow = 1 << 1,   // IsWindowFocused(): Test from root window (top most parent of the current hierarchy)
+  AnyWindow = 1 << 2,   // IsWindowFocused(): Return true if any window is focused
+  RootAndChildWindows = RootWindow | ChildWindows,
 }
 
 // Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()
 export { ImGuiHoveredFlags as HoveredFlags };
 export enum ImGuiHoveredFlags {
-    None                          = 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.
-    ChildWindows                  = 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered
-    RootWindow                    = 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)
-    AnyWindow                     = 1 << 2,   // IsWindowHovered() only: Return true if any window is hovered
-    AllowWhenBlockedByPopup       = 1 << 3,   // Return true even if a popup window is normally blocking access to this item/window
-    //AllowWhenBlockedByModal     = 1 << 4,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.
-    AllowWhenBlockedByActiveItem  = 1 << 5,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.
-    AllowWhenOverlapped           = 1 << 6,   // Return true even if the position is overlapped by another window
-    AllowWhenDisabled             = 1 << 7,   // Return true even if the item is disabled
-    RectOnly                      = AllowWhenBlockedByPopup | AllowWhenBlockedByActiveItem | AllowWhenOverlapped,
-    RootAndChildWindows           = RootWindow | ChildWindows,
+  None = 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.
+  ChildWindows = 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered
+  RootWindow = 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)
+  AnyWindow = 1 << 2,   // IsWindowHovered() only: Return true if any window is hovered
+  AllowWhenBlockedByPopup = 1 << 3,   // Return true even if a popup window is normally blocking access to this item/window
+  //AllowWhenBlockedByModal     = 1 << 4,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.
+  AllowWhenBlockedByActiveItem = 1 << 5,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.
+  AllowWhenOverlapped = 1 << 6,   // Return true even if the position is overlapped by another window
+  AllowWhenDisabled = 1 << 7,   // Return true even if the item is disabled
+  RectOnly = AllowWhenBlockedByPopup | AllowWhenBlockedByActiveItem | AllowWhenOverlapped,
+  RootAndChildWindows = RootWindow | ChildWindows,
 }
 
 // Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()
 export { ImGuiDragDropFlags as DragDropFlags };
 export enum ImGuiDragDropFlags {
-    // BeginDragDropSource() flags
-    None                         = 0,
-    SourceNoPreviewTooltip       = 1 << 0,       // By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.
-    SourceNoDisableHover         = 1 << 1,       // By default, when dragging we clear data so that IsItemHovered() will return true, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.
-    SourceNoHoldToOpenOthers     = 1 << 2,       // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.
-    SourceAllowNullID            = 1 << 3,       // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.
-    SourceExtern                 = 1 << 4,       // External source (from outside of imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.
-    SourceAutoExpirePayload      = 1 << 5,   // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)
-    // AcceptDragDropPayload() flags
-    AcceptBeforeDelivery         = 1 << 10,      // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.
-    AcceptNoDrawDefaultRect      = 1 << 11,      // Do not draw the default highlight rectangle when hovering over target.
-    AcceptNoPreviewTooltip       = 1 << 12,      // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.
-    AcceptPeekOnly               = AcceptBeforeDelivery | AcceptNoDrawDefaultRect,  // For peeking ahead and inspecting the payload before delivery.
+  // BeginDragDropSource() flags
+  None = 0,
+  SourceNoPreviewTooltip = 1 << 0,       // By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.
+  SourceNoDisableHover = 1 << 1,       // By default, when dragging we clear data so that IsItemHovered() will return true, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.
+  SourceNoHoldToOpenOthers = 1 << 2,       // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.
+  SourceAllowNullID = 1 << 3,       // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.
+  SourceExtern = 1 << 4,       // External source (from outside of imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.
+  SourceAutoExpirePayload = 1 << 5,   // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)
+  // AcceptDragDropPayload() flags
+  AcceptBeforeDelivery = 1 << 10,      // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.
+  AcceptNoDrawDefaultRect = 1 << 11,      // Do not draw the default highlight rectangle when hovering over target.
+  AcceptNoPreviewTooltip = 1 << 12,      // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.
+  AcceptPeekOnly = AcceptBeforeDelivery | AcceptNoDrawDefaultRect,  // For peeking ahead and inspecting the payload before delivery.
 }
 
 // Standard Drag and Drop payload types. You can define you own payload types using 12-characters long strings. Types starting with '_' are defined by Dear ImGui.
@@ -474,75 +476,75 @@ export const IMGUI_PAYLOAD_TYPE_COLOR_4F: string = "_COL4F";    // float[4]
 // A primary data type
 export { ImGuiDataType as DataType };
 export enum ImGuiDataType {
-    S8,       // char
-    U8,       // unsigned char
-    S16,      // short
-    U16,      // unsigned short
-    S32,      // int
-    U32,      // unsigned int
-    S64,      // long long, __int64
-    U64,      // unsigned long long, unsigned __int64
-    Float,    // float
-    Double,   // double
-    COUNT
+  S8,       // char
+  U8,       // unsigned char
+  S16,      // short
+  U16,      // unsigned short
+  S32,      // int
+  U32,      // unsigned int
+  S64,      // long long, __int64
+  U64,      // unsigned long long, unsigned __int64
+  Float,    // float
+  Double,   // double
+  COUNT
 }
 
 // A cardinal direction
 export { ImGuiDir as Dir };
 export enum ImGuiDir {
-    None    = -1,
-    Left    = 0,
-    Right   = 1,
-    Up      = 2,
-    Down    = 3,
-    COUNT
+  None = -1,
+  Left = 0,
+  Right = 1,
+  Up = 2,
+  Down = 3,
+  COUNT
 }
 
 // A sorting direction
 export { ImGuiSortDirection as SortDirection };
 export enum ImGuiSortDirection {
-    None         = 0,
-    Ascending    = 1,    // Ascending = 0->9, A->Z etc.
-    Descending   = 2     // Descending = 9->0, Z->A etc.
+  None = 0,
+  Ascending = 1,    // Ascending = 0->9, A->Z etc.
+  Descending = 2     // Descending = 9->0, Z->A etc.
 }
 
 
 // User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array
 export { ImGuiKey as Key };
 export enum ImGuiKey {
-    Tab,
-    LeftArrow,
-    RightArrow,
-    UpArrow,
-    DownArrow,
-    PageUp,
-    PageDown,
-    Home,
-    End,
-    Insert,
-    Delete,
-    Backspace,
-    Space,
-    Enter,
-    Escape,
-    KeyPadEnter,
-    A,         // for text edit CTRL+A: select all
-    C,         // for text edit CTRL+C: copy
-    V,         // for text edit CTRL+V: paste
-    X,         // for text edit CTRL+X: cut
-    Y,         // for text edit CTRL+Y: redo
-    Z,         // for text edit CTRL+Z: undo
-    COUNT,
+  Tab,
+  LeftArrow,
+  RightArrow,
+  UpArrow,
+  DownArrow,
+  PageUp,
+  PageDown,
+  Home,
+  End,
+  Insert,
+  Delete,
+  Backspace,
+  Space,
+  Enter,
+  Escape,
+  KeyPadEnter,
+  A,         // for text edit CTRL+A: select all
+  C,         // for text edit CTRL+C: copy
+  V,         // for text edit CTRL+V: paste
+  X,         // for text edit CTRL+X: cut
+  Y,         // for text edit CTRL+Y: redo
+  Z,         // for text edit CTRL+Z: undo
+  COUNT,
 }
 
 // To test io.KeyMods (which is a combination of individual fields io.KeyCtrl, io.KeyShift, io.KeyAlt set by user/backend)
 export { ImGuiKeyModFlags as KeyModFlags };
 export enum ImGuiKeyModFlags {
-    None       = 0,
-    Ctrl       = 1 << 0,
-    Shift      = 1 << 1,
-    Alt        = 1 << 2,
-    Super      = 1 << 3
+  None = 0,
+  Ctrl = 1 << 0,
+  Shift = 1 << 1,
+  Alt = 1 << 2,
+  Super = 1 << 3
 }
 
 // [BETA] Gamepad/Keyboard directional navigation
@@ -550,110 +552,108 @@ export enum ImGuiKeyModFlags {
 // Gamepad:  Set io.ConfigFlags |= EnableGamepad to enable. Fill the io.NavInputs[] fields before calling NewFrame(). Note that io.NavInputs[] is cleared by EndFrame().
 // Read instructions in imgui.cpp for more details.
 export { ImGuiNavInput as NavInput };
-export enum ImGuiNavInput
-{
-    // Gamepad Mapping
-    Activate,      // activate / open / toggle / tweak value       // e.g. Circle (PS4), A (Xbox), B (Switch), Space (Keyboard)
-    Cancel,        // cancel / close / exit                        // e.g. Cross  (PS4), B (Xbox), A (Switch), Escape (Keyboard)
-    Input,         // text input / on-screen keyboard              // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)
-    Menu,          // tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)
-    DpadLeft,      // move / tweak / resize window (w/ PadMenu)    // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard)
-    DpadRight,     //
-    DpadUp,        //
-    DpadDown,      //
-    LStickLeft,    // scroll / move window (w/ PadMenu)            // e.g. Left Analog Stick Left/Right/Up/Down
-    LStickRight,   //
-    LStickUp,      //
-    LStickDown,    //
-    FocusPrev,     // next window (w/ PadMenu)                     // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
-    FocusNext,     // prev window (w/ PadMenu)                     // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)
-    TweakSlow,     // slower tweaks                                // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
-    TweakFast,     // faster tweaks                                // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)
-
-    // [Internal] Don't use directly! This is used internally to differentiate keyboard from gamepad inputs for behaviors that require to differentiate them.
-    // Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) may be directly reading from io.KeyDown[] instead of io.NavInputs[].
-    KeyMenu_,      // toggle menu                                  // = io.KeyAlt
-    KeyLeft_,      // move left                                    // = Arrow keys
-    KeyRight_,     // move right
-    KeyUp_,        // move up
-    KeyDown_,      // move down
-    COUNT,
-    InternalStart_ = KeyMenu_,
+export enum ImGuiNavInput {
+  // Gamepad Mapping
+  Activate,      // activate / open / toggle / tweak value       // e.g. Circle (PS4), A (Xbox), B (Switch), Space (Keyboard)
+  Cancel,        // cancel / close / exit                        // e.g. Cross  (PS4), B (Xbox), A (Switch), Escape (Keyboard)
+  Input,         // text input / on-screen keyboard              // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)
+  Menu,          // tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)
+  DpadLeft,      // move / tweak / resize window (w/ PadMenu)    // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard)
+  DpadRight,     //
+  DpadUp,        //
+  DpadDown,      //
+  LStickLeft,    // scroll / move window (w/ PadMenu)            // e.g. Left Analog Stick Left/Right/Up/Down
+  LStickRight,   //
+  LStickUp,      //
+  LStickDown,    //
+  FocusPrev,     // next window (w/ PadMenu)                     // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
+  FocusNext,     // prev window (w/ PadMenu)                     // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)
+  TweakSlow,     // slower tweaks                                // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
+  TweakFast,     // faster tweaks                                // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)
+
+  // [Internal] Don't use directly! This is used internally to differentiate keyboard from gamepad inputs for behaviors that require to differentiate them.
+  // Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) may be directly reading from io.KeyDown[] instead of io.NavInputs[].
+  KeyMenu_,      // toggle menu                                  // = io.KeyAlt
+  KeyLeft_,      // move left                                    // = Arrow keys
+  KeyRight_,     // move right
+  KeyUp_,        // move up
+  KeyDown_,      // move down
+  COUNT,
+  InternalStart_ = KeyMenu_,
 }
 
 // [BETA] Gamepad/Keyboard directional navigation flags, stored in io.ConfigFlags
 export { ImGuiConfigFlags as ConfigFlags };
-export enum ImGuiConfigFlags
-{
-    None                 = 0,
-    NavEnableKeyboard    = 1 << 0,   // Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeyDown[].
-    NavEnableGamepad     = 1 << 1,   // Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[].
-    NavEnableSetMousePos = 1 << 2,   // Request navigation to allow moving the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantMoveMouse=true. If enabled you MUST honor io.WantMoveMouse requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth.
-    NavNoCaptureKeyboard = 1 << 3,    // Do not set the io.WantCaptureKeyboard flag with io.NavActive is set.
-    NoMouse              = 1 << 4,   // Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information back-end
-    NoMouseCursorChange  = 1 << 5,   // Instruct back-end to not alter mouse cursor shape and visibility.
+export enum ImGuiConfigFlags {
+  None = 0,
+  NavEnableKeyboard = 1 << 0,   // Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeyDown[].
+  NavEnableGamepad = 1 << 1,   // Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[].
+  NavEnableSetMousePos = 1 << 2,   // Request navigation to allow moving the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantMoveMouse=true. If enabled you MUST honor io.WantMoveMouse requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth.
+  NavNoCaptureKeyboard = 1 << 3,    // Do not set the io.WantCaptureKeyboard flag with io.NavActive is set.
+  NoMouse = 1 << 4,   // Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information back-end
+  NoMouseCursorChange = 1 << 5,   // Instruct back-end to not alter mouse cursor shape and visibility.
 
-    IsSRGB               = 1 << 20,  // Application is SRGB-aware.
-    IsTouchScreen        = 1 << 21   // Application is using a touch screen instead of a mouse.
+  IsSRGB = 1 << 20,  // Application is SRGB-aware.
+  IsTouchScreen = 1 << 21   // Application is using a touch screen instead of a mouse.
 }
 
 // Enumeration for PushStyleColor() / PopStyleColor()
 export { ImGuiCol as Col };
 export enum ImGuiCol {
-    Text,
-    TextDisabled,
-    WindowBg,              // Background of normal windows
-    ChildBg,               // Background of child windows
-    PopupBg,               // Background of popups, menus, tooltips windows
-    Border,
-    BorderShadow,
-    FrameBg,               // Background of checkbox, radio button, plot, slider, text input
-    FrameBgHovered,
-    FrameBgActive,
-    TitleBg,
-    TitleBgActive,
-    TitleBgCollapsed,
-    MenuBarBg,
-    ScrollbarBg,
-    ScrollbarGrab,
-    ScrollbarGrabHovered,
-    ScrollbarGrabActive,
-    CheckMark,
-    SliderGrab,
-    SliderGrabActive,
-    Button,
-    ButtonHovered,
-    ButtonActive,
-    Header,
-    HeaderHovered,
-    HeaderActive,
-    Separator,
-    SeparatorHovered,
-    SeparatorActive,
-    ResizeGrip,
-    ResizeGripHovered,
-    ResizeGripActive,
-    Tab,
-    TabHovered,
-    TabActive,
-    TabUnfocused,
-    TabUnfocusedActive,
-    PlotLines,
-    PlotLinesHovered,
-    PlotHistogram,
-    PlotHistogramHovered,
-    TableHeaderBg,         // Table header background
-    TableBorderStrong,     // Table outer and header borders (prefer using Alpha=1.0 here)
-    TableBorderLight,      // Table inner borders (prefer using Alpha=1.0 here)
-    TableRowBg,            // Table row background (even rows)
-    TableRowBgAlt,         // Table row background (odd rows)
-    TextSelectedBg,
-    DragDropTarget,
-    NavHighlight,          // Gamepad/keyboard: current highlighted item
-    NavWindowingHighlight, // Highlight window when using CTRL+TAB
-    NavWindowingDimBg,     // Darken/colorize entire screen behind the CTRL+TAB window list, when active
-    ModalWindowDimBg,      // Darken/colorize entire screen behind a modal window, when one is active
-    COUNT,
+  Text,
+  TextDisabled,
+  WindowBg,              // Background of normal windows
+  ChildBg,               // Background of child windows
+  PopupBg,               // Background of popups, menus, tooltips windows
+  Border,
+  BorderShadow,
+  FrameBg,               // Background of checkbox, radio button, plot, slider, text input
+  FrameBgHovered,
+  FrameBgActive,
+  TitleBg,
+  TitleBgActive,
+  TitleBgCollapsed,
+  MenuBarBg,
+  ScrollbarBg,
+  ScrollbarGrab,
+  ScrollbarGrabHovered,
+  ScrollbarGrabActive,
+  CheckMark,
+  SliderGrab,
+  SliderGrabActive,
+  Button,
+  ButtonHovered,
+  ButtonActive,
+  Header,
+  HeaderHovered,
+  HeaderActive,
+  Separator,
+  SeparatorHovered,
+  SeparatorActive,
+  ResizeGrip,
+  ResizeGripHovered,
+  ResizeGripActive,
+  Tab,
+  TabHovered,
+  TabActive,
+  TabUnfocused,
+  TabUnfocusedActive,
+  PlotLines,
+  PlotLinesHovered,
+  PlotHistogram,
+  PlotHistogramHovered,
+  TableHeaderBg,         // Table header background
+  TableBorderStrong,     // Table outer and header borders (prefer using Alpha=1.0 here)
+  TableBorderLight,      // Table inner borders (prefer using Alpha=1.0 here)
+  TableRowBg,            // Table row background (even rows)
+  TableRowBgAlt,         // Table row background (odd rows)
+  TextSelectedBg,
+  DragDropTarget,
+  NavHighlight,          // Gamepad/keyboard: current highlighted item
+  NavWindowingHighlight, // Highlight window when using CTRL+TAB
+  NavWindowingDimBg,     // Darken/colorize entire screen behind the CTRL+TAB window list, when active
+  ModalWindowDimBg,      // Darken/colorize entire screen behind a modal window, when one is active
+  COUNT,
 }
 
 // Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.
@@ -661,401 +661,385 @@ export enum ImGuiCol {
 // NB: if changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.
 export { ImGuiStyleVar as StyleVar };
 export enum ImGuiStyleVar {
-    // Enum name --------------------- // Member in ImGuiStyle structure (see ImGuiStyle for descriptions)
-    Alpha,               // float     Alpha
-    WindowPadding,       // ImVec2    WindowPadding
-    WindowRounding,      // float     WindowRounding
-    WindowBorderSize,    // float     WindowBorderSize
-    WindowMinSize,       // ImVec2    WindowMinSize
-    WindowTitleAlign,    // ImVec2    WindowTitleAlign
-    ChildRounding,       // float     ChildRounding
-    ChildBorderSize,     // float     ChildBorderSize
-    PopupRounding,       // float     PopupRounding
-    PopupBorderSize,     // float     PopupBorderSize
-    FramePadding,        // ImVec2    FramePadding
-    FrameRounding,       // float     FrameRounding
-    FrameBorderSize,     // float     FrameBorderSize
-    ItemSpacing,         // ImVec2    ItemSpacing
-    ItemInnerSpacing,    // ImVec2    ItemInnerSpacing
-    IndentSpacing,       // float     IndentSpacing
-    CellPadding,         // ImVec2    CellPadding
-    ScrollbarSize,       // float     ScrollbarSize
-    ScrollbarRounding,   // float     ScrollbarRounding
-    GrabMinSize,         // float     GrabMinSize
-    GrabRounding,        // float     GrabRounding
-    TabRounding,         // float     TabRounding
-    ButtonTextAlign,     // ImVec2    ButtonTextAlign
-    SelectableTextAlign, // ImVec2    SelectableTextAlign
-    COUNT
+  // Enum name --------------------- // Member in ImGuiStyle structure (see ImGuiStyle for descriptions)
+  Alpha,               // float     Alpha
+  WindowPadding,       // ImVec2    WindowPadding
+  WindowRounding,      // float     WindowRounding
+  WindowBorderSize,    // float     WindowBorderSize
+  WindowMinSize,       // ImVec2    WindowMinSize
+  WindowTitleAlign,    // ImVec2    WindowTitleAlign
+  ChildRounding,       // float     ChildRounding
+  ChildBorderSize,     // float     ChildBorderSize
+  PopupRounding,       // float     PopupRounding
+  PopupBorderSize,     // float     PopupBorderSize
+  FramePadding,        // ImVec2    FramePadding
+  FrameRounding,       // float     FrameRounding
+  FrameBorderSize,     // float     FrameBorderSize
+  ItemSpacing,         // ImVec2    ItemSpacing
+  ItemInnerSpacing,    // ImVec2    ItemInnerSpacing
+  IndentSpacing,       // float     IndentSpacing
+  CellPadding,         // ImVec2    CellPadding
+  ScrollbarSize,       // float     ScrollbarSize
+  ScrollbarRounding,   // float     ScrollbarRounding
+  GrabMinSize,         // float     GrabMinSize
+  GrabRounding,        // float     GrabRounding
+  TabRounding,         // float     TabRounding
+  ButtonTextAlign,     // ImVec2    ButtonTextAlign
+  SelectableTextAlign, // ImVec2    SelectableTextAlign
+  COUNT
 }
 
 // Back-end capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom back-end.
 export { ImGuiBackendFlags as BackendFlags };
 export enum ImGuiBackendFlags {
-    None                  = 0,
-    HasGamepad            = 1 << 0,   // Back-end has a connected gamepad.
-    HasMouseCursors       = 1 << 1,   // Back-end can honor GetMouseCursor() values and change the OS cursor shape.
-    HasSetMousePos        = 1 << 2,   // Back-end can honor io.WantSetMousePos and reposition the mouse (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).
-    RendererHasVtxOffset  = 1 << 3,   // Back-end Renderer supports ImDrawCmd::VtxOffset. This enables output of large meshes (64K+ vertices) while still using 16-bits indices.
+  None = 0,
+  HasGamepad = 1 << 0,   // Back-end has a connected gamepad.
+  HasMouseCursors = 1 << 1,   // Back-end can honor GetMouseCursor() values and change the OS cursor shape.
+  HasSetMousePos = 1 << 2,   // Back-end can honor io.WantSetMousePos and reposition the mouse (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).
+  RendererHasVtxOffset = 1 << 3,   // Back-end Renderer supports ImDrawCmd::VtxOffset. This enables output of large meshes (64K+ vertices) while still using 16-bits indices.
 }
 
 // Flags for InvisibleButton() [extended in imgui_internal.h]
 export { ImGuiButtonFlags as ButtonFlags };
 export enum ImGuiButtonFlags {
-    None                   = 0,
-    MouseButtonLeft        = 1 << 0,   // React on left mouse button (default)
-    MouseButtonRight       = 1 << 1,   // React on right mouse button
-    MouseButtonMiddle      = 1 << 2,   // React on center mouse button
+  None = 0,
+  MouseButtonLeft = 1 << 0,   // React on left mouse button (default)
+  MouseButtonRight = 1 << 1,   // React on right mouse button
+  MouseButtonMiddle = 1 << 2,   // React on center mouse button
 
-    // [Internal]
-    MouseButtonMask_       = MouseButtonLeft | MouseButtonRight | MouseButtonMiddle,
-    MouseButtonDefault_    = MouseButtonLeft
+  // [Internal]
+  MouseButtonMask_ = MouseButtonLeft | MouseButtonRight | MouseButtonMiddle,
+  MouseButtonDefault_ = MouseButtonLeft
 }
 
 // Enumeration for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()
 export { ImGuiColorEditFlags as ColorEditFlags };
 export enum ImGuiColorEditFlags {
-    None            = 0,
-    NoAlpha         = 1 << 1,   //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (read 3 components from the input pointer).
-    NoPicker        = 1 << 2,   //              // ColorEdit: disable picker when clicking on colored square.
-    NoOptions       = 1 << 3,   //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.
-    NoSmallPreview  = 1 << 4,   //              // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)
-    NoInputs        = 1 << 5,   //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).
-    NoTooltip       = 1 << 6,   //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.
-    NoLabel         = 1 << 7,   //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).
-    NoSidePreview   = 1 << 8,   //              // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.
-    NoDragDrop      = 1 << 9,   //              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.
-    NoBorder        = 1 << 10,  //              // ColorButton: disable border (which is enforced by default)
-    // User Options (right-click on widget to change some of them). You can set application defaults using SetColorEditOptions(). The idea is that you probably don't want to override them in most of your calls, let the user choose and/or call SetColorEditOptions() during startup.
-    AlphaBar        = 1 << 16,   //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.
-    AlphaPreview    = 1 << 17,  //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.
-    AlphaPreviewHalf= 1 << 18,  //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.
-    HDR             = 1 << 19,  //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use Float flag as well).
-    DisplayRGB      = 1 << 20,  // [Inputs]     // ColorEdit: choose one among RGB/HSV/HEX. ColorPicker: choose any combination using RGB/HSV/HEX.
-    DisplayHSV      = 1 << 21,  // [Inputs]     // "
-    DisplayHex      = 1 << 22,  // [Inputs]     // "
-    Uint8           = 1 << 23,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.
-    Float           = 1 << 24,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.
-    PickerHueBar    = 1 << 25,  // [PickerMode] // ColorPicker: bar for Hue, rectangle for Sat/Value.
-    PickerHueWheel  = 1 << 26,  // [PickerMode] // ColorPicker: wheel for Hue, triangle for Sat/Value.
-    InputRGB        = 1 << 27,  // [Input]      // ColorEdit, ColorPicker: input and output data in RGB format.
-    InputHSV        = 1 << 28,  // [Input]      // ColorEdit, ColorPicker: input and output data in HSV format.
-
-    // Defaults Options. You can set application defaults using SetColorEditOptions(). The intent is that you probably don't want to
-    // override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.
-    _OptionsDefault = Uint8|DisplayRGB|InputRGB|PickerHueBar,
-
-    // [Internal] Masks
-    _DisplayMask    = DisplayRGB|DisplayHSV|DisplayHex,
-    _DataTypeMask   = Uint8|Float,
-    _PickerMask     = PickerHueWheel|PickerHueBar,
-    _InputMask      = InputRGB|InputHSV,
+  None = 0,
+  NoAlpha = 1 << 1,   //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (read 3 components from the input pointer).
+  NoPicker = 1 << 2,   //              // ColorEdit: disable picker when clicking on colored square.
+  NoOptions = 1 << 3,   //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.
+  NoSmallPreview = 1 << 4,   //              // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)
+  NoInputs = 1 << 5,   //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).
+  NoTooltip = 1 << 6,   //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.
+  NoLabel = 1 << 7,   //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).
+  NoSidePreview = 1 << 8,   //              // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.
+  NoDragDrop = 1 << 9,   //              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.
+  NoBorder = 1 << 10,  //              // ColorButton: disable border (which is enforced by default)
+  // User Options (right-click on widget to change some of them). You can set application defaults using SetColorEditOptions(). The idea is that you probably don't want to override them in most of your calls, let the user choose and/or call SetColorEditOptions() during startup.
+  AlphaBar = 1 << 16,   //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.
+  AlphaPreview = 1 << 17,  //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.
+  AlphaPreviewHalf = 1 << 18,  //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.
+  HDR = 1 << 19,  //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use Float flag as well).
+  DisplayRGB = 1 << 20,  // [Inputs]     // ColorEdit: choose one among RGB/HSV/HEX. ColorPicker: choose any combination using RGB/HSV/HEX.
+  DisplayHSV = 1 << 21,  // [Inputs]     // "
+  DisplayHex = 1 << 22,  // [Inputs]     // "
+  Uint8 = 1 << 23,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.
+  Float = 1 << 24,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.
+  PickerHueBar = 1 << 25,  // [PickerMode] // ColorPicker: bar for Hue, rectangle for Sat/Value.
+  PickerHueWheel = 1 << 26,  // [PickerMode] // ColorPicker: wheel for Hue, triangle for Sat/Value.
+  InputRGB = 1 << 27,  // [Input]      // ColorEdit, ColorPicker: input and output data in RGB format.
+  InputHSV = 1 << 28,  // [Input]      // ColorEdit, ColorPicker: input and output data in HSV format.
+
+  // Defaults Options. You can set application defaults using SetColorEditOptions(). The intent is that you probably don't want to
+  // override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.
+  _OptionsDefault = Uint8 | DisplayRGB | InputRGB | PickerHueBar,
+
+  // [Internal] Masks
+  _DisplayMask = DisplayRGB | DisplayHSV | DisplayHex,
+  _DataTypeMask = Uint8 | Float,
+  _PickerMask = PickerHueWheel | PickerHueBar,
+  _InputMask = InputRGB | InputHSV,
 }
 
 // Flags for DragFloat(), DragInt(), SliderFloat(), SliderInt() etc.
 // We use the same sets of flags for DragXXX() and SliderXXX() functions as the features are the same and it makes it easier to swap them.
 export { ImGuiSliderFlags as SliderFlags };
 export enum ImGuiSliderFlags {
-    None                   = 0,
-    AlwaysClamp            = 1 << 4,       // Clamp value to min/max bounds when input manually with CTRL+Click. By default CTRL+Click allows going out of bounds.
-    Logarithmic            = 1 << 5,       // Make the widget logarithmic (linear otherwise). Consider using ImGuiSliderFlags_NoRoundToFormat with this if using a format-string with small amount of digits.
-    NoRoundToFormat        = 1 << 6,       // Disable rounding underlying value to match precision of the display format string (e.g. %.3f values are rounded to those 3 digits)
-    NoInput                = 1 << 7,       // Disable CTRL+Click or Enter key allowing to input text directly into the widget
-    InvalidMask_           = 0x7000000F    // [Internal] We treat using those bits as being potentially a 'float power' argument from the previous API that has got miscast to this enum, and will trigger an assert if needed.
+  None = 0,
+  AlwaysClamp = 1 << 4,       // Clamp value to min/max bounds when input manually with CTRL+Click. By default CTRL+Click allows going out of bounds.
+  Logarithmic = 1 << 5,       // Make the widget logarithmic (linear otherwise). Consider using ImGuiSliderFlags_NoRoundToFormat with this if using a format-string with small amount of digits.
+  NoRoundToFormat = 1 << 6,       // Disable rounding underlying value to match precision of the display format string (e.g. %.3f values are rounded to those 3 digits)
+  NoInput = 1 << 7,       // Disable CTRL+Click or Enter key allowing to input text directly into the widget
+  InvalidMask_ = 0x7000000F    // [Internal] We treat using those bits as being potentially a 'float power' argument from the previous API that has got miscast to this enum, and will trigger an assert if needed.
 }
 
 // Identify a mouse button.
 // Those values are guaranteed to be stable and we frequently use 0/1 directly. Named enums provided for convenience.
 export { ImGuiMouseButton as MouseButton };
 export enum ImGuiMouseButton {
-    Left = 0,
-    Right = 1,
-    Middle = 2,
-    COUNT = 5
+  Left = 0,
+  Right = 1,
+  Middle = 2,
+  COUNT = 5
 }
 
 // Enumeration for GetMouseCursor()
 export { ImGuiMouseCursor as MouseCursor };
 export enum ImGuiMouseCursor {
-    None = -1,
-    Arrow = 0,
-    TextInput,         // When hovering over InputText, etc.
-    ResizeAll,         // (Unused by imgui functions)
-    ResizeNS,          // When hovering over an horizontal border
-    ResizeEW,          // When hovering over a vertical border or a column
-    ResizeNESW,        // When hovering over the bottom-left corner of a window
-    ResizeNWSE,        // When hovering over the bottom-right corner of a window
-    Hand,              // (Unused by imgui functions. Use for e.g. hyperlinks)
-    NotAllowed,        // When hovering something with disallowed interaction. Usually a crossed circle.
-    COUNT,
+  None = -1,
+  Arrow = 0,
+  TextInput,         // When hovering over InputText, etc.
+  ResizeAll,         // (Unused by imgui functions)
+  ResizeNS,          // When hovering over an horizontal border
+  ResizeEW,          // When hovering over a vertical border or a column
+  ResizeNESW,        // When hovering over the bottom-left corner of a window
+  ResizeNWSE,        // When hovering over the bottom-right corner of a window
+  Hand,              // (Unused by imgui functions. Use for e.g. hyperlinks)
+  NotAllowed,        // When hovering something with disallowed interaction. Usually a crossed circle.
+  COUNT,
 }
 
 // Condition for ImGui::SetWindow***(), SetNextWindow***(), SetNextTreeNode***() functions
 // All those functions treat 0 as a shortcut to Always. From the point of view of the user use this as an enum (don't combine multiple values into flags).
 export { ImGuiCond as Cond };
 export enum ImGuiCond {
-    None          = 0,        // No condition (always set the variable), same as _Always
-    Always        = 1 << 0,   // Set the variable
-    Once          = 1 << 1,   // Set the variable once per runtime session (only the first call with succeed)
-    FirstUseEver  = 1 << 2,   // Set the variable if the window has no saved data (if doesn't exist in the .ini file)
-    Appearing     = 1 << 3,    // Set the variable if the window is appearing after being hidden/inactive (or the first time)
+  None = 0,        // No condition (always set the variable), same as _Always
+  Always = 1 << 0,   // Set the variable
+  Once = 1 << 1,   // Set the variable once per runtime session (only the first call with succeed)
+  FirstUseEver = 1 << 2,   // Set the variable if the window has no saved data (if doesn't exist in the .ini file)
+  Appearing = 1 << 3,    // Set the variable if the window is appearing after being hidden/inactive (or the first time)
 }
 
 export { ImDrawCornerFlags as DrawCornerFlags };
-export enum ImDrawCornerFlags
-{
-    None      = 0,
-    TopLeft   = 1 << 0, // 0x1
-    TopRight  = 1 << 1, // 0x2
-    BotLeft   = 1 << 2, // 0x4
-    BotRight  = 1 << 3, // 0x8
-    Top       = TopLeft | TopRight,   // 0x3
-    Bot       = BotLeft | BotRight,   // 0xC
-    Left      = TopLeft | BotLeft,    // 0x5
-    Right     = TopRight | BotRight,  // 0xA
-    All       = 0xF,     // In your function calls you may use ~0 (= all bits sets) instead of All, as a convenience
+export enum ImDrawCornerFlags {
+  None = 0,
+  TopLeft = 1 << 0, // 0x1
+  TopRight = 1 << 1, // 0x2
+  BotLeft = 1 << 2, // 0x4
+  BotRight = 1 << 3, // 0x8
+  Top = TopLeft | TopRight,   // 0x3
+  Bot = BotLeft | BotRight,   // 0xC
+  Left = TopLeft | BotLeft,    // 0x5
+  Right = TopRight | BotRight,  // 0xA
+  All = 0xF,     // In your function calls you may use ~0 (= all bits sets) instead of All, as a convenience
 }
 
 export { ImDrawListFlags as wListFlags };
-export enum ImDrawListFlags
-{
-    None             = 0,
-    AntiAliasedLines = 1 << 0,
-    AntiAliasedLinesUseTex  = 1 << 1,  // Enable anti-aliased lines/borders using textures when possible. Require backend to render with bilinear filtering.
-    AntiAliasedFill         = 1 << 2,  // Enable anti-aliased edge around filled shapes (rounded rectangles, circles).
-    AllowVtxOffset          = 1 << 3   // Can emit 'VtxOffset > 0' to allow large meshes. Set when 'ImGuiBackendFlags_RendererHasVtxOffset' is enabled.
+export enum ImDrawListFlags {
+  None = 0,
+  AntiAliasedLines = 1 << 0,
+  AntiAliasedLinesUseTex = 1 << 1,  // Enable anti-aliased lines/borders using textures when possible. Require backend to render with bilinear filtering.
+  AntiAliasedFill = 1 << 2,  // Enable anti-aliased edge around filled shapes (rounded rectangles, circles).
+  AllowVtxOffset = 1 << 3   // Can emit 'VtxOffset > 0' to allow large meshes. Set when 'ImGuiBackendFlags_RendererHasVtxOffset' is enabled.
 }
 
-export { ImU32 as U32 }
+export { ImU32 as U32 };
 export type ImU32 = Bind.ImU32;
 
-export { interface_ImVec2 } from "./bind-imgui";
-export { reference_ImVec2 } from "./bind-imgui";
+export { interface_ImVec2, reference_ImVec2 } from "./bind-imgui";
 
-export { ImVec2 as Vec2 }
+export { ImVec2 as Vec2 };
 export class ImVec2 implements Bind.interface_ImVec2 {
-    public static readonly ZERO: Readonly<ImVec2> = new ImVec2(0.0, 0.0);
-    public static readonly UNIT: Readonly<ImVec2> = new ImVec2(1.0, 1.0);
-    public static readonly UNIT_X: Readonly<ImVec2> = new ImVec2(1.0, 0.0);
-    public static readonly UNIT_Y: Readonly<ImVec2> = new ImVec2(0.0, 1.0);
+  public static readonly ZERO: Readonly<ImVec2> = new ImVec2(0.0, 0.0);
+  public static readonly UNIT: Readonly<ImVec2> = new ImVec2(1.0, 1.0);
+  public static readonly UNIT_X: Readonly<ImVec2> = new ImVec2(1.0, 0.0);
+  public static readonly UNIT_Y: Readonly<ImVec2> = new ImVec2(0.0, 1.0);
 
-    constructor(public x: number = 0.0, public y: number = 0.0) {}
+  constructor(public x: number = 0.0, public y: number = 0.0) {}
 
-    public Set(x: number, y: number): this {
-        this.x = x;
-        this.y = y;
-        return this;
-    }
+  public Set(x: number, y: number): this {
+    this.x = x;
+    this.y = y;
+    return this;
+  }
 
-    public Copy(other: Readonly<Bind.interface_ImVec2>): this {
-        this.x = other.x;
-        this.y = other.y;
-        return this;
-    }
+  public Copy(other: Readonly<Bind.interface_ImVec2>): this {
+    this.x = other.x;
+    this.y = other.y;
+    return this;
+  }
 
-    public Equals(other: Readonly<Bind.interface_ImVec2>): boolean {
-        if (this.x !== other.x) { return false; }
-        if (this.y !== other.y) { return false; }
-        return true;
-    }
+  public Equals(other: Readonly<Bind.interface_ImVec2>): boolean {
+    if (this.x !== other.x) { return false; }
+    if (this.y !== other.y) { return false; }
+    return true;
+  }
 }
 
-export { interface_ImVec4 } from "./bind-imgui";
-export { reference_ImVec4 } from "./bind-imgui";
+export { interface_ImVec4, reference_ImVec4 } from "./bind-imgui";
 
-export { ImVec4 as Vec4 }
+export { ImVec4 as Vec4 };
 export class ImVec4 implements Bind.interface_ImVec4 {
-    public static readonly ZERO: Readonly<ImVec4> = new ImVec4(0.0, 0.0, 0.0, 0.0);
-    public static readonly UNIT: Readonly<ImVec4> = new ImVec4(1.0, 1.0, 1.0, 1.0);
-    public static readonly UNIT_X: Readonly<ImVec4> = new ImVec4(1.0, 0.0, 0.0, 0.0);
-    public static readonly UNIT_Y: Readonly<ImVec4> = new ImVec4(0.0, 1.0, 0.0, 0.0);
-    public static readonly UNIT_Z: Readonly<ImVec4> = new ImVec4(0.0, 0.0, 1.0, 0.0);
-    public static readonly UNIT_W: Readonly<ImVec4> = new ImVec4(0.0, 0.0, 0.0, 1.0);
-    public static readonly BLACK: Readonly<ImVec4> = new ImVec4(0.0, 0.0, 0.0, 1.0);
-    public static readonly WHITE: Readonly<ImVec4> = new ImVec4(1.0, 1.0, 1.0, 1.0);
-
-    constructor(public x: number = 0.0, public y: number = 0.0, public z: number = 0.0, public w: number = 1.0) {}
-
-    public Set(x: number, y: number, z: number, w: number): this {
-        this.x = x;
-        this.y = y;
-        this.z = z;
-        this.w = w;
-        return this;
-    }
-
-    public Copy(other: Readonly<Bind.interface_ImVec4>): this {
-        this.x = other.x;
-        this.y = other.y;
-        this.z = other.z;
-        this.w = other.w;
-        return this;
-    }
-
-    public Equals(other: Readonly<Bind.interface_ImVec4>): boolean {
-        if (this.x !== other.x) { return false; }
-        if (this.y !== other.y) { return false; }
-        if (this.z !== other.z) { return false; }
-        if (this.w !== other.w) { return false; }
-        return true;
-    }
-}
-
-export {interface_ImMat2} from "./bind-imgui"
-export {reference_ImMat2} from "./bind-imgui"
+  public static readonly ZERO: Readonly<ImVec4> = new ImVec4(0.0, 0.0, 0.0, 0.0);
+  public static readonly UNIT: Readonly<ImVec4> = new ImVec4(1.0, 1.0, 1.0, 1.0);
+  public static readonly UNIT_X: Readonly<ImVec4> = new ImVec4(1.0, 0.0, 0.0, 0.0);
+  public static readonly UNIT_Y: Readonly<ImVec4> = new ImVec4(0.0, 1.0, 0.0, 0.0);
+  public static readonly UNIT_Z: Readonly<ImVec4> = new ImVec4(0.0, 0.0, 1.0, 0.0);
+  public static readonly UNIT_W: Readonly<ImVec4> = new ImVec4(0.0, 0.0, 0.0, 1.0);
+  public static readonly BLACK: Readonly<ImVec4> = new ImVec4(0.0, 0.0, 0.0, 1.0);
+  public static readonly WHITE: Readonly<ImVec4> = new ImVec4(1.0, 1.0, 1.0, 1.0);
+
+  constructor(public x: number = 0.0, public y: number = 0.0, public z: number = 0.0, public w: number = 1.0) {}
+
+  public Set(x: number, y: number, z: number, w: number): this {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+    this.w = w;
+    return this;
+  }
+
+  public Copy(other: Readonly<Bind.interface_ImVec4>): this {
+    this.x = other.x;
+    this.y = other.y;
+    this.z = other.z;
+    this.w = other.w;
+    return this;
+  }
+
+  public Equals(other: Readonly<Bind.interface_ImVec4>): boolean {
+    if (this.x !== other.x) { return false; }
+    if (this.y !== other.y) { return false; }
+    if (this.z !== other.z) { return false; }
+    if (this.w !== other.w) { return false; }
+    return true;
+  }
+}
+
+export { interface_ImMat2, reference_ImMat2 } from "./bind-imgui";
 
 export class ImMat2 implements Bind.interface_ImMat2 {
-    public static readonly IDENTITY: Readonly<ImMat2> = new ImMat2(1.0, 0.0, 0.0, 1.0);
-
-    constructor(public m11: number = 1.0, public m12: number =0.0, public m21: number =0.0, public m22: number =1.0) {}
-
-    //constructor(public readonly native: Bind.reference_ImMat2) {}
-
-    Set(m11:number, m12:number, m21:number, m22:number): this
-    {
-        this.m11 = m11;
-        this.m12 = m12;
-        this.m21 = m21;
-        this.m22 = m22;
-        return this;
-    }
-    Copy(other: Readonly<Bind.interface_ImMat2>): this {
-        this.m11 = other.m11;
-        this.m12 = other.m12;
-        this.m21 = other.m21;
-        this.m22 = other.m22;
-        return this;
-    }
-    Equals(other: Readonly<Bind.interface_ImMat2>): boolean {
-        if(this.m11!== other.m11) { return false; }
-        if(this.m12!== other.m12) { return false; }
-        if(this.m21!== other.m21) { return false; }
-        if(this.m22!== other.m22) { return false; }
-        return true;
-    }
-    Identity(): void {
-        this.m11=1;
-        this.m12=0;
-        this.m21=0;
-        this.m22=1;
-    }
-    Transpose():ImMat2
-    {
-        return new ImMat2(this.m11, this.m21, this.m12, this.m22);
-    }
-
-    SetRotate(radius: number): this {
-        const c=Math.cos(radius), s=Math.sin(radius);
-        this.m11 = c;
-        this.m12 = -s;
-        this.m21 = s;
-        this.m22 = c;
-        return this;
-    }
-    Multiply(other: Readonly<Bind.interface_ImMat2>): Bind.interface_ImMat2
-    {
-        const m11 = this.m11 * other.m11 + this.m12 * other.m21;
-        const m12 = this.m11 * other.m12 + this.m12 * other.m22;
-        const m21 = this.m21 * other.m11 + this.m22 * other.m21;
-        const m22 = this.m21 * other.m12 + this.m22 * other.m22;
-        return new ImMat2(m11, m12, m21, m22);
-    }
-    Transform(p: Readonly<Bind.interface_ImVec2>): Bind.interface_ImVec2
-    {
-        return new ImVec2(
-            this.m11 * p.x + this.m12 * p.y,
-            this.m21 * p.x + this.m22 * p.y
-            );
-    }    
-
-    TransposeTo(target:ImMat2):void
-    {
-        target.m11 = this.m11;
-        target.m12 = this.m21;
-        target.m21 = this.m12;
-        target.m22 = this.m22;
-    }
-
-    MultiplyTo(other: Readonly<Bind.interface_ImMat2>, target:ImMat2): void
-    {
-        target.m11 = this.m11 * other.m11 + this.m12 * other.m21;
-        target.m12 = this.m11 * other.m12 + this.m12 * other.m22;
-        target.m21 = this.m21 * other.m11 + this.m22 * other.m21;
-        target.m22 = this.m21 * other.m12 + this.m22 * other.m22;
-    }
-    TransformTo(p: Readonly<Bind.interface_ImVec2>, target: ImVec2): void
-    {
-        let px=p.x;
-        let py=p.y;
-        target.x=this.m11 * px + this.m12 * py;
-        target.y=this.m21 * px + this.m22 * py;
-    }
-}
-
-
-export {ImTransform as Transform} 
-
-export class ImTransform implements Bind.interface_ImTransform 
-{
-    constructor(
-        public rotate:Bind.interface_ImMat2=new ImMat2,
-        public translate:Bind.interface_ImVec2=new ImVec2(0,0),
-        public scale:number=1) {}
-
-    Identity(): void {
-        this.rotate.Identity();
-        this.translate.Set(0,0);
-        this.scale=1;
-    }
-    Multiply(m: Readonly<Bind.interface_ImTransform>): Bind.interface_ImTransform {
-        let tm=new ImTransform;
-        tm.scale = this.scale * m.scale;
-        tm.rotate = this.rotate.Multiply(m.rotate);
-        let t=this.rotate.Transform(m.translate);
-        tm.translate.x = this.translate.x + t.x * this.scale;
-        tm.translate.y = this.translate.y + t.y * this.scale;
-        return tm;
-    }
-    Transform(point: Readonly<Bind.interface_ImVec2>): Bind.interface_ImVec2 {
-        let p=this.rotate.Transform(point);
-        p.x=p.x*this.scale+this.translate.x;
-        p.y=p.y*this.scale+this.translate.y;
-        return p;
-    }
-    Invert():Bind.interface_ImTransform
-    {
-        let tm:ImTransform=new ImTransform;
-        tm.rotate=this.rotate.Transpose();
-        tm.scale = 1.0 / this.scale;
-        let t=new ImVec2(-this.translate.x, -this.translate.y);
-        t=tm.rotate.Transform(t);
-		tm.translate.x = t.x*tm.scale;
-        tm.translate.y = t.y*tm.scale;
-        return tm;
-    }
-
-    MultiplyTo(other: ImTransform, target:ImTransform): void
-    {
-        target.scale = this.scale * other.scale;
-        this.rotate.MultiplyTo(other.rotate, target.rotate);
-        this.rotate.TransformTo(other.translate, target.translate);
-        target.translate.x = this.translate.x + target.translate.x * this.scale;
-        target.translate.y = this.translate.y + target.translate.y * this.scale;
-    }
-    TransformTo(point: Readonly<Bind.interface_ImVec2>, target: Bind.interface_ImVec2): void
-    {
-        this.rotate.TransformTo(point, target);
-        target.x=target.x*this.scale+this.translate.x;
-        target.y=target.y*this.scale+this.translate.y;
-    }
-    InvertTo(target: Bind.interface_ImTransform): void {
-        this.rotate.TransposeTo(target.rotate);
-        target.scale = 1.0 / this.scale;
-        target.translate.Set(-this.translate.x, -this.translate.y);
-        this.rotate.TransformTo(target.translate, target.translate);
-        target.translate.x = target.translate.x * this.scale;
-        target.translate.y = target.translate.y * this.scale;
-    }
+  public static readonly IDENTITY: Readonly<ImMat2> = new ImMat2(1.0, 0.0, 0.0, 1.0);
+
+  constructor(public m11: number = 1.0, public m12: number = 0.0, public m21: number = 0.0, public m22: number = 1.0) {}
+
+  //constructor(public readonly native: Bind.reference_ImMat2) {}
+
+  Set(m11: number, m12: number, m21: number, m22: number): this {
+    this.m11 = m11;
+    this.m12 = m12;
+    this.m21 = m21;
+    this.m22 = m22;
+    return this;
+  }
+  Copy(other: Readonly<Bind.interface_ImMat2>): this {
+    this.m11 = other.m11;
+    this.m12 = other.m12;
+    this.m21 = other.m21;
+    this.m22 = other.m22;
+    return this;
+  }
+  Equals(other: Readonly<Bind.interface_ImMat2>): boolean {
+    if (this.m11 !== other.m11) { return false; }
+    if (this.m12 !== other.m12) { return false; }
+    if (this.m21 !== other.m21) { return false; }
+    if (this.m22 !== other.m22) { return false; }
+    return true;
+  }
+  Identity(): void {
+    this.m11 = 1;
+    this.m12 = 0;
+    this.m21 = 0;
+    this.m22 = 1;
+  }
+  Transpose(): ImMat2 {
+    return new ImMat2(this.m11, this.m21, this.m12, this.m22);
+  }
+
+  SetRotate(radius: number): this {
+    const c = Math.cos(radius), s = Math.sin(radius);
+    this.m11 = c;
+    this.m12 = -s;
+    this.m21 = s;
+    this.m22 = c;
+    return this;
+  }
+  Multiply(other: Readonly<Bind.interface_ImMat2>): Bind.interface_ImMat2 {
+    const m11 = this.m11 * other.m11 + this.m12 * other.m21;
+    const m12 = this.m11 * other.m12 + this.m12 * other.m22;
+    const m21 = this.m21 * other.m11 + this.m22 * other.m21;
+    const m22 = this.m21 * other.m12 + this.m22 * other.m22;
+    return new ImMat2(m11, m12, m21, m22);
+  }
+  Transform(p: Readonly<Bind.interface_ImVec2>): Bind.interface_ImVec2 {
+    return new ImVec2(
+      this.m11 * p.x + this.m12 * p.y,
+      this.m21 * p.x + this.m22 * p.y
+    );
+  }
+
+  TransposeTo(target: ImMat2): void {
+    target.m11 = this.m11;
+    target.m12 = this.m21;
+    target.m21 = this.m12;
+    target.m22 = this.m22;
+  }
+
+  MultiplyTo(other: Readonly<Bind.interface_ImMat2>, target: ImMat2): void {
+    target.m11 = this.m11 * other.m11 + this.m12 * other.m21;
+    target.m12 = this.m11 * other.m12 + this.m12 * other.m22;
+    target.m21 = this.m21 * other.m11 + this.m22 * other.m21;
+    target.m22 = this.m21 * other.m12 + this.m22 * other.m22;
+  }
+  TransformTo(p: Readonly<Bind.interface_ImVec2>, target: ImVec2): void {
+    let px = p.x;
+    let py = p.y;
+    target.x = this.m11 * px + this.m12 * py;
+    target.y = this.m21 * px + this.m22 * py;
+  }
+}
+
+
+export { ImTransform as Transform };
+
+export class ImTransform implements Bind.interface_ImTransform {
+  constructor(
+    public rotate: Bind.interface_ImMat2 = new ImMat2,
+    public translate: Bind.interface_ImVec2 = new ImVec2(0, 0),
+    public scale: number = 1) {}
+
+  Identity(): void {
+    this.rotate.Identity();
+    this.translate.Set(0, 0);
+    this.scale = 1;
+  }
+  Multiply(m: Readonly<Bind.interface_ImTransform>): Bind.interface_ImTransform {
+    let tm = new ImTransform;
+    tm.scale = this.scale * m.scale;
+    tm.rotate = this.rotate.Multiply(m.rotate);
+    let t = this.rotate.Transform(m.translate);
+    tm.translate.x = this.translate.x + t.x * this.scale;
+    tm.translate.y = this.translate.y + t.y * this.scale;
+    return tm;
+  }
+  Transform(point: Readonly<Bind.interface_ImVec2>): Bind.interface_ImVec2 {
+    let p = this.rotate.Transform(point);
+    p.x = p.x * this.scale + this.translate.x;
+    p.y = p.y * this.scale + this.translate.y;
+    return p;
+  }
+  Invert(): Bind.interface_ImTransform {
+    let tm: ImTransform = new ImTransform;
+    tm.rotate = this.rotate.Transpose();
+    tm.scale = 1.0 / this.scale;
+    let t = new ImVec2(-this.translate.x, -this.translate.y);
+    t = tm.rotate.Transform(t);
+    tm.translate.x = t.x * tm.scale;
+    tm.translate.y = t.y * tm.scale;
+    return tm;
+  }
+
+  MultiplyTo(other: ImTransform, target: ImTransform): void {
+    target.scale = this.scale * other.scale;
+    this.rotate.MultiplyTo(other.rotate, target.rotate);
+    this.rotate.TransformTo(other.translate, target.translate);
+    target.translate.x = this.translate.x + target.translate.x * this.scale;
+    target.translate.y = this.translate.y + target.translate.y * this.scale;
+  }
+  TransformTo(point: Readonly<Bind.interface_ImVec2>, target: Bind.interface_ImVec2): void {
+    this.rotate.TransformTo(point, target);
+    target.x = target.x * this.scale + this.translate.x;
+    target.y = target.y * this.scale + this.translate.y;
+  }
+  InvertTo(target: Bind.interface_ImTransform): void {
+    this.rotate.TransposeTo(target.rotate);
+    target.scale = 1.0 / this.scale;
+    target.translate.Set(-this.translate.x, -this.translate.y);
+    this.rotate.TransformTo(target.translate, target.translate);
+    target.translate.x = target.translate.x * this.scale;
+    target.translate.y = target.translate.y * this.scale;
+  }
 }
 
 //-----------------------------------------------------------------------------
@@ -1064,92 +1048,91 @@ export class ImTransform implements Bind.interface_ImTransform
 
 // Lightweight std::vector<> like class to avoid dragging dependencies (also: windows implementation of STL with debug enabled is absurdly slow, so let's bypass it so our code runs fast in debug).
 // Our implementation does NOT call C++ constructors/destructors. This is intentional and we do not require it. Do not use this class as a straight std::vector replacement in your code!
-export { ImVector as Vector }
-export class ImVector<T> extends Array<T>
-{
-    public get Size(): number { return this.length; }
-    public Data: T[] = this;
-    public empty(): boolean { return this.length === 0; }
-    public clear(): void { this.length = 0; }
-    public pop_back(): T | undefined { return this.pop(); }
-    public push_back(value: T): void { this.push(value); }
-    public front(): T { IM_ASSERT(this.Size > 0);  return this.Data[0]; }
-    public back(): T { IM_ASSERT(this.Size > 0);  return this.Data[this.Size - 1]; }
-    public size(): number { return this.Size; }
-    public resize(new_size: number, v?: (index: number) => T): void {
-        if (v) {
-            for (let index = this.length; index < new_size; ++index) {
-                this[index] = v(index);
-            }
-        }
-        else {
-            this.length = new_size;
-        }
-    }
-    public contains(value: T): boolean {
-        return this.includes(value);
-    }
-    public find_erase_unsorted(value: T): void {
-        const index = this.indexOf(value);
-        if (index !== -1) {
-            this.splice(index, 1);
-        }
-    }
-    // public:
-    // int                         Size;
-    // int                         Capacity;
-    // T*                          Data;
-
-    // typedef T                   value_type;
-    // typedef value_type*         iterator;
-    // typedef const value_type*   const_iterator;
-
-    // inline ImVector()           { Size = Capacity = 0; Data = NULL; }
-    // inline ~ImVector()          { if (Data) ImGui::MemFree(Data); }
-
-    // inline bool                 empty() const                   { return Size == 0; }
-    // inline int                  size() const                    { return Size; }
-    // inline int                  capacity() const                { return Capacity; }
-
-    // inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }
-    // inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }
-
-    // inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }
-    // inline iterator             begin()                         { return Data; }
-    // inline const_iterator       begin() const                   { return Data; }
-    // inline iterator             end()                           { return Data + Size; }
-    // inline const_iterator       end() const                     { return Data + Size; }
-    // inline value_type&          front()                         { IM_ASSERT(Size > 0); return Data[0]; }
-    // inline const value_type&    front() const                   { IM_ASSERT(Size > 0); return Data[0]; }
-    // inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size - 1]; }
-    // inline const value_type&    back() const                    { IM_ASSERT(Size > 0); return Data[Size - 1]; }
-    // inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }
-
-    // inline int                  _grow_capacity(int size) const  { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > size ? new_capacity : size; }
-
-    // inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
-    // inline void                 resize(int new_size, const T& v){ if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) Data[n] = v; Size = new_size; }
-    // inline void                 reserve(int new_capacity)
-    // {
-    //     if (new_capacity <= Capacity)
-    //         return;
-    //     T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T));
-    //     if (Data)
-    //         memcpy(new_data, Data, (size_t)Size * sizeof(T));
-    //     ImGui::MemFree(Data);
-    //     Data = new_data;
-    //     Capacity = new_capacity;
-    // }
-
-    // inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); Data[Size++] = v; }
-    // inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }
-    // inline void                 push_front(const value_type& v) { if (Size == 0) push_back(v); else insert(Data, v); }
-
-    // inline iterator             erase(const_iterator it)                        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }
-    // inline iterator             erase(const_iterator it, const_iterator it_last){ IM_ASSERT(it >= Data && it < Data+Size && it_last > it && it_last <= Data+Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - count) * sizeof(value_type)); Size -= (int)count; return Data + off; }
-    // inline iterator             erase_unsorted(const_iterator it)               { IM_ASSERT(it >= Data && it < Data+Size);  const ptrdiff_t off = it - Data; if (it < Data+Size-1) memcpy(Data + off, Data + Size - 1, sizeof(value_type)); Size--; return Data + off; }
-    // inline iterator             insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); Data[off] = v; Size++; return Data + off; }
-    // inline bool                 contains(const value_type& v) const             { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
+export { ImVector as Vector };
+export class ImVector<T> extends Array<T> {
+  public get Size(): number { return this.length; }
+  public Data: T[] = this;
+  public empty(): boolean { return this.length === 0; }
+  public clear(): void { this.length = 0; }
+  public pop_back(): T | undefined { return this.pop(); }
+  public push_back(value: T): void { this.push(value); }
+  public front(): T { IM_ASSERT(this.Size > 0); return this.Data[0]; }
+  public back(): T { IM_ASSERT(this.Size > 0); return this.Data[this.Size - 1]; }
+  public size(): number { return this.Size; }
+  public resize(new_size: number, v?: (index: number) => T): void {
+    if (v) {
+      for (let index = this.length; index < new_size; ++index) {
+        this[index] = v(index);
+      }
+    }
+    else {
+      this.length = new_size;
+    }
+  }
+  public contains(value: T): boolean {
+    return this.includes(value);
+  }
+  public find_erase_unsorted(value: T): void {
+    const index = this.indexOf(value);
+    if (index !== -1) {
+      this.splice(index, 1);
+    }
+  }
+  // public:
+  // int                         Size;
+  // int                         Capacity;
+  // T*                          Data;
+
+  // typedef T                   value_type;
+  // typedef value_type*         iterator;
+  // typedef const value_type*   const_iterator;
+
+  // inline ImVector()           { Size = Capacity = 0; Data = NULL; }
+  // inline ~ImVector()          { if (Data) ImGui::MemFree(Data); }
+
+  // inline bool                 empty() const                   { return Size == 0; }
+  // inline int                  size() const                    { return Size; }
+  // inline int                  capacity() const                { return Capacity; }
+
+  // inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }
+  // inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }
+
+  // inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }
+  // inline iterator             begin()                         { return Data; }
+  // inline const_iterator       begin() const                   { return Data; }
+  // inline iterator             end()                           { return Data + Size; }
+  // inline const_iterator       end() const                     { return Data + Size; }
+  // inline value_type&          front()                         { IM_ASSERT(Size > 0); return Data[0]; }
+  // inline const value_type&    front() const                   { IM_ASSERT(Size > 0); return Data[0]; }
+  // inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size - 1]; }
+  // inline const value_type&    back() const                    { IM_ASSERT(Size > 0); return Data[Size - 1]; }
+  // inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }
+
+  // inline int                  _grow_capacity(int size) const  { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > size ? new_capacity : size; }
+
+  // inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
+  // inline void                 resize(int new_size, const T& v){ if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) Data[n] = v; Size = new_size; }
+  // inline void                 reserve(int new_capacity)
+  // {
+  //     if (new_capacity <= Capacity)
+  //         return;
+  //     T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T));
+  //     if (Data)
+  //         memcpy(new_data, Data, (size_t)Size * sizeof(T));
+  //     ImGui::MemFree(Data);
+  //     Data = new_data;
+  //     Capacity = new_capacity;
+  // }
+
+  // inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); Data[Size++] = v; }
+  // inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }
+  // inline void                 push_front(const value_type& v) { if (Size == 0) push_back(v); else insert(Data, v); }
+
+  // inline iterator             erase(const_iterator it)                        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }
+  // inline iterator             erase(const_iterator it, const_iterator it_last){ IM_ASSERT(it >= Data && it < Data+Size && it_last > it && it_last <= Data+Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - count) * sizeof(value_type)); Size -= (int)count; return Data + off; }
+  // inline iterator             erase_unsorted(const_iterator it)               { IM_ASSERT(it >= Data && it < Data+Size);  const ptrdiff_t off = it - Data; if (it < Data+Size-1) memcpy(Data + off, Data + Size - 1, sizeof(value_type)); Size--; return Data + off; }
+  // inline iterator             insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); Data[off] = v; Size++; return Data + off; }
+  // inline bool                 contains(const value_type& v) const             { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
 }
 
 // Helper: Unicode defines
@@ -1159,139 +1142,135 @@ export class ImVector<T> extends Array<T>
 // #else
 // #define IM_UNICODE_CODEPOINT_MAX     0xFFFF     // Maximum Unicode code point supported by this build.
 // #endif
-export { IM_UNICODE_CODEPOINT_MAX as UNICODE_CODEPOINT_MAX }
+export { IM_UNICODE_CODEPOINT_MAX as UNICODE_CODEPOINT_MAX };
 export const IM_UNICODE_CODEPOINT_MAX: number = 0xFFFF; // Maximum Unicode code point supported by this build.
 
 // Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
-export { ImGuiTextFilter as TextFilter }
-export class ImGuiTextFilter
-{
-    // IMGUI_API           ImGuiTextFilter(const char* default_filter = "");
-    constructor(default_filter: string = "") {
-        if (default_filter)
-        {
-            // ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));
-            this.InputBuf.buffer = default_filter;
-            this.Build();
-        }
-        else
-        {
-            // InputBuf[0] = 0;
-            this.InputBuf.buffer = "";
-            this.CountGrep = 0;
-        }
-    }
-    // IMGUI_API bool      Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);    // Helper calling InputText+Build
-    public Draw(label: string = "Filter (inc,-exc)", width: number = 0.0): boolean {
-        if (width !== 0.0)
-            bind.PushItemWidth(width);
-        const value_changed: boolean = InputText(label, this.InputBuf, IM_ARRAYSIZE(this.InputBuf));
-        if (width !== 0.0)
-            bind.PopItemWidth();
-        if (value_changed)
-            this.Build();
-        return value_changed;
-    }
-    // IMGUI_API bool      PassFilter(const char* text, const char* text_end = NULL) const;
-    public PassFilter(text: string, text_end: number | null = null): boolean {
-        // if (Filters.empty())
-        //     return true;
-
-        // if (text == NULL)
-        //     text = "";
-
-        // for (int i = 0; i != Filters.Size; i++)
-        // {
-        //     const TextRange& f = Filters[i];
-        //     if (f.empty())
-        //         continue;
-        //     if (f.front() == '-')
-        //     {
-        //         // Subtract
-        //         if (ImStristr(text, text_end, f.begin()+1, f.end()) != NULL)
-        //             return false;
-        //     }
-        //     else
-        //     {
-        //         // Grep
-        //         if (ImStristr(text, text_end, f.begin(), f.end()) != NULL)
-        //             return true;
-        //     }
-        // }
-
-        // Implicit * grep
-        if (this.CountGrep === 0)
-            return true;
-
-        return false;
-    }
-    // IMGUI_API void      Build();
-    public Build(): void {
-        // Filters.resize(0);
-        // TextRange input_range(InputBuf, InputBuf+strlen(InputBuf));
-        // input_range.split(',', Filters);
-
-        this.CountGrep = 0;
-        // for (int i = 0; i != Filters.Size; i++)
-        // {
-        //     Filters[i].trim_blanks();
-        //     if (Filters[i].empty())
-        //         continue;
-        //     if (Filters[i].front() != '-')
-        //         CountGrep += 1;
-        // }
-    }
-    // void                Clear() { InputBuf[0] = 0; Build(); }
-    public Clear(): void { this.InputBuf.buffer = ""; this.Build(); }
-    // bool                IsActive() const { return !Filters.empty(); }
-    public IsActive(): boolean { return false; }
+export { ImGuiTextFilter as TextFilter };
+export class ImGuiTextFilter {
+  // IMGUI_API           ImGuiTextFilter(const char* default_filter = "");
+  constructor(default_filter: string = "") {
+    if (default_filter) {
+      // ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));
+      this.InputBuf.buffer = default_filter;
+      this.Build();
+    }
+    else {
+      // InputBuf[0] = 0;
+      this.InputBuf.buffer = "";
+      this.CountGrep = 0;
+    }
+  }
+  // IMGUI_API bool      Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);    // Helper calling InputText+Build
+  public Draw(label: string = "Filter (inc,-exc)", width: number = 0.0): boolean {
+    if (width !== 0.0)
+      bind.PushItemWidth(width);
+    const value_changed: boolean = InputText(label, this.InputBuf, IM_ARRAYSIZE(this.InputBuf));
+    if (width !== 0.0)
+      bind.PopItemWidth();
+    if (value_changed)
+      this.Build();
+    return value_changed;
+  }
+  // IMGUI_API bool      PassFilter(const char* text, const char* text_end = NULL) const;
+  public PassFilter(text: string, text_end: number | null = null): boolean {
+    // if (Filters.empty())
+    //     return true;
+
+    // if (text == NULL)
+    //     text = "";
+
+    // for (int i = 0; i != Filters.Size; i++)
+    // {
+    //     const TextRange& f = Filters[i];
+    //     if (f.empty())
+    //         continue;
+    //     if (f.front() == '-')
+    //     {
+    //         // Subtract
+    //         if (ImStristr(text, text_end, f.begin()+1, f.end()) != NULL)
+    //             return false;
+    //     }
+    //     else
+    //     {
+    //         // Grep
+    //         if (ImStristr(text, text_end, f.begin(), f.end()) != NULL)
+    //             return true;
+    //     }
+    // }
+
+    // Implicit * grep
+    if (this.CountGrep === 0)
+      return true;
+
+    return false;
+  }
+  // IMGUI_API void      Build();
+  public Build(): void {
+    // Filters.resize(0);
+    // TextRange input_range(InputBuf, InputBuf+strlen(InputBuf));
+    // input_range.split(',', Filters);
 
-    // [Internal]
-    // struct TextRange
+    this.CountGrep = 0;
+    // for (int i = 0; i != Filters.Size; i++)
     // {
-    //     const char* b;
-    //     const char* e;
-
-    //     TextRange() { b = e = NULL; }
-    //     TextRange(const char* _b, const char* _e) { b = _b; e = _e; }
-    //     const char* begin() const { return b; }
-    //     const char* end() const { return e; }
-    //     bool empty() const { return b == e; }
-    //     char front() const { return *b; }
-    //     static bool is_blank(char c) { return c == ' ' || c == '\t'; }
-    //     void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }
-    //     IMGUI_API void split(char separator, ImVector<TextRange>& out);
-    // };
-
-    // char                InputBuf[256];
-    public InputBuf: ImStringBuffer = new ImStringBuffer(256);
-    // ImVector<TextRange> Filters;
-    // int                 CountGrep;
-    public CountGrep: number = 0;
+    //     Filters[i].trim_blanks();
+    //     if (Filters[i].empty())
+    //         continue;
+    //     if (Filters[i].front() != '-')
+    //         CountGrep += 1;
+    // }
+  }
+  // void                Clear() { InputBuf[0] = 0; Build(); }
+  public Clear(): void { this.InputBuf.buffer = ""; this.Build(); }
+  // bool                IsActive() const { return !Filters.empty(); }
+  public IsActive(): boolean { return false; }
+
+  // [Internal]
+  // struct TextRange
+  // {
+  //     const char* b;
+  //     const char* e;
+
+  //     TextRange() { b = e = NULL; }
+  //     TextRange(const char* _b, const char* _e) { b = _b; e = _e; }
+  //     const char* begin() const { return b; }
+  //     const char* end() const { return e; }
+  //     bool empty() const { return b == e; }
+  //     char front() const { return *b; }
+  //     static bool is_blank(char c) { return c == ' ' || c == '\t'; }
+  //     void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }
+  //     IMGUI_API void split(char separator, ImVector<TextRange>& out);
+  // };
+
+  // char                InputBuf[256];
+  public InputBuf: ImStringBuffer = new ImStringBuffer(256);
+  // ImVector<TextRange> Filters;
+  // int                 CountGrep;
+  public CountGrep: number = 0;
 }
 
 // Helper: Text buffer for logging/accumulating text
-export { ImGuiTextBuffer as TextBuffer }
-export class ImGuiTextBuffer
-{
-    // ImVector<char>      Buf;
-    public Buf: string = "";
-    public begin(): string { return this.Buf; }
-    public size(): number { return this.Buf.length; }
-    public clear(): void { this.Buf = ""; }
-    public append(text: string): void { this.Buf += text; }
-
-    // ImGuiTextBuffer()   { Buf.push_back(0); }
-    // inline char         operator[](int i) { return Buf.Data[i]; }
-    // const char*         begin() const { return &Buf.front(); }
-    // const char*         end() const { return &Buf.back(); }      // Buf is zero-terminated, so end() will point on the zero-terminator
-    // int                 size() const { return Buf.Size - 1; }
-    // bool                empty() { return Buf.Size <= 1; }
-    // void                clear() { Buf.clear(); Buf.push_back(0); }
-    // void                reserve(int capacity) { Buf.reserve(capacity); }
-    // const char*         c_str() const { return Buf.Data; }
-    // IMGUI_API void      appendf(const char* fmt, ...) IM_FMTARGS(2);
-    // IMGUI_API void      appendfv(const char* fmt, va_list args) IM_FMTLIST(2);
+export { ImGuiTextBuffer as TextBuffer };
+export class ImGuiTextBuffer {
+  // ImVector<char>      Buf;
+  public Buf: string = "";
+  public begin(): string { return this.Buf; }
+  public size(): number { return this.Buf.length; }
+  public clear(): void { this.Buf = ""; }
+  public append(text: string): void { this.Buf += text; }
+
+  // ImGuiTextBuffer()   { Buf.push_back(0); }
+  // inline char         operator[](int i) { return Buf.Data[i]; }
+  // const char*         begin() const { return &Buf.front(); }
+  // const char*         end() const { return &Buf.back(); }      // Buf is zero-terminated, so end() will point on the zero-terminator
+  // int                 size() const { return Buf.Size - 1; }
+  // bool                empty() { return Buf.Size <= 1; }
+  // void                clear() { Buf.clear(); Buf.push_back(0); }
+  // void                reserve(int capacity) { Buf.reserve(capacity); }
+  // const char*         c_str() const { return Buf.Data; }
+  // IMGUI_API void      appendf(const char* fmt, ...) IM_FMTARGS(2);
+  // IMGUI_API void      appendfv(const char* fmt, va_list args) IM_FMTLIST(2);
 }
 
 // Helper: Simple Key->value storage
@@ -1302,69 +1281,67 @@ export class ImGuiTextBuffer
 // - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).
 // - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)
 // Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.
-export class ImGuiStorage
-{
-    // struct Pair
-    // {
-    //     ImGuiID key;
-    //     union { int val_i; float val_f; void* val_p; };
-    //     Pair(ImGuiID _key, int _val_i)   { key = _key; val_i = _val_i; }
-    //     Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }
-    //     Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }
-    // };
-    // ImVector<Pair>      Data;
-
-    // - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)
-    // - Set***() functions find pair, insertion on demand if missing.
-    // - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
-    // void                Clear() { Data.clear(); }
-    // IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;
-    // IMGUI_API void      SetInt(ImGuiID key, int val);
-    // IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;
-    // IMGUI_API void      SetBool(ImGuiID key, bool val);
-    // IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;
-    // IMGUI_API void      SetFloat(ImGuiID key, float val);
-    // IMGUI_API void*     GetVoidPtr(ImGuiID key) const; // default_val is NULL
-    // IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);
-
-    // - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.
-    // - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
-    // - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)
-    //      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;
-    // IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);
-    // IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);
-    // IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);
-    // IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);
-
-    // Use on your own storage if you know only integer are being stored (open/close all tree nodes)
-    // IMGUI_API void      SetAllInt(int val);
-
-    // For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
-    // IMGUI_API void      BuildSortByKey();
+export class ImGuiStorage {
+  // struct Pair
+  // {
+  //     ImGuiID key;
+  //     union { int val_i; float val_f; void* val_p; };
+  //     Pair(ImGuiID _key, int _val_i)   { key = _key; val_i = _val_i; }
+  //     Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }
+  //     Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }
+  // };
+  // ImVector<Pair>      Data;
+
+  // - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)
+  // - Set***() functions find pair, insertion on demand if missing.
+  // - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
+  // void                Clear() { Data.clear(); }
+  // IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;
+  // IMGUI_API void      SetInt(ImGuiID key, int val);
+  // IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;
+  // IMGUI_API void      SetBool(ImGuiID key, bool val);
+  // IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;
+  // IMGUI_API void      SetFloat(ImGuiID key, float val);
+  // IMGUI_API void*     GetVoidPtr(ImGuiID key) const; // default_val is NULL
+  // IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);
+
+  // - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.
+  // - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
+  // - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)
+  //      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;
+  // IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);
+  // IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);
+  // IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);
+  // IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);
+
+  // Use on your own storage if you know only integer are being stored (open/close all tree nodes)
+  // IMGUI_API void      SetAllInt(int val);
+
+  // For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
+  // IMGUI_API void      BuildSortByKey();
 }
 
 // Data payload for Drag and Drop operations
-export { ImGuiPayload as Payload }
-export interface ImGuiPayload<T>
-{
-    // Members
-    // void*           Data;               // Data (copied and owned by dear imgui)
-    Data: T;
-    // int             DataSize;           // Data size
-
-    // [Internal]
-    // ImGuiID         SourceId;           // Source item id
-    // ImGuiID         SourceParentId;     // Source parent id (if available)
-    // int             DataFrameCount;     // Data timestamp
-    // char            DataType[12 + 1];    // Data type tag (short user-supplied string, 12 characters max)
-    // bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
-    // bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.
-
-    // ImGuiPayload()  { Clear(); }
-    // void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
-    // bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
-    // bool IsPreview() const                  { return Preview; }
-    // bool IsDelivery() const                 { return Delivery; }
+export { ImGuiPayload as Payload };
+export interface ImGuiPayload<T> {
+  // Members
+  // void*           Data;               // Data (copied and owned by dear imgui)
+  Data: T;
+  // int             DataSize;           // Data size
+
+  // [Internal]
+  // ImGuiID         SourceId;           // Source item id
+  // ImGuiID         SourceParentId;     // Source parent id (if available)
+  // int             DataFrameCount;     // Data timestamp
+  // char            DataType[12 + 1];    // Data type tag (short user-supplied string, 12 characters max)
+  // bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
+  // bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.
+
+  // ImGuiPayload()  { Clear(); }
+  // void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
+  // bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
+  // bool IsPreview() const                  { return Preview; }
+  // bool IsDelivery() const                 { return Delivery; }
 }
 
 // Helpers macros to generate 32-bits encoded colors
@@ -1373,236 +1350,232 @@ export const IM_COL32_G_SHIFT: number = 8;
 export const IM_COL32_B_SHIFT: number = 16;
 export const IM_COL32_A_SHIFT: number = 24;
 export const IM_COL32_A_MASK: number = 0xFF000000;
-export { IM_COL32 as COL32 }
+export { IM_COL32 as COL32 };
 export function IM_COL32(R: number, G: number, B: number, A: number = 255): number {
-    return ((A << IM_COL32_A_SHIFT) | (B << IM_COL32_B_SHIFT) | (G << IM_COL32_G_SHIFT) | (R << IM_COL32_R_SHIFT)) >>> 0;
+  return ((A << IM_COL32_A_SHIFT) | (B << IM_COL32_B_SHIFT) | (G << IM_COL32_G_SHIFT) | (R << IM_COL32_R_SHIFT)) >>> 0;
 }
-export const IM_COL32_WHITE: number = IM_COL32(255, 255, 255, 255); export { IM_COL32_WHITE as COL32_WHITE }  // Opaque white = 0xFFFFFFFF
-export const IM_COL32_BLACK: number = IM_COL32(0, 0, 0, 255); export { IM_COL32_BLACK as COL32_BLACK }        // Opaque black
-export const IM_COL32_BLACK_TRANS: number = IM_COL32(0, 0, 0, 0); export { IM_COL32_BLACK_TRANS as COL32_BLACK_TRANS }    // Transparent black = 0x00000000
+export const IM_COL32_WHITE: number = IM_COL32(255, 255, 255, 255); export { IM_COL32_WHITE as COL32_WHITE }; // Opaque white = 0xFFFFFFFF
+export const IM_COL32_BLACK: number = IM_COL32(0, 0, 0, 255); export { IM_COL32_BLACK as COL32_BLACK }; // Opaque black
+export const IM_COL32_BLACK_TRANS: number = IM_COL32(0, 0, 0, 0); export { IM_COL32_BLACK_TRANS as COL32_BLACK_TRANS }; // Transparent black = 0x00000000
 
 // ImColor() helper to implicity converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)
 // Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.
 // **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.
 // **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.
-export { ImColor as Color }
-export class ImColor
-{
-    // ImVec4              Value;
-    public Value: ImVec4 = new ImVec4();
-
-    // ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }
-    // ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }
-    // ImColor(ImU32 rgba)                                             { float sc = 1.0f/255.0f; Value.x = (float)((rgba>>IM_COL32_R_SHIFT)&0xFF) * sc; Value.y = (float)((rgba>>IM_COL32_G_SHIFT)&0xFF) * sc; Value.z = (float)((rgba>>IM_COL32_B_SHIFT)&0xFF) * sc; Value.w = (float)((rgba>>IM_COL32_A_SHIFT)&0xFF) * sc; }
-    // ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }
-    // ImColor(const ImVec4& col)                                      { Value = col; }
-    constructor();
-    constructor(r: number, g: number, b: number);
-    constructor(r: number, g: number, b: number, a: number);
-    constructor(rgba: Bind.ImU32);
-    constructor(col: Readonly<Bind.interface_ImVec4>);
-    constructor(r: number | Bind.ImU32 | Readonly<Bind.interface_ImVec4> = 0.0, g: number = 0.0, b: number = 0.0, a: number = 1.0) {
-        if (typeof(r) === "number") {
-            if (r > 255 && g === 0.0 && b === 0.0 && a === 1.0) {
-                this.Value.x = Math.max(0.0, Math.min(1.0, ((r >> IM_COL32_R_SHIFT) & 0xFF) / 255));
-                this.Value.y = Math.max(0.0, Math.min(1.0, ((r >> IM_COL32_G_SHIFT) & 0xFF) / 255));
-                this.Value.z = Math.max(0.0, Math.min(1.0, ((r >> IM_COL32_B_SHIFT) & 0xFF) / 255));
-                this.Value.w = Math.max(0.0, Math.min(1.0, ((r >> IM_COL32_A_SHIFT) & 0xFF) / 255));
-            } else if (r <= 1.0 && g <= 1.0 && b <= 1.0 && a <= 1.0) {
-                this.Value.x = Math.max(0.0, r);
-                this.Value.y = Math.max(0.0, g);
-                this.Value.z = Math.max(0.0, b);
-                this.Value.w = Math.max(0.0, a);
-            } else {
-                this.Value.x = Math.max(0.0, Math.min(1.0, r / 255));
-                this.Value.y = Math.max(0.0, Math.min(1.0, g / 255));
-                this.Value.z = Math.max(0.0, Math.min(1.0, b / 255));
-                if (a <= 1.0) {
-                    this.Value.w = Math.max(0.0, a);
-                } else {
-                    this.Value.w = Math.max(0.0, Math.min(1.0, a / 255));
-                }
-            }
+export { ImColor as Color };
+export class ImColor {
+  // ImVec4              Value;
+  public Value: ImVec4 = new ImVec4();
+
+  // ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }
+  // ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }
+  // ImColor(ImU32 rgba)                                             { float sc = 1.0f/255.0f; Value.x = (float)((rgba>>IM_COL32_R_SHIFT)&0xFF) * sc; Value.y = (float)((rgba>>IM_COL32_G_SHIFT)&0xFF) * sc; Value.z = (float)((rgba>>IM_COL32_B_SHIFT)&0xFF) * sc; Value.w = (float)((rgba>>IM_COL32_A_SHIFT)&0xFF) * sc; }
+  // ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }
+  // ImColor(const ImVec4& col)                                      { Value = col; }
+  constructor();
+  constructor(r: number, g: number, b: number);
+  constructor(r: number, g: number, b: number, a: number);
+  constructor(rgba: Bind.ImU32);
+  constructor(col: Readonly<Bind.interface_ImVec4>);
+  constructor(r: number | Bind.ImU32 | Readonly<Bind.interface_ImVec4> = 0.0, g: number = 0.0, b: number = 0.0, a: number = 1.0) {
+    if (typeof (r) === "number") {
+      if (r > 255 && g === 0.0 && b === 0.0 && a === 1.0) {
+        this.Value.x = Math.max(0.0, Math.min(1.0, ((r >> IM_COL32_R_SHIFT) & 0xFF) / 255));
+        this.Value.y = Math.max(0.0, Math.min(1.0, ((r >> IM_COL32_G_SHIFT) & 0xFF) / 255));
+        this.Value.z = Math.max(0.0, Math.min(1.0, ((r >> IM_COL32_B_SHIFT) & 0xFF) / 255));
+        this.Value.w = Math.max(0.0, Math.min(1.0, ((r >> IM_COL32_A_SHIFT) & 0xFF) / 255));
+      } else if (r <= 1.0 && g <= 1.0 && b <= 1.0 && a <= 1.0) {
+        this.Value.x = Math.max(0.0, r);
+        this.Value.y = Math.max(0.0, g);
+        this.Value.z = Math.max(0.0, b);
+        this.Value.w = Math.max(0.0, a);
+      } else {
+        this.Value.x = Math.max(0.0, Math.min(1.0, r / 255));
+        this.Value.y = Math.max(0.0, Math.min(1.0, g / 255));
+        this.Value.z = Math.max(0.0, Math.min(1.0, b / 255));
+        if (a <= 1.0) {
+          this.Value.w = Math.max(0.0, a);
         } else {
-            this.Value.Copy(r);
+          this.Value.w = Math.max(0.0, Math.min(1.0, a / 255));
         }
-    }
-    // inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }
-    public toImU32(): Bind.ImU32 { return ColorConvertFloat4ToU32(this.Value); }
-    // inline operator ImVec4() const                                  { return Value; }
-    public toImVec4(): ImVec4 { return this.Value; }
-
-    // FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.
-    // inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }
-    public SetHSV(h: number, s: number, v: number, a: number = 1.0): void {
-        const ref_r: Bind.ImScalar<number> = [ this.Value.x ];
-        const ref_g: Bind.ImScalar<number> = [ this.Value.y ];
-        const ref_b: Bind.ImScalar<number> = [ this.Value.z ];
-        ColorConvertHSVtoRGB(h, s, v, ref_r, ref_g, ref_b);
-        this.Value.x = ref_r[0];
-        this.Value.y = ref_g[0];
-        this.Value.z = ref_b[0];
-        this.Value.w = a;
-    }
-    // static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }
-    public static HSV(h: number, s: number, v: number, a: number = 1.0): ImColor {
-        const color = new ImColor();
-        color.SetHSV(h, s, v, a);
-        return color;
-    }
-}
-
-export { ImGuiInputTextDefaultSize as InputTextDefaultSize }
+      }
+    } else {
+      this.Value.Copy(r);
+    }
+  }
+  // inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }
+  public toImU32(): Bind.ImU32 { return ColorConvertFloat4ToU32(this.Value); }
+  // inline operator ImVec4() const                                  { return Value; }
+  public toImVec4(): ImVec4 { return this.Value; }
+
+  // FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.
+  // inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }
+  public SetHSV(h: number, s: number, v: number, a: number = 1.0): void {
+    const ref_r: Bind.ImScalar<number> = [this.Value.x];
+    const ref_g: Bind.ImScalar<number> = [this.Value.y];
+    const ref_b: Bind.ImScalar<number> = [this.Value.z];
+    ColorConvertHSVtoRGB(h, s, v, ref_r, ref_g, ref_b);
+    this.Value.x = ref_r[0];
+    this.Value.y = ref_g[0];
+    this.Value.z = ref_b[0];
+    this.Value.w = a;
+  }
+  // static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }
+  public static HSV(h: number, s: number, v: number, a: number = 1.0): ImColor {
+    const color = new ImColor();
+    color.SetHSV(h, s, v, a);
+    return color;
+  }
+}
+
+export { ImGuiInputTextDefaultSize as InputTextDefaultSize };
 export const ImGuiInputTextDefaultSize: number = 128;
 
-export { ImGuiInputTextCallback as InputTextCallback }
+export { ImGuiInputTextCallback as InputTextCallback };
 export type ImGuiInputTextCallback<T> = (data: ImGuiInputTextCallbackData<T>) => number;
 
 // Shared state of InputText(), passed to callback when a ImGuiInputTextFlags_Callback* flag is used and the corresponding callback is triggered.
-export { ImGuiInputTextCallbackData as InputTextCallbackData }
+export { ImGuiInputTextCallbackData as InputTextCallbackData };
 export class ImGuiInputTextCallbackData<T> {
-    constructor(public readonly native: Bind.reference_ImGuiInputTextCallbackData, public readonly UserData: T | null = null) {}
-
-    // ImGuiInputTextFlags EventFlag;      // One of ImGuiInputTextFlags_Callback* // Read-only
-    public get EventFlag(): ImGuiInputTextFlags { return this.native.EventFlag; }
-    // ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only
-    public get Flags(): ImGuiInputTextFlags { return this.native.Flags; }
-    // void*               UserData;       // What user passed to InputText()      // Read-only
-    // public get UserData(): any { return this.native.UserData; }
-
-    // CharFilter event:
-    // ImWchar             EventChar;      // Character input                      // Read-write (replace character or set to zero)
-    public get EventChar(): Bind.ImWchar { return this.native.EventChar; }
-    public set EventChar(value: Bind.ImWchar) { this.native.EventChar = value; }
-
-    // Completion,History,Always events:
-    // If you modify the buffer contents make sure you update 'BufTextLen' and set 'BufDirty' to true.
-    // ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only
-    public get EventKey(): ImGuiKey { return this.native.EventKey; }
-    // char*               Buf;            // Current text buffer                  // Read-write (pointed data only, can't replace the actual pointer)
-    public get Buf(): string { return this.native.Buf; }
-    public set Buf(value: string) { this.native.Buf = value; }
-    // int                 BufTextLen;     // Current text length in bytes         // Read-write
-    public get BufTextLen(): number { return this.native.BufTextLen; }
-    public set BufTextLen(value: number) { this.native.BufTextLen = value; }
-    // int                 BufSize;        // Maximum text length in bytes         // Read-only
-    public get BufSize(): number { return this.native.BufSize; }
-    // bool                BufDirty;       // Set if you modify Buf/BufTextLen!!   // Write
-    public set BufDirty(value: boolean) { this.native.BufDirty = value; }
-    // int                 CursorPos;      //                                      // Read-write
-    public get CursorPos(): number { return this.native.CursorPos; }
-    public set CursorPos(value: number) { this.native.CursorPos = value; }
-    // int                 SelectionStart; //                                      // Read-write (== to SelectionEnd when no selection)
-    public get SelectionStart(): number { return this.native.SelectionStart; }
-    public set SelectionStart(value: number) { this.native.SelectionStart = value; }
-    // int                 SelectionEnd;   //                                      // Read-write
-    public get SelectionEnd(): number { return this.native.SelectionEnd; }
-    public set SelectionEnd(value: number) { this.native.SelectionEnd = value; }
-
-    // NB: Helper functions for text manipulation. Calling those function loses selection.
-    // IMGUI_API void    DeleteChars(int pos, int bytes_count);
-    public DeleteChars(pos: number, bytes_count: number): void { return this.native.DeleteChars(pos, bytes_count); }
-    // IMGUI_API void    InsertChars(int pos, const char* text, const char* text_end = NULL);
-    public InsertChars(pos: number, text: string, text_end: number | null = null): void { return this.native.InsertChars(pos, text_end !== null ? text.substring(0, text_end) : text); }
-    // void                SelectAll()             { SelectionStart = 0; SelectionEnd = BufTextLen; }
-    public SelectAll(): void { this.native.SelectAll(); }
-    // void                ClearSelection()        { SelectionStart = SelectionEnd = BufTextLen; }
-    public ClearSelection(): void { this.native.ClearSelection(); }
-    // bool              HasSelection() const { return SelectionStart != SelectionEnd; }
-    public HasSelection(): boolean { return this.native.HasSelection(); }
-}
-
-export { ImGuiSizeCallback as SizeCallback }
+  constructor(public readonly native: Bind.reference_ImGuiInputTextCallbackData, public readonly UserData: T | null = null) {}
+
+  // ImGuiInputTextFlags EventFlag;      // One of ImGuiInputTextFlags_Callback* // Read-only
+  public get EventFlag(): ImGuiInputTextFlags { return this.native.EventFlag; }
+  // ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only
+  public get Flags(): ImGuiInputTextFlags { return this.native.Flags; }
+  // void*               UserData;       // What user passed to InputText()      // Read-only
+  // public get UserData(): any { return this.native.UserData; }
+
+  // CharFilter event:
+  // ImWchar             EventChar;      // Character input                      // Read-write (replace character or set to zero)
+  public get EventChar(): Bind.ImWchar { return this.native.EventChar; }
+  public set EventChar(value: Bind.ImWchar) { this.native.EventChar = value; }
+
+  // Completion,History,Always events:
+  // If you modify the buffer contents make sure you update 'BufTextLen' and set 'BufDirty' to true.
+  // ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only
+  public get EventKey(): ImGuiKey { return this.native.EventKey; }
+  // char*               Buf;            // Current text buffer                  // Read-write (pointed data only, can't replace the actual pointer)
+  public get Buf(): string { return this.native.Buf; }
+  public set Buf(value: string) { this.native.Buf = value; }
+  // int                 BufTextLen;     // Current text length in bytes         // Read-write
+  public get BufTextLen(): number { return this.native.BufTextLen; }
+  public set BufTextLen(value: number) { this.native.BufTextLen = value; }
+  // int                 BufSize;        // Maximum text length in bytes         // Read-only
+  public get BufSize(): number { return this.native.BufSize; }
+  // bool                BufDirty;       // Set if you modify Buf/BufTextLen!!   // Write
+  public set BufDirty(value: boolean) { this.native.BufDirty = value; }
+  // int                 CursorPos;      //                                      // Read-write
+  public get CursorPos(): number { return this.native.CursorPos; }
+  public set CursorPos(value: number) { this.native.CursorPos = value; }
+  // int                 SelectionStart; //                                      // Read-write (== to SelectionEnd when no selection)
+  public get SelectionStart(): number { return this.native.SelectionStart; }
+  public set SelectionStart(value: number) { this.native.SelectionStart = value; }
+  // int                 SelectionEnd;   //                                      // Read-write
+  public get SelectionEnd(): number { return this.native.SelectionEnd; }
+  public set SelectionEnd(value: number) { this.native.SelectionEnd = value; }
+
+  // NB: Helper functions for text manipulation. Calling those function loses selection.
+  // IMGUI_API void    DeleteChars(int pos, int bytes_count);
+  public DeleteChars(pos: number, bytes_count: number): void { return this.native.DeleteChars(pos, bytes_count); }
+  // IMGUI_API void    InsertChars(int pos, const char* text, const char* text_end = NULL);
+  public InsertChars(pos: number, text: string, text_end: number | null = null): void { return this.native.InsertChars(pos, text_end !== null ? text.substring(0, text_end) : text); }
+  // void                SelectAll()             { SelectionStart = 0; SelectionEnd = BufTextLen; }
+  public SelectAll(): void { this.native.SelectAll(); }
+  // void                ClearSelection()        { SelectionStart = SelectionEnd = BufTextLen; }
+  public ClearSelection(): void { this.native.ClearSelection(); }
+  // bool              HasSelection() const { return SelectionStart != SelectionEnd; }
+  public HasSelection(): boolean { return this.native.HasSelection(); }
+}
+
+export { ImGuiSizeCallback as SizeCallback };
 export type ImGuiSizeCallback<T> = (data: ImGuiSizeCallbackData<T>) => void;
 
 // Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().
 // NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.
-export { ImGuiSizeCallbackData as SizeCallbackData }
+export { ImGuiSizeCallbackData as SizeCallbackData };
 export class ImGuiSizeCallbackData<T> {
-    constructor(public readonly native: Bind.reference_ImGuiSizeCallbackData, public readonly UserData: T) {}
+  constructor(public readonly native: Bind.reference_ImGuiSizeCallbackData, public readonly UserData: T) {}
 
-    get Pos(): Readonly<Bind.interface_ImVec2> { return this.native.Pos; }
-    get CurrentSize(): Readonly<Bind.interface_ImVec2> { return this.native.CurrentSize; }
-    get DesiredSize(): Bind.interface_ImVec2 { return this.native.DesiredSize; }
+  get Pos(): Readonly<Bind.interface_ImVec2> { return this.native.Pos; }
+  get CurrentSize(): Readonly<Bind.interface_ImVec2> { return this.native.CurrentSize; }
+  get DesiredSize(): Bind.interface_ImVec2 { return this.native.DesiredSize; }
 }
 
 // Sorting specification for one column of a table (sizeof == 12 bytes)
-export { ImGuiTableColumnSortSpecs as TableColumnSortSpecs }
-export class ImGuiTableColumnSortSpecs
-{
-    constructor(public readonly native: Bind.reference_ImGuiTableColumnSortSpecs) {}
-    get ColumnUserID(): ImGuiID { return this.native.ColumnUserID; }
-    get ColumnIndex(): Bind.ImS16 { return this.native.ColumnIndex; }
-    get SortOrder(): Bind.ImS16 { return this.native.SortOrder; }
-    get SortDirection(): ImGuiSortDirection { return this.native.SortDirection; }
+export { ImGuiTableColumnSortSpecs as TableColumnSortSpecs };
+export class ImGuiTableColumnSortSpecs {
+  constructor(public readonly native: Bind.reference_ImGuiTableColumnSortSpecs) {}
+  get ColumnUserID(): ImGuiID { return this.native.ColumnUserID; }
+  get ColumnIndex(): Bind.ImS16 { return this.native.ColumnIndex; }
+  get SortOrder(): Bind.ImS16 { return this.native.SortOrder; }
+  get SortDirection(): ImGuiSortDirection { return this.native.SortDirection; }
 }
 
 // Sorting specifications for a table (often handling sort specs for a single column, occasionally more)
 // Obtained by calling TableGetSortSpecs().
 // When 'SpecsDirty == true' you can sort your data. It will be true with sorting specs have changed since last call, or the first time.
 // Make sure to set 'SpecsDirty = false' after sorting, else you may wastefully sort your data every frame!
-export { ImGuiTableSortSpecs as TableSortSpecs }
-export class ImGuiTableSortSpecs
-{
-    constructor(public readonly native: Bind.reference_ImGuiTableSortSpecs) {
-        this._Specs = Array.from({length: this.SpecsCount}).map((_, i) => {
-            return new ImGuiTableColumnSortSpecs(this.native.GetSpec(i));
-        })
-    }
-
-    private _Specs: Readonly<ImGuiTableColumnSortSpecs[]>;
-    get Specs(): Readonly<ImGuiTableColumnSortSpecs[]> { return this._Specs; }
-    get SpecsCount(): number { return this.native.SpecsCount; }
-    get SpecsDirty(): boolean { return this.native.SpecsDirty; }
-    set SpecsDirty(value: boolean) { this.native.SpecsDirty = value; }
-}
-
-export { ImGuiListClipper as ListClipper }
-export class ImGuiListClipper
-{
-    private _native: Bind.ImGuiListClipper | null = null;
-    private get native(): Bind.ImGuiListClipper {
-        return this._native || (this._native = new bind.ImGuiListClipper());
-    }
-
-    public get DisplayStart(): number { return this.native.DisplayStart; }
-    public get DisplayEnd(): number { return this.native.DisplayEnd; }
-
-    public get ItemsCount(): number { return this.native.ItemsCount; }
-    public get StepNo(): number { return this.native.StepNo; }
-    public get ItemsFrozen(): number { return this.native.ItemsFrozen; }
-    public get ItemsHeight(): number { return this.native.ItemsHeight; }
-    public get StartPosY(): number { return this.native.StartPosY; }
-
-    // items_count:  Use -1 to ignore (you can call Begin later). Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step).
-    // items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().
-    // If you don't specify an items_height, you NEED to call Step(). If you specify items_height you may call the old Begin()/End() api directly, but prefer calling Step().
-    // ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).
-    // ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.
-    public delete(): void {
-        if (this._native !== null) {
-            this._native.delete();
-            this._native = null;
-        }
-    }
-
-    // IMGUI_API void Begin(int items_count, float items_height = -1.0f);  // Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.
-    public Begin(items_count: number, items_height: number = -1.0): void {
-        this.native.Begin(items_count, items_height);
-    }
-    // IMGUI_API void End();                                               // Automatically called on the last call of Step() that returns false.
-    public End(): void {
-        this.native.End();
-        this.delete();
-    }
-    // IMGUI_API bool Step();                                              // Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
-    public Step(): boolean {
-        const busy: boolean = this.native.Step();
-        if (!busy) {
-            this.delete();
-        }
-        return busy;
-    }
+export { ImGuiTableSortSpecs as TableSortSpecs };
+export class ImGuiTableSortSpecs {
+  constructor(public readonly native: Bind.reference_ImGuiTableSortSpecs) {
+    this._Specs = Array.from({ length: this.SpecsCount }).map((_, i) => {
+      return new ImGuiTableColumnSortSpecs(this.native.GetSpec(i));
+    })
+  }
+
+  private _Specs: Readonly<ImGuiTableColumnSortSpecs[]>;
+  get Specs(): Readonly<ImGuiTableColumnSortSpecs[]> { return this._Specs; }
+  get SpecsCount(): number { return this.native.SpecsCount; }
+  get SpecsDirty(): boolean { return this.native.SpecsDirty; }
+  set SpecsDirty(value: boolean) { this.native.SpecsDirty = value; }
+}
+
+export { ImGuiListClipper as ListClipper };
+export class ImGuiListClipper {
+  private _native: Bind.ImGuiListClipper | null = null;
+  private get native(): Bind.ImGuiListClipper {
+    return this._native || (this._native = new bind.ImGuiListClipper());
+  }
+
+  public get DisplayStart(): number { return this.native.DisplayStart; }
+  public get DisplayEnd(): number { return this.native.DisplayEnd; }
+
+  public get ItemsCount(): number { return this.native.ItemsCount; }
+  public get StepNo(): number { return this.native.StepNo; }
+  public get ItemsFrozen(): number { return this.native.ItemsFrozen; }
+  public get ItemsHeight(): number { return this.native.ItemsHeight; }
+  public get StartPosY(): number { return this.native.StartPosY; }
+
+  // items_count:  Use -1 to ignore (you can call Begin later). Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step).
+  // items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().
+  // If you don't specify an items_height, you NEED to call Step(). If you specify items_height you may call the old Begin()/End() api directly, but prefer calling Step().
+  // ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).
+  // ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.
+  public delete(): void {
+    if (this._native !== null) {
+      this._native.delete();
+      this._native = null;
+    }
+  }
+
+  // IMGUI_API void Begin(int items_count, float items_height = -1.0f);  // Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.
+  public Begin(items_count: number, items_height: number = -1.0): void {
+    this.native.Begin(items_count, items_height);
+  }
+  // IMGUI_API void End();                                               // Automatically called on the last call of Step() that returns false.
+  public End(): void {
+    this.native.End();
+    this.delete();
+  }
+  // IMGUI_API bool Step();                                              // Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
+  public Step(): boolean {
+    const busy: boolean = this.native.Step();
+    if (!busy) {
+      this.delete();
+    }
+    return busy;
+  }
 }
 
 //-----------------------------------------------------------------------------
@@ -1630,37 +1603,36 @@ export const ImDrawCallback_ResetRenderState = -1;
 // Pre 1.71 back-ends will typically ignore the VtxOffset/IdxOffset fields. When 'io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset'
 // is enabled, those fields allow us to render meshes larger than 64K vertices while keeping 16-bits indices.
 
-export { ImDrawCmd as DrawCmd }
-export class ImDrawCmd
-{
-    constructor(public readonly native: Bind.reference_ImDrawCmd) {}
-
-    // unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
-    get ElemCount(): number { return this.native.ElemCount; }
-    // ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2)
-    get ClipRect(): Readonly<Bind.reference_ImVec4> { return this.native.ClipRect; }
-    // ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
-    get TextureId(): ImTextureID | null {
-        return ImGuiContext.getTexture(this.native.TextureId);
-    }
-    // unsigned int    VtxOffset;              // Start offset in vertex buffer. Pre-1.71 or without ImGuiBackendFlags_RendererHasVtxOffset: always 0. With ImGuiBackendFlags_RendererHasVtxOffset: may be >0 to support meshes larger than 64K vertices with 16-bits indices.
-    get VtxOffset(): number { return this.native.VtxOffset; }
-    // unsigned int    IdxOffset;              // Start offset in index buffer. Always equal to sum of ElemCount drawn so far.
-    get IdxOffset(): number { return this.native.IdxOffset; }
-    // ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
-    get UserCallback(): ImDrawCallback | null {
-        if(this.native.UserCallback) {
-            const _callback:ImDrawCallback=(parent_list, cmd)=>{
-                this.native.UserCallback(parent_list.native, cmd.native);
-            };
-            return _callback;
-        }
-        return null;
-    } 
-    // void*           UserCallbackData;       // The draw callback code can access this.
-    get UserCallbackData(): any { return this.native.UserCallbackData }
-
-    // ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = ClipRect.z = ClipRect.w = 0.0f; TextureId = NULL; UserCallback = NULL; UserCallbackData = NULL; }
+export { ImDrawCmd as DrawCmd };
+export class ImDrawCmd {
+  constructor(public readonly native: Bind.reference_ImDrawCmd) {}
+
+  // unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
+  get ElemCount(): number { return this.native.ElemCount; }
+  // ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2)
+  get ClipRect(): Readonly<Bind.reference_ImVec4> { return this.native.ClipRect; }
+  // ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
+  get TextureId(): ImTextureID | null {
+    return ImGuiContext.getTexture(this.native.TextureId);
+  }
+  // unsigned int    VtxOffset;              // Start offset in vertex buffer. Pre-1.71 or without ImGuiBackendFlags_RendererHasVtxOffset: always 0. With ImGuiBackendFlags_RendererHasVtxOffset: may be >0 to support meshes larger than 64K vertices with 16-bits indices.
+  get VtxOffset(): number { return this.native.VtxOffset; }
+  // unsigned int    IdxOffset;              // Start offset in index buffer. Always equal to sum of ElemCount drawn so far.
+  get IdxOffset(): number { return this.native.IdxOffset; }
+  // ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
+  get UserCallback(): ImDrawCallback | null {
+    if (this.native.UserCallback) {
+      const _callback: ImDrawCallback = (parent_list, cmd) => {
+        this.native.UserCallback(parent_list.native, cmd.native);
+      };
+      return _callback;
+    }
+    return null;
+  }
+  // void*           UserCallbackData;       // The draw callback code can access this.
+  get UserCallbackData(): any { return this.native.UserCallbackData }
+
+  // ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = ClipRect.z = ClipRect.w = 0.0f; TextureId = NULL; UserCallback = NULL; UserCallbackData = NULL; }
 }
 
 // Vertex index
@@ -1669,36 +1641,35 @@ export class ImDrawCmd
 // #ifndef ImDrawIdx
 // typedef unsigned short ImDrawIdx;
 // #endif
-export { ImDrawIdxSize as DrawIdxSize }
+export { ImDrawIdxSize as DrawIdxSize };
 export const ImDrawIdxSize: number = 4; // bind.ImDrawIdxSize;
-export { ImDrawIdx as DrawIdx }
+export { ImDrawIdx as DrawIdx };
 export type ImDrawIdx = number;
 
 // Vertex layout
 // #ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT
-export { ImDrawVertSize as DrawVertSize }
+export { ImDrawVertSize as DrawVertSize };
 export const ImDrawVertSize: number = 20; // bind.ImDrawVertSize;
-export { ImDrawVertPosOffset as DrawVertPosOffset }
+export { ImDrawVertPosOffset as DrawVertPosOffset };
 export const ImDrawVertPosOffset: number = 0; // bind.ImDrawVertPosOffset;
-export { ImDrawVertUVOffset as DrawVertUVOffset }
+export { ImDrawVertUVOffset as DrawVertUVOffset };
 export const ImDrawVertUVOffset: number = 8; // bind.ImDrawVertUVOffset;
-export { ImDrawVertColOffset as DrawVertColOffset }
+export { ImDrawVertColOffset as DrawVertColOffset };
 export const ImDrawVertColOffset: number = 16; // bind.ImDrawVertColOffset;
-export { ImDrawVert as DrawVert }
-export class ImDrawVert
-{
-    // ImVec2  pos;
-    public pos: Float32Array;
-    // ImVec2  uv;
-    public uv: Float32Array;
-    // ImU32   col;
-    public col: Uint32Array;
-
-    constructor(buffer: ArrayBuffer, byteOffset: number = 0) {
-        this.pos = new Float32Array(buffer, byteOffset + bind.ImDrawVertPosOffset, 2);
-        this.uv = new Float32Array(buffer, byteOffset + bind.ImDrawVertUVOffset, 2);
-        this.col = new Uint32Array(buffer, byteOffset + bind.ImDrawVertColOffset, 1);
-    }
+export { ImDrawVert as DrawVert };
+export class ImDrawVert {
+  // ImVec2  pos;
+  public pos: Float32Array;
+  // ImVec2  uv;
+  public uv: Float32Array;
+  // ImU32   col;
+  public col: Uint32Array;
+
+  constructor(buffer: ArrayBuffer, byteOffset: number = 0) {
+    this.pos = new Float32Array(buffer, byteOffset + bind.ImDrawVertPosOffset, 2);
+    this.uv = new Float32Array(buffer, byteOffset + bind.ImDrawVertUVOffset, 2);
+    this.col = new Uint32Array(buffer, byteOffset + bind.ImDrawVertColOffset, 1);
+  }
 }
 // #else
 // You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h
@@ -1709,24 +1680,21 @@ export class ImDrawVert
 // #endif
 
 // [Internal] For use by ImDrawList
-export class ImDrawCmdHeader
-{
-    // ImVec4          ClipRect;
-    // ImTextureID     TextureId;
-    // unsigned int    VtxOffset;
+export class ImDrawCmdHeader {
+  // ImVec4          ClipRect;
+  // ImTextureID     TextureId;
+  // unsigned int    VtxOffset;
 }
 
 // Draw channels are used by the Columns API to "split" the render list into different channels while building, so items of each column can be batched together.
 // You can also use them to simulate drawing layers and submit primitives in a different order than how they will be rendered.
-export class ImDrawChannel
-{
-    // ImVector<ImDrawCmd>     CmdBuffer;
-    // ImVector<ImDrawIdx>     IdxBuffer;
+export class ImDrawChannel {
+  // ImVector<ImDrawCmd>     CmdBuffer;
+  // ImVector<ImDrawIdx>     IdxBuffer;
 }
 
-export class ImDrawListSharedData
-{
-    constructor(public readonly native: Bind.reference_ImDrawListSharedData) {}
+export class ImDrawListSharedData {
+  constructor(public readonly native: Bind.reference_ImDrawListSharedData) {}
 }
 
 // Draw command list
@@ -1735,452 +1703,444 @@ export class ImDrawListSharedData
 // You can interleave normal ImGui:: calls and adding primitives to the current draw list.
 // All positions are generally in pixel coordinates (top-left at (0,0), bottom-right at io.DisplaySize), however you are totally free to apply whatever transformation matrix to want to the data (if you apply such transformation you'll want to apply it to ClipRect as well)
 // Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
-export { ImDrawList as DrawList }
-export class ImDrawList
-{
-    constructor(public readonly native: Bind.reference_ImDrawList) {}
-
-    public IterateDrawCmds(callback: (draw_cmd: ImDrawCmd, ElemStart: number) => void): void {
-        this.native.IterateDrawCmds((draw_cmd: Bind.reference_ImDrawCmd, ElemStart: number): void => {
-            callback(new ImDrawCmd(draw_cmd), ElemStart);
-        });
-    }
+export { ImDrawList as DrawList };
+export class ImDrawList {
+  constructor(public readonly native: Bind.reference_ImDrawList) {}
 
-    // This is what you have to render
-    // ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
-    // ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those
-    get IdxBuffer(): Uint8Array { return this.native.IdxBuffer; }
-    // ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.
-    get VtxBuffer(): Uint8Array { return this.native.VtxBuffer; }
-    // ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.
-    get Flags(): ImDrawListFlags { return this.native.Flags; }
-    set Flags(value: ImDrawListFlags) { this.native.Flags = value; }
-
-    // [Internal, used while building lists]
-    // unsigned int            _VtxCurrentIdx;     // [Internal] == VtxBuffer.Size
-    // const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
-    // const char*             _OwnerName;         // Pointer to owner window's name for debugging
-    // ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
-    // ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
-    // ImVector<ImVec4>        _ClipRectStack;     // [Internal]
-    // ImVector<ImTextureID>   _TextureIdStack;    // [Internal]
-    // ImVector<ImVec2>        _Path;              // [Internal] current path building
-    // int                     _ChannelsCurrent;   // [Internal] current channel number (0)
-    // int                     _ChannelsCount;     // [Internal] number of active channels (1+)
-    // ImVector<ImDrawChannel> _Channels;          // [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)
-
-    // ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }
-    // ~ImDrawList() { ClearFreeMemory(); }
-    // IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
-    public PushClipRect(clip_rect_min: Readonly<Bind.interface_ImVec2>, clip_rect_max: Readonly<Bind.interface_ImVec2>, intersect_with_current_clip_rect: boolean = false): void {
-        this.native.PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
-    }
-    // IMGUI_API void  PushClipRectFullScreen();
-    public PushClipRectFullScreen(): void { this.native.PushClipRectFullScreen(); }
-    // IMGUI_API void  PopClipRect();
-    public PopClipRect(): void { this.native.PopClipRect(); }
-    // IMGUI_API void  PushTextureID(ImTextureID texture_id);
-    public PushTextureID(texture_id: ImTextureID): void {
-        this.native.PushTextureID(ImGuiContext.setTexture(texture_id));
-    }
-    // IMGUI_API void  PopTextureID();
-    public PopTextureID(): void { this.native.PopTextureID(); }
-    // inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
-    public GetClipRectMin(out: Bind.interface_ImVec2 = new ImVec2()): Bind.interface_ImVec2 {
-        return this.native.GetClipRectMin(out);
-    }
-    // inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }
-    public GetClipRectMax(out: Bind.interface_ImVec2 = new ImVec2()): Bind.interface_ImVec2 {
-        return this.native.GetClipRectMax(out);
-    }
-
-    // Primitives
-    // IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);
-    public AddLine(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, thickness: number = 1.0): void {
-        this.native.AddLine(a, b, col, thickness);
-    }
-    // IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right, rounding_corners_flags: 4-bits corresponding to which corner to round
-    public AddRect(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, rounding: number = 0.0, rounding_corners_flags: ImDrawCornerFlags = ImDrawCornerFlags.All, thickness: number = 1.0): void {
-        this.native.AddRect(a, b, col, rounding, rounding_corners_flags, thickness);
-    }
-    // IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right
-    public AddRectFilled(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, rounding: number = 0.0, rounding_corners_flags: ImDrawCornerFlags = ImDrawCornerFlags.All): void {
-        this.native.AddRectFilled(a, b, col, rounding, rounding_corners_flags);
-    }
-    // IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);
-    public AddRectFilledMultiColor(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, col_upr_left: Bind.ImU32, col_upr_right: Bind.ImU32, col_bot_right: Bind.ImU32, col_bot_left: Bind.ImU32): void {
-        this.native.AddRectFilledMultiColor(a, b, col_upr_left, col_upr_right, col_bot_right, col_bot_left);
-    }
-    // IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);
-    public AddQuad(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, c: Readonly<Bind.interface_ImVec2>, d: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, thickness: number = 1.0): void {
-        this.native.AddQuad(a, b, c, d, col, thickness);
-    }
-    // IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);
-    public AddQuadFilled(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, c: Readonly<Bind.interface_ImVec2>, d: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void {
-        this.native.AddQuadFilled(a, b, c, d, col);
-    }
-    // IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);
-    public AddTriangle(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, c: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, thickness: number = 1.0): void {
-        this.native.AddTriangle(a, b, c, col, thickness);
-    }
-    // IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);
-    public AddTriangleFilled(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, c: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void {
-        this.native.AddTriangleFilled(a, b, c, col);
-    }
-    // IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);
-    public AddCircle(centre: Readonly<Bind.interface_ImVec2>, radius: number, col: Bind.ImU32, num_segments: number = 12, thickness: number = 1.0): void {
-        this.native.AddCircle(centre, radius, col, num_segments, thickness);
-    }
-    // IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);
-    public AddCircleFilled(centre: Readonly<Bind.interface_ImVec2>, radius: number, col: Bind.ImU32, num_segments: number = 12): void {
-        this.native.AddCircleFilled(centre, radius, col, num_segments);
-    }
-    // IMGUI_API void  AddNgon(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness = 1.0f);
-    public AddNgon(centre: Readonly<Bind.interface_ImVec2>, radius: number, col: Bind.ImU32, num_segments: number, thickness: number = 1.0): void {
-        this.native.AddNgon(centre, radius, col, num_segments, thickness);
-    }
-    // IMGUI_API void  AddNgonFilled(const ImVec2& center, float radius, ImU32 col, int num_segments);
-    public AddNgonFilled(centre: Readonly<Bind.interface_ImVec2>, radius: number, col: Bind.ImU32, num_segments: number): void {
-        this.native.AddNgonFilled(centre, radius, col, num_segments);
-    }
-    // IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);
-    // IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);
-    public AddText(pos: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, text_begin: string, text_end?: number | null): void;
-    public AddText(font: ImFont, font_size: number, pos: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, text_begin: string, text_end?: number | null, wrap_width?: number, cpu_fine_clip_rect?: Readonly<Bind.interface_ImVec4> | null): void;
-    public AddText(...args: any[]): void {
-        if (args[0] instanceof ImFont) {
-            const font: ImFont = args[0];
-            const font_size: number = args[1];
-            const pos: Readonly<Bind.interface_ImVec2> = args[2];
-            const col: Bind.ImU32 = args[3];
-            const text_begin: string = args[4];
-            const text_end: number | null = args[5] || null;
-            const wrap_width: number = args[6] ? args[6] : 0.0;
-            const cpu_fine_clip_rect: Readonly<Bind.interface_ImVec4> | null = args[7] || null;
-            this.native.AddText_B(font.native, font_size, pos, col, text_end !== null ? text_begin.substring(0, text_end) : text_begin, wrap_width, cpu_fine_clip_rect);
-        } else {
-            const pos: Readonly<Bind.interface_ImVec2> = args[0];
-            const col: Bind.ImU32 = args[1];
-            const text_begin: string = args[2];
-            const text_end: number | null = args[3] || null;
-            this.native.AddText_A(pos, col, text_end !== null ? text_begin.substring(0, text_end) : text_begin);
-        }
-    }
-    // IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness);
-    public AddPolyline(points: Array<Readonly<Bind.interface_ImVec2>>, num_points: number, col: Bind.ImU32, closed: boolean, thickness: number): void {
-        this.native.AddPolyline(points, num_points, col, closed, thickness);
-    }
-    // IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col);
-    public AddConvexPolyFilled(points: Array<Readonly<Bind.interface_ImVec2>>, num_points: number, col: Bind.ImU32): void {
-        this.native.AddConvexPolyFilled(points, num_points, col);
-    }
-    // IMGUI_API void  AddBezierCubic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0); // Cubic Bezier (4 control points)
-    public AddBezierCubic(p1: Readonly<Bind.interface_ImVec2>, p2: Readonly<Bind.interface_ImVec2>, p3: Readonly<Bind.interface_ImVec2>, p4: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, thickness: number = 1.0, num_segments: number = 0): void {
-        this.native.AddBezierCubic(p1, p2, p3, p4, col, thickness, num_segments);
-    }
-    // IMGUI_API void  AddBezierQuadratic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness, int num_segments = 0);               // Quadratic Bezier (3 control points)
-    public AddBezierQuadratic(p1: Readonly<Bind.interface_ImVec2>, p2: Readonly<Bind.interface_ImVec2>, p3: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, thickness: number = 1.0, num_segments: number = 0): void {
-        this.native.AddBezierQuadratic(p1, p2, p3, col, thickness, num_segments);
-    }
-
-    // IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF);
-    public AddImage(user_texture_id: ImTextureID | null, a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, uv_a: Readonly<Bind.interface_ImVec2> = ImVec2.ZERO, uv_b: Readonly<Bind.interface_ImVec2> = ImVec2.UNIT, col: Bind.ImU32 = 0xFFFFFFFF): void {
-        this.native.AddImage(ImGuiContext.setTexture(user_texture_id), a, b, uv_a, uv_b, col);
-    }
-    // IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF);
-    public AddImageQuad(user_texture_id: ImTextureID | null, a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, c: Readonly<Bind.interface_ImVec2>, d: Readonly<Bind.interface_ImVec2>, uv_a: Readonly<Bind.interface_ImVec2> = ImVec2.ZERO, uv_b: Readonly<Bind.interface_ImVec2> = ImVec2.UNIT_X, uv_c: Readonly<Bind.interface_ImVec2> = ImVec2.UNIT, uv_d: Readonly<Bind.interface_ImVec2> = ImVec2.UNIT_Y, col: Bind.ImU32 = 0xFFFFFFFF): void {
-        this.native.AddImageQuad(ImGuiContext.setTexture(user_texture_id), a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);
-    }
-    // IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);
-    public AddImageRounded(user_texture_id: ImTextureID | null, a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, uv_a: Readonly<Bind.interface_ImVec2>, uv_b: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, rounding: number, rounding_corners: ImDrawCornerFlags = ImDrawCornerFlags.All): void {
-        this.native.AddImageRounded(ImGuiContext.setTexture(user_texture_id), a, b, uv_a, uv_b, col, rounding, rounding_corners);
-    }
-    
-    // Stateful path API, add points then finish with PathFill() or PathStroke()
-    // inline    void  PathClear()                                                 { _Path.resize(0); }
-    public PathClear(): void { this.native.PathClear(); }
-    // inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
-    public PathLineTo(pos: Readonly<Bind.interface_ImVec2>): void { this.native.PathLineTo(pos); }
-    // inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }
-    public PathLineToMergeDuplicate(pos: Readonly<Bind.interface_ImVec2>): void { this.native.PathLineToMergeDuplicate(pos); }
-    // inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); PathClear(); }
-    public PathFillConvex(col: Bind.ImU32): void { this.native.PathFillConvex(col); }
-    // inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); PathClear(); }
-    public PathStroke(col: Bind.ImU32, closed: boolean, thickness: number = 1.0): void { this.native.PathStroke(col, closed, thickness); }
-    // IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);
-    public PathArcTo(centre: Readonly<Bind.interface_ImVec2>, radius: number, a_min: number, a_max: number, num_segments: number = 10): void { this.native.PathArcTo(centre, radius, a_min, a_max, num_segments); }
-    // IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                // Use precomputed angles for a 12 steps circle
-    public PathArcToFast(centre: Readonly<Bind.interface_ImVec2>, radius: number, a_min_of_12: number, a_max_of_12: number): void { this.native.PathArcToFast(centre, radius, a_min_of_12, a_max_of_12); }
-    // IMGUI_API void  PathBezierCubicCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0);  // Cubic Bezier (4 control points)
-    public PathBezierCubicCurveTo(p2: Readonly<Bind.interface_ImVec2>, p3: Readonly<Bind.interface_ImVec2>, p4: Readonly<Bind.interface_ImVec2>, num_segments: number = 0): void { this.native.PathBezierCubicCurveTo(p2, p3, p4, num_segments); }
-    // IMGUI_API void  PathBezierQuadraticCurveTo(const ImVec2& p2, const ImVec2& p3, int num_segments = 0);                // Quadratic Bezier (3 control points)
-    public PathBezierQuadraticCurveTo(p2: Readonly<Bind.interface_ImVec2>, p3: Readonly<Bind.interface_ImVec2>, num_segments: number = 0): void { this.native.PathBezierQuadraticCurveTo(p2, p3, num_segments); }
-    // IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);
-    public PathRect(rect_min: Readonly<Bind.interface_ImVec2>, rect_max: Readonly<Bind.interface_ImVec2>, rounding: number = 0.0, rounding_corners_flags: ImDrawCornerFlags = ImDrawCornerFlags.All): void { this.native.PathRect(rect_min, rect_max, rounding, rounding_corners_flags); }
-
-    // Channels
-    // - Use to simulate layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)
-    // - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)
-    // IMGUI_API void  ChannelsSplit(int channels_count);
-    public ChannelsSplit(channels_count: number): void { this.native.ChannelsSplit(channels_count); }
-    // IMGUI_API void  ChannelsMerge();
-    public ChannelsMerge(): void { this.native.ChannelsMerge(); }
-    // IMGUI_API void  ChannelsSetCurrent(int channel_index);
-    public ChannelsSetCurrent(channel_index: number): void { this.native.ChannelsSetCurrent(channel_index); }
-
-    // Advanced
-    // IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.
-    public AddCallback(callback: ImDrawCallback, callback_data: any): void {
-        const _callback: Bind.ImDrawCallback = (parent_list: Readonly<Bind.reference_ImDrawList>, draw_cmd: Readonly<Bind.reference_ImDrawCmd>): void => {
-            callback(new ImDrawList(parent_list), new ImDrawCmd(draw_cmd));
-        };
-        this.native.AddCallback(_callback, callback_data);
-    }
-    // IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
-    public AddDrawCmd(): void { this.native.AddDrawCmd(); }
-
-    // Internal helpers
-    // NB: all primitives needs to be reserved via PrimReserve() beforehand!
-    // IMGUI_API void  PrimReserve(int idx_count, int vtx_count);
-    public PrimReserve(idx_count: number, vtx_count: number): void { this.native.PrimReserve(idx_count, vtx_count); }
-    // IMGUI_API void  PrimUnreserve(int idx_count, int vtx_count);
-    public PrimUnreserve(idx_count: number, vtx_count: number): void { this.native.PrimUnreserve(idx_count, vtx_count); }
-    // IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)
-    public PrimRect(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void { this.native.PrimRect(a, b, col); }
-    // IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
-    public PrimRectUV(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, uv_a: Readonly<Bind.interface_ImVec2>, uv_b: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void { this.native.PrimRectUV(a, b, uv_a, uv_b, col); }
-    // IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);
-    public PrimQuadUV(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, c: Readonly<Bind.interface_ImVec2>, d: Readonly<Bind.interface_ImVec2>, uv_a: Readonly<Bind.interface_ImVec2>, uv_b: Readonly<Bind.interface_ImVec2>, uv_c: Readonly<Bind.interface_ImVec2>, uv_d: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void { this.native.PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col); }
-    // inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }
-    public PrimWriteVtx(pos: Readonly<Bind.interface_ImVec2>, uv: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void { this.native.PrimWriteVtx(pos, uv, col); }
-    // inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }
-    public PrimWriteIdx(idx: ImDrawIdx): void { this.native.PrimWriteIdx(idx); }
-    // inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }
-    public PrimVtx(pos: Readonly<Bind.interface_ImVec2>, uv: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void { this.native.PrimVtx(pos, uv, col); }
-
-    AddRectFilledMultiColorRound(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, col_lt: ImU32, col_rt: ImU32, col_lb: ImU32, col_rb: ImU32, rounding: number, rounding_corners_flags: ImDrawCornerFlags): void
-    {
-        this.native.AddRectFilledMultiColorRound(a, b, col_lt, col_rt, col_lb, col_rb, rounding, rounding_corners_flags);
-    }
-    GetVertexSize(): number { return this.native.GetVertexSize(); }
-    Transform(tm:Readonly<Bind.interface_ImTransform>, start:number, end?:number): void
-    {
-        if(!end) end=0;
-        this.native.Transform(tm, start, end);
-    }
+  public IterateDrawCmds(callback: (draw_cmd: ImDrawCmd, ElemStart: number) => void): void {
+    this.native.IterateDrawCmds((draw_cmd: Bind.reference_ImDrawCmd, ElemStart: number): void => {
+      callback(new ImDrawCmd(draw_cmd), ElemStart);
+    });
+  }
+
+  // This is what you have to render
+  // ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
+  // ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those
+  get IdxBuffer(): Uint8Array { return this.native.IdxBuffer; }
+  // ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.
+  get VtxBuffer(): Uint8Array { return this.native.VtxBuffer; }
+  // ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.
+  get Flags(): ImDrawListFlags { return this.native.Flags; }
+  set Flags(value: ImDrawListFlags) { this.native.Flags = value; }
+
+  // [Internal, used while building lists]
+  // unsigned int            _VtxCurrentIdx;     // [Internal] == VtxBuffer.Size
+  // const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
+  // const char*             _OwnerName;         // Pointer to owner window's name for debugging
+  // ImDrawVert*             _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
+  // ImDrawIdx*              _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
+  // ImVector<ImVec4>        _ClipRectStack;     // [Internal]
+  // ImVector<ImTextureID>   _TextureIdStack;    // [Internal]
+  // ImVector<ImVec2>        _Path;              // [Internal] current path building
+  // int                     _ChannelsCurrent;   // [Internal] current channel number (0)
+  // int                     _ChannelsCount;     // [Internal] number of active channels (1+)
+  // ImVector<ImDrawChannel> _Channels;          // [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)
+
+  // ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }
+  // ~ImDrawList() { ClearFreeMemory(); }
+  // IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
+  public PushClipRect(clip_rect_min: Readonly<Bind.interface_ImVec2>, clip_rect_max: Readonly<Bind.interface_ImVec2>, intersect_with_current_clip_rect: boolean = false): void {
+    this.native.PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
+  }
+  // IMGUI_API void  PushClipRectFullScreen();
+  public PushClipRectFullScreen(): void { this.native.PushClipRectFullScreen(); }
+  // IMGUI_API void  PopClipRect();
+  public PopClipRect(): void { this.native.PopClipRect(); }
+  // IMGUI_API void  PushTextureID(ImTextureID texture_id);
+  public PushTextureID(texture_id: ImTextureID): void {
+    this.native.PushTextureID(ImGuiContext.setTexture(texture_id));
+  }
+  // IMGUI_API void  PopTextureID();
+  public PopTextureID(): void { this.native.PopTextureID(); }
+  // inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
+  public GetClipRectMin(out: Bind.interface_ImVec2 = new ImVec2()): Bind.interface_ImVec2 {
+    return this.native.GetClipRectMin(out);
+  }
+  // inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }
+  public GetClipRectMax(out: Bind.interface_ImVec2 = new ImVec2()): Bind.interface_ImVec2 {
+    return this.native.GetClipRectMax(out);
+  }
+
+  // Primitives
+  // IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);
+  public AddLine(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, thickness: number = 1.0): void {
+    this.native.AddLine(a, b, col, thickness);
+  }
+  // IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right, rounding_corners_flags: 4-bits corresponding to which corner to round
+  public AddRect(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, rounding: number = 0.0, rounding_corners_flags: ImDrawCornerFlags = ImDrawCornerFlags.All, thickness: number = 1.0): void {
+    this.native.AddRect(a, b, col, rounding, rounding_corners_flags, thickness);
+  }
+  // IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right
+  public AddRectFilled(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, rounding: number = 0.0, rounding_corners_flags: ImDrawCornerFlags = ImDrawCornerFlags.All): void {
+    this.native.AddRectFilled(a, b, col, rounding, rounding_corners_flags);
+  }
+  // IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);
+  public AddRectFilledMultiColor(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, col_upr_left: Bind.ImU32, col_upr_right: Bind.ImU32, col_bot_right: Bind.ImU32, col_bot_left: Bind.ImU32): void {
+    this.native.AddRectFilledMultiColor(a, b, col_upr_left, col_upr_right, col_bot_right, col_bot_left);
+  }
+  // IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);
+  public AddQuad(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, c: Readonly<Bind.interface_ImVec2>, d: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, thickness: number = 1.0): void {
+    this.native.AddQuad(a, b, c, d, col, thickness);
+  }
+  // IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);
+  public AddQuadFilled(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, c: Readonly<Bind.interface_ImVec2>, d: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void {
+    this.native.AddQuadFilled(a, b, c, d, col);
+  }
+  // IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);
+  public AddTriangle(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, c: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, thickness: number = 1.0): void {
+    this.native.AddTriangle(a, b, c, col, thickness);
+  }
+  // IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);
+  public AddTriangleFilled(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, c: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void {
+    this.native.AddTriangleFilled(a, b, c, col);
+  }
+  // IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);
+  public AddCircle(centre: Readonly<Bind.interface_ImVec2>, radius: number, col: Bind.ImU32, num_segments: number = 12, thickness: number = 1.0): void {
+    this.native.AddCircle(centre, radius, col, num_segments, thickness);
+  }
+  // IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);
+  public AddCircleFilled(centre: Readonly<Bind.interface_ImVec2>, radius: number, col: Bind.ImU32, num_segments: number = 12): void {
+    this.native.AddCircleFilled(centre, radius, col, num_segments);
+  }
+  // IMGUI_API void  AddNgon(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness = 1.0f);
+  public AddNgon(centre: Readonly<Bind.interface_ImVec2>, radius: number, col: Bind.ImU32, num_segments: number, thickness: number = 1.0): void {
+    this.native.AddNgon(centre, radius, col, num_segments, thickness);
+  }
+  // IMGUI_API void  AddNgonFilled(const ImVec2& center, float radius, ImU32 col, int num_segments);
+  public AddNgonFilled(centre: Readonly<Bind.interface_ImVec2>, radius: number, col: Bind.ImU32, num_segments: number): void {
+    this.native.AddNgonFilled(centre, radius, col, num_segments);
+  }
+  // IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);
+  // IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);
+  public AddText(pos: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, text_begin: string, text_end?: number | null): void;
+  public AddText(font: ImFont, font_size: number, pos: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, text_begin: string, text_end?: number | null, wrap_width?: number, cpu_fine_clip_rect?: Readonly<Bind.interface_ImVec4> | null): void;
+  public AddText(...args: any[]): void {
+    if (args[0] instanceof ImFont) {
+      const font: ImFont = args[0];
+      const font_size: number = args[1];
+      const pos: Readonly<Bind.interface_ImVec2> = args[2];
+      const col: Bind.ImU32 = args[3];
+      const text_begin: string = args[4];
+      const text_end: number | null = args[5] || null;
+      const wrap_width: number = args[6] ? args[6] : 0.0;
+      const cpu_fine_clip_rect: Readonly<Bind.interface_ImVec4> | null = args[7] || null;
+      this.native.AddText_B(font.native, font_size, pos, col, text_end !== null ? text_begin.substring(0, text_end) : text_begin, wrap_width, cpu_fine_clip_rect);
+    } else {
+      const pos: Readonly<Bind.interface_ImVec2> = args[0];
+      const col: Bind.ImU32 = args[1];
+      const text_begin: string = args[2];
+      const text_end: number | null = args[3] || null;
+      this.native.AddText_A(pos, col, text_end !== null ? text_begin.substring(0, text_end) : text_begin);
+    }
+  }
+  // IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness);
+  public AddPolyline(points: Array<Readonly<Bind.interface_ImVec2>>, num_points: number, col: Bind.ImU32, closed: boolean, thickness: number): void {
+    this.native.AddPolyline(points, num_points, col, closed, thickness);
+  }
+  // IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col);
+  public AddConvexPolyFilled(points: Array<Readonly<Bind.interface_ImVec2>>, num_points: number, col: Bind.ImU32): void {
+    this.native.AddConvexPolyFilled(points, num_points, col);
+  }
+  // IMGUI_API void  AddBezierCubic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0); // Cubic Bezier (4 control points)
+  public AddBezierCubic(p1: Readonly<Bind.interface_ImVec2>, p2: Readonly<Bind.interface_ImVec2>, p3: Readonly<Bind.interface_ImVec2>, p4: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, thickness: number = 1.0, num_segments: number = 0): void {
+    this.native.AddBezierCubic(p1, p2, p3, p4, col, thickness, num_segments);
+  }
+  // IMGUI_API void  AddBezierQuadratic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness, int num_segments = 0);               // Quadratic Bezier (3 control points)
+  public AddBezierQuadratic(p1: Readonly<Bind.interface_ImVec2>, p2: Readonly<Bind.interface_ImVec2>, p3: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, thickness: number = 1.0, num_segments: number = 0): void {
+    this.native.AddBezierQuadratic(p1, p2, p3, col, thickness, num_segments);
+  }
+
+  // IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF);
+  public AddImage(user_texture_id: ImTextureID | null, a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, uv_a: Readonly<Bind.interface_ImVec2> = ImVec2.ZERO, uv_b: Readonly<Bind.interface_ImVec2> = ImVec2.UNIT, col: Bind.ImU32 = 0xFFFFFFFF): void {
+    this.native.AddImage(ImGuiContext.setTexture(user_texture_id), a, b, uv_a, uv_b, col);
+  }
+  // IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF);
+  public AddImageQuad(user_texture_id: ImTextureID | null, a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, c: Readonly<Bind.interface_ImVec2>, d: Readonly<Bind.interface_ImVec2>, uv_a: Readonly<Bind.interface_ImVec2> = ImVec2.ZERO, uv_b: Readonly<Bind.interface_ImVec2> = ImVec2.UNIT_X, uv_c: Readonly<Bind.interface_ImVec2> = ImVec2.UNIT, uv_d: Readonly<Bind.interface_ImVec2> = ImVec2.UNIT_Y, col: Bind.ImU32 = 0xFFFFFFFF): void {
+    this.native.AddImageQuad(ImGuiContext.setTexture(user_texture_id), a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);
+  }
+  // IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);
+  public AddImageRounded(user_texture_id: ImTextureID | null, a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, uv_a: Readonly<Bind.interface_ImVec2>, uv_b: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, rounding: number, rounding_corners: ImDrawCornerFlags = ImDrawCornerFlags.All): void {
+    this.native.AddImageRounded(ImGuiContext.setTexture(user_texture_id), a, b, uv_a, uv_b, col, rounding, rounding_corners);
+  }
+
+  // Stateful path API, add points then finish with PathFill() or PathStroke()
+  // inline    void  PathClear()                                                 { _Path.resize(0); }
+  public PathClear(): void { this.native.PathClear(); }
+  // inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }
+  public PathLineTo(pos: Readonly<Bind.interface_ImVec2>): void { this.native.PathLineTo(pos); }
+  // inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }
+  public PathLineToMergeDuplicate(pos: Readonly<Bind.interface_ImVec2>): void { this.native.PathLineToMergeDuplicate(pos); }
+  // inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); PathClear(); }
+  public PathFillConvex(col: Bind.ImU32): void { this.native.PathFillConvex(col); }
+  // inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); PathClear(); }
+  public PathStroke(col: Bind.ImU32, closed: boolean, thickness: number = 1.0): void { this.native.PathStroke(col, closed, thickness); }
+  // IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);
+  public PathArcTo(centre: Readonly<Bind.interface_ImVec2>, radius: number, a_min: number, a_max: number, num_segments: number = 10): void { this.native.PathArcTo(centre, radius, a_min, a_max, num_segments); }
+  // IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                // Use precomputed angles for a 12 steps circle
+  public PathArcToFast(centre: Readonly<Bind.interface_ImVec2>, radius: number, a_min_of_12: number, a_max_of_12: number): void { this.native.PathArcToFast(centre, radius, a_min_of_12, a_max_of_12); }
+  // IMGUI_API void  PathBezierCubicCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0);  // Cubic Bezier (4 control points)
+  public PathBezierCubicCurveTo(p2: Readonly<Bind.interface_ImVec2>, p3: Readonly<Bind.interface_ImVec2>, p4: Readonly<Bind.interface_ImVec2>, num_segments: number = 0): void { this.native.PathBezierCubicCurveTo(p2, p3, p4, num_segments); }
+  // IMGUI_API void  PathBezierQuadraticCurveTo(const ImVec2& p2, const ImVec2& p3, int num_segments = 0);                // Quadratic Bezier (3 control points)
+  public PathBezierQuadraticCurveTo(p2: Readonly<Bind.interface_ImVec2>, p3: Readonly<Bind.interface_ImVec2>, num_segments: number = 0): void { this.native.PathBezierQuadraticCurveTo(p2, p3, num_segments); }
+  // IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);
+  public PathRect(rect_min: Readonly<Bind.interface_ImVec2>, rect_max: Readonly<Bind.interface_ImVec2>, rounding: number = 0.0, rounding_corners_flags: ImDrawCornerFlags = ImDrawCornerFlags.All): void { this.native.PathRect(rect_min, rect_max, rounding, rounding_corners_flags); }
+
+  // Channels
+  // - Use to simulate layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)
+  // - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)
+  // IMGUI_API void  ChannelsSplit(int channels_count);
+  public ChannelsSplit(channels_count: number): void { this.native.ChannelsSplit(channels_count); }
+  // IMGUI_API void  ChannelsMerge();
+  public ChannelsMerge(): void { this.native.ChannelsMerge(); }
+  // IMGUI_API void  ChannelsSetCurrent(int channel_index);
+  public ChannelsSetCurrent(channel_index: number): void { this.native.ChannelsSetCurrent(channel_index); }
+
+  // Advanced
+  // IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.
+  public AddCallback(callback: ImDrawCallback, callback_data: any): void {
+    const _callback: Bind.ImDrawCallback = (parent_list: Readonly<Bind.reference_ImDrawList>, draw_cmd: Readonly<Bind.reference_ImDrawCmd>): void => {
+      callback(new ImDrawList(parent_list), new ImDrawCmd(draw_cmd));
+    };
+    this.native.AddCallback(_callback, callback_data);
+  }
+  // IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
+  public AddDrawCmd(): void { this.native.AddDrawCmd(); }
+
+  // Internal helpers
+  // NB: all primitives needs to be reserved via PrimReserve() beforehand!
+  // IMGUI_API void  PrimReserve(int idx_count, int vtx_count);
+  public PrimReserve(idx_count: number, vtx_count: number): void { this.native.PrimReserve(idx_count, vtx_count); }
+  // IMGUI_API void  PrimUnreserve(int idx_count, int vtx_count);
+  public PrimUnreserve(idx_count: number, vtx_count: number): void { this.native.PrimUnreserve(idx_count, vtx_count); }
+  // IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)
+  public PrimRect(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void { this.native.PrimRect(a, b, col); }
+  // IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
+  public PrimRectUV(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, uv_a: Readonly<Bind.interface_ImVec2>, uv_b: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void { this.native.PrimRectUV(a, b, uv_a, uv_b, col); }
+  // IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);
+  public PrimQuadUV(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, c: Readonly<Bind.interface_ImVec2>, d: Readonly<Bind.interface_ImVec2>, uv_a: Readonly<Bind.interface_ImVec2>, uv_b: Readonly<Bind.interface_ImVec2>, uv_c: Readonly<Bind.interface_ImVec2>, uv_d: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void { this.native.PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col); }
+  // inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }
+  public PrimWriteVtx(pos: Readonly<Bind.interface_ImVec2>, uv: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void { this.native.PrimWriteVtx(pos, uv, col); }
+  // inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }
+  public PrimWriteIdx(idx: ImDrawIdx): void { this.native.PrimWriteIdx(idx); }
+  // inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }
+  public PrimVtx(pos: Readonly<Bind.interface_ImVec2>, uv: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32): void { this.native.PrimVtx(pos, uv, col); }
+
+  AddRectFilledMultiColorRound(a: Readonly<Bind.interface_ImVec2>, b: Readonly<Bind.interface_ImVec2>, col_lt: ImU32, col_rt: ImU32, col_lb: ImU32, col_rb: ImU32, rounding: number, rounding_corners_flags: ImDrawCornerFlags): void {
+    this.native.AddRectFilledMultiColorRound(a, b, col_lt, col_rt, col_lb, col_rb, rounding, rounding_corners_flags);
+  }
+  GetVertexSize(): number { return this.native.GetVertexSize(); }
+  Transform(tm: Readonly<Bind.interface_ImTransform>, start: number, end?: number): void {
+    if (!end) end = 0;
+    this.native.Transform(tm, start, end);
+  }
 }
 
 // All draw data to render an ImGui frame
-export { ImDrawData as DrawData }
-export class ImDrawData
-{
-    constructor(public readonly native: Bind.reference_ImDrawData) {}
-
-    public IterateDrawLists(callback: (draw_list: ImDrawList) => void): void {
-        this.native.IterateDrawLists((draw_list: Bind.reference_ImDrawList): void => {
-            callback(new ImDrawList(draw_list));
-        });
-    }
+export { ImDrawData as DrawData };
+export class ImDrawData {
+  constructor(public readonly native: Bind.reference_ImDrawData) {}
 
-    // bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.
-    get Valid(): boolean { return this.native.Valid; }
-    // ImDrawList**    CmdLists;
-    // int             CmdListsCount;
-    get CmdListsCount(): number { return this.native.CmdListsCount; }
-    // int             TotalIdxCount;          // For convenience, sum of all cmd_lists idx_buffer.Size
-    get TotalIdxCount(): number { return this.native.TotalIdxCount; }
-    // int             TotalVtxCount;          // For convenience, sum of all cmd_lists vtx_buffer.Size
-    get TotalVtxCount(): number { return this.native.TotalVtxCount; }
-    // ImVec2          DisplayPos;             // Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)
-    get DisplayPos(): Readonly<Bind.reference_ImVec2> { return this.native.DisplayPos; }
-    // ImVec2          DisplaySize;            // Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)
-    get DisplaySize(): Readonly<Bind.reference_ImVec2> { return this.native.DisplaySize; }
-    // ImVec2          FramebufferScale;       // Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.
-    get FramebufferScale(): Readonly<Bind.reference_ImVec2> { return this.native.FramebufferScale; }
-
-    // Functions
-    // ImDrawData() { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; }
-    // IMGUI_API void DeIndexAllBuffers();               // For backward compatibility or convenience: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
-    public DeIndexAllBuffers(): void { this.native.DeIndexAllBuffers(); }
-    // IMGUI_API void ScaleClipRects(const ImVec2& fb_scale);  // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
-    public ScaleClipRects(fb_scale: Readonly<Bind.interface_ImVec2>): void {
-        this.native.ScaleClipRects(fb_scale);
-    }
-}
-
-export class script_ImFontConfig implements Bind.interface_ImFontConfig
-{
-    // void*           FontData;                   //          // TTF/OTF data
-    // int             FontDataSize;               //          // TTF/OTF data size
-    FontData: DataView | null = null;
-    // bool            FontDataOwnedByAtlas;       // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
-    FontDataOwnedByAtlas: boolean = true;
-    // int             FontNo;                     // 0        // Index of font within TTF/OTF file
-    FontNo: number = 0;
-    // float           SizePixels;                 //          // Size in pixels for rasterizer.
-    SizePixels: number = 0;
-    // int             OversampleH, OversampleV;   // 3, 1     // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
-    OversampleH: number = 3;
-    OversampleV: number = 1;
-    // bool            PixelSnapH;                 // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
-    PixelSnapH: boolean = false;
-    // ImVec2          GlyphExtraSpacing;          // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
-    GlyphExtraSpacing: ImVec2 = new ImVec2(0, 0);
-    // ImVec2          GlyphOffset;                // 0, 0     // Offset all glyphs from this font input.
-    GlyphOffset: ImVec2 = new ImVec2(0, 0);
-    // const ImWchar*  GlyphRanges;                // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
-    GlyphRanges: number | null = null;
-    // float           GlyphMinAdvanceX;           // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
-    GlyphMinAdvanceX: number = 0;
-    // float           GlyphMaxAdvanceX;           // FLT_MAX  // Maximum AdvanceX for glyphs
-    GlyphMaxAdvanceX: number = Number.MAX_VALUE;
-    // bool            MergeMode;                  // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
-    MergeMode: boolean = false;
-    // unsigned int    RasterizerFlags;            // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
-    RasterizerFlags: number = 0;
-    // float           RasterizerMultiply;         // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.
-    RasterizerMultiply: number = 1.0;
-    // ImWchar         EllipsisChar;           // -1       // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.
-    EllipsisChar: number = -1;
-
-    // [Internal]
-    // char            Name[32];                               // Name (strictly to ease debugging)
-    Name: string = "";
-    // ImFont*         DstFont;
-    DstFont: Bind.reference_ImFont | null = null;
-
-    // IMGUI_API ImFontConfig();
-}
-
-export { ImFontConfig as FontConfig }
+  public IterateDrawLists(callback: (draw_list: ImDrawList) => void): void {
+    this.native.IterateDrawLists((draw_list: Bind.reference_ImDrawList): void => {
+      callback(new ImDrawList(draw_list));
+    });
+  }
+
+  // bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.
+  get Valid(): boolean { return this.native.Valid; }
+  // ImDrawList**    CmdLists;
+  // int             CmdListsCount;
+  get CmdListsCount(): number { return this.native.CmdListsCount; }
+  // int             TotalIdxCount;          // For convenience, sum of all cmd_lists idx_buffer.Size
+  get TotalIdxCount(): number { return this.native.TotalIdxCount; }
+  // int             TotalVtxCount;          // For convenience, sum of all cmd_lists vtx_buffer.Size
+  get TotalVtxCount(): number { return this.native.TotalVtxCount; }
+  // ImVec2          DisplayPos;             // Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)
+  get DisplayPos(): Readonly<Bind.reference_ImVec2> { return this.native.DisplayPos; }
+  // ImVec2          DisplaySize;            // Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)
+  get DisplaySize(): Readonly<Bind.reference_ImVec2> { return this.native.DisplaySize; }
+  // ImVec2          FramebufferScale;       // Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.
+  get FramebufferScale(): Readonly<Bind.reference_ImVec2> { return this.native.FramebufferScale; }
+
+  // Functions
+  // ImDrawData() { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; }
+  // IMGUI_API void DeIndexAllBuffers();               // For backward compatibility or convenience: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
+  public DeIndexAllBuffers(): void { this.native.DeIndexAllBuffers(); }
+  // IMGUI_API void ScaleClipRects(const ImVec2& fb_scale);  // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
+  public ScaleClipRects(fb_scale: Readonly<Bind.interface_ImVec2>): void {
+    this.native.ScaleClipRects(fb_scale);
+  }
+}
+
+export class script_ImFontConfig implements Bind.interface_ImFontConfig {
+  // void*           FontData;                   //          // TTF/OTF data
+  // int             FontDataSize;               //          // TTF/OTF data size
+  FontData: DataView | null = null;
+  // bool            FontDataOwnedByAtlas;       // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
+  FontDataOwnedByAtlas: boolean = true;
+  // int             FontNo;                     // 0        // Index of font within TTF/OTF file
+  FontNo: number = 0;
+  // float           SizePixels;                 //          // Size in pixels for rasterizer.
+  SizePixels: number = 0;
+  // int             OversampleH, OversampleV;   // 3, 1     // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
+  OversampleH: number = 3;
+  OversampleV: number = 1;
+  // bool            PixelSnapH;                 // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
+  PixelSnapH: boolean = false;
+  // ImVec2          GlyphExtraSpacing;          // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
+  GlyphExtraSpacing: ImVec2 = new ImVec2(0, 0);
+  // ImVec2          GlyphOffset;                // 0, 0     // Offset all glyphs from this font input.
+  GlyphOffset: ImVec2 = new ImVec2(0, 0);
+  // const ImWchar*  GlyphRanges;                // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
+  GlyphRanges: number | null = null;
+  // float           GlyphMinAdvanceX;           // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
+  GlyphMinAdvanceX: number = 0;
+  // float           GlyphMaxAdvanceX;           // FLT_MAX  // Maximum AdvanceX for glyphs
+  GlyphMaxAdvanceX: number = Number.MAX_VALUE;
+  // bool            MergeMode;                  // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
+  MergeMode: boolean = false;
+  // unsigned int    RasterizerFlags;            // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
+  RasterizerFlags: number = 0;
+  // float           RasterizerMultiply;         // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.
+  RasterizerMultiply: number = 1.0;
+  // ImWchar         EllipsisChar;           // -1       // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.
+  EllipsisChar: number = -1;
+
+  // [Internal]
+  // char            Name[32];                               // Name (strictly to ease debugging)
+  Name: string = "";
+  // ImFont*         DstFont;
+  DstFont: Bind.reference_ImFont | null = null;
+
+  // IMGUI_API ImFontConfig();
+}
+
+export { ImFontConfig as FontConfig };
 export class ImFontConfig {
-    constructor(public readonly internal: Bind.interface_ImFontConfig = new script_ImFontConfig()) {}
-
-    // void*           FontData;                   //          // TTF/OTF data
-    // int             FontDataSize;               //          // TTF/OTF data size
-    get FontData(): DataView | null { return this.internal.FontData; }
-    // bool            FontDataOwnedByAtlas;       // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
-    get FontDataOwnedByAtlas(): boolean { return this.internal.FontDataOwnedByAtlas; }
-    // int             FontNo;                     // 0        // Index of font within TTF/OTF file
-    get FontNo(): number { return this.internal.FontNo; }
-    // float           SizePixels;                 //          // Size in pixels for rasterizer.
-    get SizePixels(): number { return this.internal.SizePixels; }
-    // int             OversampleH, OversampleV;   // 3, 1     // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
-    get OversampleH(): number { return this.internal.OversampleH; }
-    get OversampleV(): number { return this.internal.OversampleV; }
-    // bool            PixelSnapH;                 // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
-    get PixelSnapH(): boolean { return this.internal.PixelSnapH; }
-    // ImVec2          GlyphExtraSpacing;          // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
-    get GlyphExtraSpacing(): ImVec2 { return this.internal.GlyphExtraSpacing; }
-    // ImVec2          GlyphOffset;                // 0, 0     // Offset all glyphs from this font input.
-    get GlyphOffset(): ImVec2 { return this.internal.GlyphOffset; }
-    // const ImWchar*  GlyphRanges;                // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
-    get GlyphRanges(): number | null { return this.internal.GlyphRanges; }
-    // float           GlyphMinAdvanceX;           // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
-    get GlyphMinAdvanceX(): number { return this.internal.GlyphMinAdvanceX; }
-    // float           GlyphMaxAdvanceX;           // FLT_MAX  // Maximum AdvanceX for glyphs
-    get GlyphMaxAdvanceX(): number { return this.internal.GlyphMaxAdvanceX; }
-    // bool            MergeMode;                  // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
-    get MergeMode(): boolean { return this.internal.MergeMode; }
-    // unsigned int    RasterizerFlags;            // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
-    get RasterizerFlags(): number { return this.internal.RasterizerFlags; }
-    // float           RasterizerMultiply;         // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.
-    get RasterizerMultiply(): number { return this.internal.RasterizerMultiply; }
-
-    // [Internal]
-    // char            Name[32];                               // Name (strictly to ease debugging)
-    get Name(): string { return this.internal.Name; }
-    set Name(value: string) { this.internal.Name = value; }
-    // ImFont*         DstFont;
-    get DstFont(): ImFont | null {
-        const font = this.internal.DstFont;
-        return font && new ImFont(font);
-    }
-
-    // IMGUI_API ImFontConfig();
+  constructor(public readonly internal: Bind.interface_ImFontConfig = new script_ImFontConfig()) {}
+
+  // void*           FontData;                   //          // TTF/OTF data
+  // int             FontDataSize;               //          // TTF/OTF data size
+  get FontData(): DataView | null { return this.internal.FontData; }
+  // bool            FontDataOwnedByAtlas;       // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
+  get FontDataOwnedByAtlas(): boolean { return this.internal.FontDataOwnedByAtlas; }
+  // int             FontNo;                     // 0        // Index of font within TTF/OTF file
+  get FontNo(): number { return this.internal.FontNo; }
+  // float           SizePixels;                 //          // Size in pixels for rasterizer.
+  get SizePixels(): number { return this.internal.SizePixels; }
+  // int             OversampleH, OversampleV;   // 3, 1     // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
+  get OversampleH(): number { return this.internal.OversampleH; }
+  get OversampleV(): number { return this.internal.OversampleV; }
+  // bool            PixelSnapH;                 // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
+  get PixelSnapH(): boolean { return this.internal.PixelSnapH; }
+  // ImVec2          GlyphExtraSpacing;          // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
+  get GlyphExtraSpacing(): ImVec2 { return this.internal.GlyphExtraSpacing; }
+  // ImVec2          GlyphOffset;                // 0, 0     // Offset all glyphs from this font input.
+  get GlyphOffset(): ImVec2 { return this.internal.GlyphOffset; }
+  // const ImWchar*  GlyphRanges;                // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
+  get GlyphRanges(): number | null { return this.internal.GlyphRanges; }
+  // float           GlyphMinAdvanceX;           // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
+  get GlyphMinAdvanceX(): number { return this.internal.GlyphMinAdvanceX; }
+  // float           GlyphMaxAdvanceX;           // FLT_MAX  // Maximum AdvanceX for glyphs
+  get GlyphMaxAdvanceX(): number { return this.internal.GlyphMaxAdvanceX; }
+  // bool            MergeMode;                  // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
+  get MergeMode(): boolean { return this.internal.MergeMode; }
+  // unsigned int    RasterizerFlags;            // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
+  get RasterizerFlags(): number { return this.internal.RasterizerFlags; }
+  // float           RasterizerMultiply;         // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.
+  get RasterizerMultiply(): number { return this.internal.RasterizerMultiply; }
+
+  // [Internal]
+  // char            Name[32];                               // Name (strictly to ease debugging)
+  get Name(): string { return this.internal.Name; }
+  set Name(value: string) { this.internal.Name = value; }
+  // ImFont*         DstFont;
+  get DstFont(): ImFont | null {
+    const font = this.internal.DstFont;
+    return font && new ImFont(font);
+  }
+
+  // IMGUI_API ImFontConfig();
 }
 
 // struct ImFontGlyph
-export class script_ImFontGlyph implements Bind.interface_ImFontGlyph
-{
-    // unsigned int    Codepoint : 31;     // 0x0000..0xFFFF
-    Codepoint: number = 0;
-    // unsigned int    Visible : 1;        // Flag to allow early out when rendering
-    Visible: boolean = false;
-    // float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
-    AdvanceX: number = 0.0;
-    // float           X0, Y0, X1, Y1;     // Glyph corners
-    X0: number = 0.0;
-    Y0: number = 0.0;
-    X1: number = 1.0;
-    Y1: number = 1.0;
-    // float           U0, V0, U1, V1;     // Texture coordinates
-    U0: number = 0.0;
-    V0: number = 0.0;
-    U1: number = 1.0;
-    V1: number = 1.0;
-
-    TexID:number=null;
-
-    Char:number=0;
-}
-
-export { ImFontGlyph as FontGlyph }
+export class script_ImFontGlyph implements Bind.interface_ImFontGlyph {
+  // unsigned int    Codepoint : 31;     // 0x0000..0xFFFF
+  Codepoint: number = 0;
+  // unsigned int    Visible : 1;        // Flag to allow early out when rendering
+  Visible: boolean = false;
+  // float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
+  AdvanceX: number = 0.0;
+  // float           X0, Y0, X1, Y1;     // Glyph corners
+  X0: number = 0.0;
+  Y0: number = 0.0;
+  X1: number = 1.0;
+  Y1: number = 1.0;
+  // float           U0, V0, U1, V1;     // Texture coordinates
+  U0: number = 0.0;
+  V0: number = 0.0;
+  U1: number = 1.0;
+  V1: number = 1.0;
+
+  TexID: number = null;
+
+  Char: number = 0;
+}
+
+export { ImFontGlyph as FontGlyph };
 export class ImFontGlyph implements Bind.interface_ImFontGlyph {
-    constructor(public readonly internal: Bind.interface_ImFontGlyph = new script_ImFontGlyph()) {}
-    // unsigned int    Codepoint : 31;     // 0x0000..0xFFFF
-    get Codepoint(): number {  return this.internal.Codepoint; }
-    // unsigned int    Visible : 1;        // Flag to allow early out when rendering
-    get Visible(): boolean {  return this.internal.Visible; }
-    // float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
-    get AdvanceX(): number { return this.internal.AdvanceX; };
-    set AdvanceX(v:number) {this.internal.AdvanceX=v;}
-    // float           X0, Y0, X1, Y1;     // Glyph corners
-    get X0(): number { return this.internal.X0; };
-    set X0(v:number) {this.internal.X0=v;}
-    get Y0(): number { return this.internal.Y0; };
-    set Y0(v:number) {this.internal.Y0=v;}
-    get X1(): number { return this.internal.X1; };
-    set X1(v:number) {this.internal.X1=v;}
-    get Y1(): number { return this.internal.Y1; };
-    set Y1(v:number) {this.internal.Y1=v;}
-    // float           U0, V0, U1, V1;     // Texture coordinates
-    get U0(): number { return this.internal.U0; };
-    set U0(v:number) {this.internal.U0=v;}
-    get V0(): number { return this.internal.V0; };
-    set V0(v:number) {this.internal.V0=v;}
-    get U1(): number { return this.internal.U1; };
-    set U1(v:number) {this.internal.U1=v;}
-    get V1(): number { return this.internal.V1; };
-    set V1(v:number) {this.internal.V1=v;}
-
-    get TexID():number {return this.internal.TexID;}
-    
-    get TextureID(): ImTextureID|null { return ImGuiContext.getTexture(this.internal.TexID); };
-    set TextureID(v:ImTextureID|null) {this.internal.TexID=ImGuiContext.setTexture(v);}
-    get Char(): number { return this.internal.Char; };
+  constructor(public readonly internal: Bind.interface_ImFontGlyph = new script_ImFontGlyph()) {}
+  // unsigned int    Codepoint : 31;     // 0x0000..0xFFFF
+  get Codepoint(): number { return this.internal.Codepoint; }
+  // unsigned int    Visible : 1;        // Flag to allow early out when rendering
+  get Visible(): boolean { return this.internal.Visible; }
+  // float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
+  get AdvanceX(): number { return this.internal.AdvanceX; };
+  set AdvanceX(v: number) { this.internal.AdvanceX = v; }
+  // float           X0, Y0, X1, Y1;     // Glyph corners
+  get X0(): number { return this.internal.X0; };
+  set X0(v: number) { this.internal.X0 = v; }
+  get Y0(): number { return this.internal.Y0; };
+  set Y0(v: number) { this.internal.Y0 = v; }
+  get X1(): number { return this.internal.X1; };
+  set X1(v: number) { this.internal.X1 = v; }
+  get Y1(): number { return this.internal.Y1; };
+  set Y1(v: number) { this.internal.Y1 = v; }
+  // float           U0, V0, U1, V1;     // Texture coordinates
+  get U0(): number { return this.internal.U0; };
+  set U0(v: number) { this.internal.U0 = v; }
+  get V0(): number { return this.internal.V0; };
+  set V0(v: number) { this.internal.V0 = v; }
+  get U1(): number { return this.internal.U1; };
+  set U1(v: number) { this.internal.U1 = v; }
+  get V1(): number { return this.internal.V1; };
+  set V1(v: number) { this.internal.V1 = v; }
+
+  get TexID(): number { return this.internal.TexID; }
+
+  get TextureID(): ImTextureID | null { return ImGuiContext.getTexture(this.internal.TexID); };
+  set TextureID(v: ImTextureID | null) { this.internal.TexID = ImGuiContext.setTexture(v); }
+  get Char(): number { return this.internal.Char; };
 }
 
 // See ImFontAtlas::AddCustomRectXXX functions.
-export class ImFontAtlasCustomRect
-{
-    // unsigned short  Width, Height;  // Input    // Desired rectangle dimension
-    // unsigned short  X, Y;           // Output   // Packed position in Atlas
-    // unsigned int    GlyphID;        // Input    // For custom font glyphs only (ID < 0x110000)
-    // float           GlyphAdvanceX;  // Input    // For custom font glyphs only: glyph xadvance
-    // ImVec2          GlyphOffset;    // Input    // For custom font glyphs only: glyph display offset
-    // ImFont*         Font;           // Input    // For custom font glyphs only: target font
-    // ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }
-    // bool IsPacked() const           { return X != 0xFFFF; }
-}
-
-export { ImFontAtlasFlags as FontAtlasFlags }
-export enum ImFontAtlasFlags
-{
-    None               = 0,
-    NoPowerOfTwoHeight = 1 << 0,   // Don't round the height to next power of two
-    NoMouseCursors     = 1 << 1,   // Don't build software mouse cursors into the atlas
-    NoBakedLines       = 1 << 2,   // Don't build thick line textures into the atlas (save a little texture memory). The AntiAliasedLinesUseTex features uses them, otherwise they will be rendered using polygons (more expensive for CPU/GPU).
+export class ImFontAtlasCustomRect {
+  // unsigned short  Width, Height;  // Input    // Desired rectangle dimension
+  // unsigned short  X, Y;           // Output   // Packed position in Atlas
+  // unsigned int    GlyphID;        // Input    // For custom font glyphs only (ID < 0x110000)
+  // float           GlyphAdvanceX;  // Input    // For custom font glyphs only: glyph xadvance
+  // ImVec2          GlyphOffset;    // Input    // For custom font glyphs only: glyph display offset
+  // ImFont*         Font;           // Input    // For custom font glyphs only: target font
+  // ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }
+  // bool IsPacked() const           { return X != 0xFFFF; }
+}
+
+export { ImFontAtlasFlags as FontAtlasFlags };
+export enum ImFontAtlasFlags {
+  None = 0,
+  NoPowerOfTwoHeight = 1 << 0,   // Don't round the height to next power of two
+  NoMouseCursors = 1 << 1,   // Don't build software mouse cursors into the atlas
+  NoBakedLines = 1 << 2,   // Don't build thick line textures into the atlas (save a little texture memory). The AntiAliasedLinesUseTex features uses them, otherwise they will be rendered using polygons (more expensive for CPU/GPU).
 }
 
 // Load and rasterize multiple TTF/OTF fonts into a same texture.
@@ -2191,834 +2151,829 @@ export enum ImFontAtlasFlags
 //  3. Upload the pixels data into a texture within your graphics system.
 //  4. Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture. This value will be passed back to you during rendering to identify the texture.
 // IMPORTANT: If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the ImFont is build (when calling GetTextData*** or Build()). We only copy the pointer, not the data.
-export { ImFontAtlas as FontAtlas }
-export class ImFontAtlas
-{
-    constructor(public readonly native: Bind.reference_ImFontAtlas) {}
-
-    // IMGUI_API ImFontAtlas();
-    // IMGUI_API ~ImFontAtlas();
-    // IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);
-    // IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);
-    public AddFontDefault(font_cfg: Bind.interface_ImFontConfig | null = null): ImFont {
-        return new ImFont(this.native.AddFontDefault(font_cfg));
-    }
-    // IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);
-    // IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after Build(). Set font_cfg->FontDataOwnedByAtlas to false to keep ownership.
-    public AddFontFromMemoryTTF(data: ArrayBuffer, size_pixels: number, font_cfg: ImFontConfig | null = null, glyph_ranges: number | null = null): ImFont {
-        return new ImFont(this.native.AddFontFromMemoryTTF(new Uint8Array(data), size_pixels, font_cfg && font_cfg.internal, glyph_ranges));
-    }
-    // IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
-    // IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
-    // IMGUI_API void              ClearTexData();             // Clear the CPU-side texture data. Saves RAM once the texture has been copied to graphics memory.
-    public ClearTexData(): void { this.native.ClearTexData(); }
-    // IMGUI_API void              ClearInputData();           // Clear the input TTF data (inc sizes, glyph ranges)
-    public ClearInputData(): void { this.native.ClearInputData(); }
-    // IMGUI_API void              ClearFonts();               // Clear the ImGui-side font data (glyphs storage, UV coordinates)
-    public ClearFonts(): void { this.native.ClearFonts(); }
-    // IMGUI_API void              Clear();                    // Clear all
-    public Clear(): void { this.native.Clear(); }
-
-    // Build atlas, retrieve pixel data.
-    // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().
-    // RGBA32 format is provided for convenience and compatibility, but note that unless you use CustomRect to draw color data, the RGB pixels emitted from Fonts will all be white (~75% of waste).
-    // Pitch = Width * BytesPerPixels
-    // IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.
-    public Build(): boolean { return this.native.Build(); }
-    // IMGUI_API bool              IsBuilt()                   { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }
-    public IsBuilt(): boolean { return this.native.IsBuilt(); }
-    // IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel
-    public GetTexDataAsAlpha8(): { pixels: Uint8ClampedArray, width: number, height: number, bytes_per_pixel: number } {
-        return this.native.GetTexDataAsAlpha8();
-    }
-    // IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel
-    public GetTexDataAsRGBA32(): { pixels: Uint8ClampedArray, width: number, height: number, bytes_per_pixel: number } {
-        return this.native.GetTexDataAsRGBA32();
-    }
-    // void                        SetTexID(ImTextureID id)    { TexID = id; }
-    public SetTexID(id: ImTextureID | null): void { this.TexID = id; }
-
-    //-------------------------------------------
-    // Glyph Ranges
-    //-------------------------------------------
-
-    // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)
-    // NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8"Hello world" syntax. See FAQ for details.
-    // IMGUI_API const ImWchar*    GetGlyphRangesDefault();    // Basic Latin, Extended Latin
-    GetGlyphRangesDefault(): number { return this.native.GetGlyphRangesDefault(); }
-    // IMGUI_API const ImWchar*    GetGlyphRangesKorean();     // Default + Korean characters
-    GetGlyphRangesKorean(): number { return this.native.GetGlyphRangesKorean(); }
-    // IMGUI_API const ImWchar*    GetGlyphRangesJapanese();   // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs
-    GetGlyphRangesJapanese(): number { return this.native.GetGlyphRangesJapanese(); }
-    // IMGUI_API const ImWchar*    GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs
-    GetGlyphRangesChineseFull(): number { return this.native.GetGlyphRangesChineseFull(); }
-    // IMGUI_API const ImWchar*    GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese
-    GetGlyphRangesChineseSimplifiedCommon(): number { return this.native.GetGlyphRangesChineseSimplifiedCommon(); }
-    // IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();   // Default + about 400 Cyrillic characters
-    GetGlyphRangesCyrillic(): number { return this.native.GetGlyphRangesCyrillic(); }
-    // IMGUI_API const ImWchar*    GetGlyphRangesThai();       // Default + Thai characters
-    GetGlyphRangesThai(): number { return this.native.GetGlyphRangesThai(); }
-    // IMGUI_API const ImWchar*    GetGlyphRangesVietnamese();       // Default + Vietnamese characters
-    GetGlyphRangesVietnamese(): number { return this.native.GetGlyphRangesVietnamese(); }
-
-    // Helpers to build glyph ranges from text data. Feed your application strings/characters to it then call BuildRanges().
-    // struct GlyphRangesBuilder
-    // {
-    //     ImVector<unsigned char> UsedChars;  // Store 1-bit per Unicode code point (0=unused, 1=used)
-    //     GlyphRangesBuilder()                { UsedChars.resize(0x10000 / 8); memset(UsedChars.Data, 0, 0x10000 / 8); }
-    //     bool           GetBit(int n) const  { return (UsedChars[n >> 3] & (1 << (n & 7))) != 0; }
-    //     void           SetBit(int n)        { UsedChars[n >> 3] |= 1 << (n & 7); }  // Set bit 'c' in the array
-    //     void           AddChar(ImWchar c)   { SetBit(c); }                          // Add character
-    //     IMGUI_API void AddText(const char* text, const char* text_end = NULL);      // Add string (each character of the UTF-8 string are added)
-    //     IMGUI_API void AddRanges(const ImWchar* ranges);                            // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault) to force add all of ASCII/Latin+Ext
-    //     IMGUI_API void BuildRanges(ImVector<ImWchar>* out_ranges);                  // Output new ranges
-    // };
-
-    //-------------------------------------------
-    // Custom Rectangles/Glyphs API
-    //-------------------------------------------
-
-    // You can request arbitrary rectangles to be packed into the atlas, for your own purposes. After calling Build(), you can query the rectangle position and render your pixels.
-    // You can also request your rectangles to be mapped as font glyph (given a font + Unicode point), so you can render e.g. custom colorful icons and use them as regular glyphs.
-    // struct CustomRect
-    // {
-    //     unsigned int    ID;             // Input    // User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other/internal/custom texture data.
-    //     unsigned short  Width, Height;  // Input    // Desired rectangle dimension
-    //     unsigned short  X, Y;           // Output   // Packed position in Atlas
-    //     float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID<0x10000): glyph xadvance
-    //     ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID<0x10000): glyph display offset
-    //     ImFont*         Font;           // Input    // For custom font glyphs only (ID<0x10000): target font
-    //     CustomRect()            { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }
-    //     bool IsPacked() const   { return X != 0xFFFF; }
-    // };
-
-    // IMGUI_API int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x10000. Id >= 0x80000000 are reserved for ImGui and ImDrawList
-    // IMGUI_API int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   // Id needs to be < 0x10000 to register a rectangle to map into a specific font.
-    // IMGUI_API void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);
-    // const CustomRect*   GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }
-
-    //-------------------------------------------
-    // Members
-    //-------------------------------------------
-
-    // bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
-    get Locked(): boolean { return this.native.Locked; }
-    set Locked(value: boolean) { this.native.Locked = value; }
-    // ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)
-    get Flags(): ImFontAtlasFlags { return this.native.Flags; }
-    set Flags(value: ImFontAtlasFlags) { this.native.Flags = value; }
-    // ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.
-    get TexID(): ImTextureID | null {
-        return ImGuiContext.getTexture(this.native.TexID);
-    }
-    set TexID(value: ImTextureID | null) {
-        this.native.TexID = ImGuiContext.setTexture(value);
-    }
-    // int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
-    get TexDesiredWidth(): number { return this.native.TexDesiredWidth; }
-    set TexDesiredWidth(value: number) { this.native.TexDesiredWidth = value; }
-    // int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1.
-    get TexGlyphPadding(): number { return this.native.TexGlyphPadding; }
-    set TexGlyphPadding(value: number) { this.native.TexGlyphPadding = value; }
-
-    // [Internal]
-    // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
-    // unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
-    // unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
-    // int                         TexWidth;           // Texture width calculated during Build().
-    get TexWidth(): number { return this.native.TexWidth; }
-    // int                         TexHeight;          // Texture height calculated during Build().
-    get TexHeight(): number { return this.native.TexHeight; }
-    // ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)
-    get TexUvScale(): Readonly<Bind.reference_ImVec2> { return this.native.TexUvScale; }
-    // ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel
-    get TexUvWhitePixel(): Readonly<Bind.reference_ImVec2> { return this.native.TexUvWhitePixel; }
-    // ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
-    get Fonts_(): ImVector<ImFont> {        
-        const fonts: ImVector<ImFont> = new ImVector<ImFont>();
-        this.native.IterateFonts((font: Bind.reference_ImFont) => {
-            fonts.push(new ImFont(font));
-        });
-        return fonts;
-    }
-    get Fonts(): ImVector<ImFont> {
-        if(this._Fonts==null)   {
-            this._Fonts=this.Fonts_;
-        }
-        return this._Fonts;
+export { ImFontAtlas as FontAtlas };
+export class ImFontAtlas {
+  constructor(public readonly native: Bind.reference_ImFontAtlas) {}
+
+  // IMGUI_API ImFontAtlas();
+  // IMGUI_API ~ImFontAtlas();
+  // IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);
+  // IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);
+  public AddFontDefault(font_cfg: Bind.interface_ImFontConfig | null = null): ImFont {
+    return new ImFont(this.native.AddFontDefault(font_cfg));
+  }
+  // IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);
+  // IMGUI_API ImFont*           AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after Build(). Set font_cfg->FontDataOwnedByAtlas to false to keep ownership.
+  public AddFontFromMemoryTTF(data: ArrayBuffer, size_pixels: number, font_cfg: ImFontConfig | null = null, glyph_ranges: number | null = null): ImFont {
+    return new ImFont(this.native.AddFontFromMemoryTTF(new Uint8Array(data), size_pixels, font_cfg && font_cfg.internal, glyph_ranges));
+  }
+  // IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
+  // IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
+  // IMGUI_API void              ClearTexData();             // Clear the CPU-side texture data. Saves RAM once the texture has been copied to graphics memory.
+  public ClearTexData(): void { this.native.ClearTexData(); }
+  // IMGUI_API void              ClearInputData();           // Clear the input TTF data (inc sizes, glyph ranges)
+  public ClearInputData(): void { this.native.ClearInputData(); }
+  // IMGUI_API void              ClearFonts();               // Clear the ImGui-side font data (glyphs storage, UV coordinates)
+  public ClearFonts(): void { this.native.ClearFonts(); }
+  // IMGUI_API void              Clear();                    // Clear all
+  public Clear(): void { this.native.Clear(); }
+
+  // Build atlas, retrieve pixel data.
+  // User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().
+  // RGBA32 format is provided for convenience and compatibility, but note that unless you use CustomRect to draw color data, the RGB pixels emitted from Fonts will all be white (~75% of waste).
+  // Pitch = Width * BytesPerPixels
+  // IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.
+  public Build(): boolean { return this.native.Build(); }
+  // IMGUI_API bool              IsBuilt()                   { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }
+  public IsBuilt(): boolean { return this.native.IsBuilt(); }
+  // IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel
+  public GetTexDataAsAlpha8(): { pixels: Uint8ClampedArray, width: number, height: number, bytes_per_pixel: number } {
+    return this.native.GetTexDataAsAlpha8();
+  }
+  // IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel
+  public GetTexDataAsRGBA32(): { pixels: Uint8ClampedArray, width: number, height: number, bytes_per_pixel: number } {
+    return this.native.GetTexDataAsRGBA32();
+  }
+  // void                        SetTexID(ImTextureID id)    { TexID = id; }
+  public SetTexID(id: ImTextureID | null): void { this.TexID = id; }
+
+  //-------------------------------------------
+  // Glyph Ranges
+  //-------------------------------------------
+
+  // Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)
+  // NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8"Hello world" syntax. See FAQ for details.
+  // IMGUI_API const ImWchar*    GetGlyphRangesDefault();    // Basic Latin, Extended Latin
+  GetGlyphRangesDefault(): number { return this.native.GetGlyphRangesDefault(); }
+  // IMGUI_API const ImWchar*    GetGlyphRangesKorean();     // Default + Korean characters
+  GetGlyphRangesKorean(): number { return this.native.GetGlyphRangesKorean(); }
+  // IMGUI_API const ImWchar*    GetGlyphRangesJapanese();   // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs
+  GetGlyphRangesJapanese(): number { return this.native.GetGlyphRangesJapanese(); }
+  // IMGUI_API const ImWchar*    GetGlyphRangesChineseFull();            // Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs
+  GetGlyphRangesChineseFull(): number { return this.native.GetGlyphRangesChineseFull(); }
+  // IMGUI_API const ImWchar*    GetGlyphRangesChineseSimplifiedCommon();// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese
+  GetGlyphRangesChineseSimplifiedCommon(): number { return this.native.GetGlyphRangesChineseSimplifiedCommon(); }
+  // IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();   // Default + about 400 Cyrillic characters
+  GetGlyphRangesCyrillic(): number { return this.native.GetGlyphRangesCyrillic(); }
+  // IMGUI_API const ImWchar*    GetGlyphRangesThai();       // Default + Thai characters
+  GetGlyphRangesThai(): number { return this.native.GetGlyphRangesThai(); }
+  // IMGUI_API const ImWchar*    GetGlyphRangesVietnamese();       // Default + Vietnamese characters
+  GetGlyphRangesVietnamese(): number { return this.native.GetGlyphRangesVietnamese(); }
+
+  // Helpers to build glyph ranges from text data. Feed your application strings/characters to it then call BuildRanges().
+  // struct GlyphRangesBuilder
+  // {
+  //     ImVector<unsigned char> UsedChars;  // Store 1-bit per Unicode code point (0=unused, 1=used)
+  //     GlyphRangesBuilder()                { UsedChars.resize(0x10000 / 8); memset(UsedChars.Data, 0, 0x10000 / 8); }
+  //     bool           GetBit(int n) const  { return (UsedChars[n >> 3] & (1 << (n & 7))) != 0; }
+  //     void           SetBit(int n)        { UsedChars[n >> 3] |= 1 << (n & 7); }  // Set bit 'c' in the array
+  //     void           AddChar(ImWchar c)   { SetBit(c); }                          // Add character
+  //     IMGUI_API void AddText(const char* text, const char* text_end = NULL);      // Add string (each character of the UTF-8 string are added)
+  //     IMGUI_API void AddRanges(const ImWchar* ranges);                            // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault) to force add all of ASCII/Latin+Ext
+  //     IMGUI_API void BuildRanges(ImVector<ImWchar>* out_ranges);                  // Output new ranges
+  // };
+
+  //-------------------------------------------
+  // Custom Rectangles/Glyphs API
+  //-------------------------------------------
+
+  // You can request arbitrary rectangles to be packed into the atlas, for your own purposes. After calling Build(), you can query the rectangle position and render your pixels.
+  // You can also request your rectangles to be mapped as font glyph (given a font + Unicode point), so you can render e.g. custom colorful icons and use them as regular glyphs.
+  // struct CustomRect
+  // {
+  //     unsigned int    ID;             // Input    // User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other/internal/custom texture data.
+  //     unsigned short  Width, Height;  // Input    // Desired rectangle dimension
+  //     unsigned short  X, Y;           // Output   // Packed position in Atlas
+  //     float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID<0x10000): glyph xadvance
+  //     ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID<0x10000): glyph display offset
+  //     ImFont*         Font;           // Input    // For custom font glyphs only (ID<0x10000): target font
+  //     CustomRect()            { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }
+  //     bool IsPacked() const   { return X != 0xFFFF; }
+  // };
+
+  // IMGUI_API int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x10000. Id >= 0x80000000 are reserved for ImGui and ImDrawList
+  // IMGUI_API int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0,0));   // Id needs to be < 0x10000 to register a rectangle to map into a specific font.
+  // IMGUI_API void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);
+  // const CustomRect*   GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }
+
+  //-------------------------------------------
+  // Members
+  //-------------------------------------------
+
+  // bool                        Locked;             // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
+  get Locked(): boolean { return this.native.Locked; }
+  set Locked(value: boolean) { this.native.Locked = value; }
+  // ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)
+  get Flags(): ImFontAtlasFlags { return this.native.Flags; }
+  set Flags(value: ImFontAtlasFlags) { this.native.Flags = value; }
+  // ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.
+  get TexID(): ImTextureID | null {
+    return ImGuiContext.getTexture(this.native.TexID);
+  }
+  set TexID(value: ImTextureID | null) {
+    this.native.TexID = ImGuiContext.setTexture(value);
+  }
+  // int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
+  get TexDesiredWidth(): number { return this.native.TexDesiredWidth; }
+  set TexDesiredWidth(value: number) { this.native.TexDesiredWidth = value; }
+  // int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1.
+  get TexGlyphPadding(): number { return this.native.TexGlyphPadding; }
+  set TexGlyphPadding(value: number) { this.native.TexGlyphPadding = value; }
+
+  // [Internal]
+  // NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
+  // unsigned char*              TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
+  // unsigned int*               TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
+  // int                         TexWidth;           // Texture width calculated during Build().
+  get TexWidth(): number { return this.native.TexWidth; }
+  // int                         TexHeight;          // Texture height calculated during Build().
+  get TexHeight(): number { return this.native.TexHeight; }
+  // ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)
+  get TexUvScale(): Readonly<Bind.reference_ImVec2> { return this.native.TexUvScale; }
+  // ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel
+  get TexUvWhitePixel(): Readonly<Bind.reference_ImVec2> { return this.native.TexUvWhitePixel; }
+  // ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
+  get Fonts_(): ImVector<ImFont> {
+    const fonts: ImVector<ImFont> = new ImVector<ImFont>();
+    this.native.IterateFonts((font: Bind.reference_ImFont) => {
+      fonts.push(new ImFont(font));
+    });
+    return fonts;
+  }
+  get Fonts(): ImVector<ImFont> {
+    if (this._Fonts == null) {
+      this._Fonts = this.Fonts_;
     }
-    _Fonts:ImVector<ImFont>=null;
+    return this._Fonts;
+  }
+  _Fonts: ImVector<ImFont> = null;
 
-    // ImVector<CustomRect>        CustomRects;        // Rectangles for packing custom texture data into the atlas.
-    // ImVector<ImFontConfig>      ConfigData;         // Internal data
-    // int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList
-    get CurrentFont():ImFont {
-        return new ImFont(this.native.CurrentFont);
-    }
+  // ImVector<CustomRect>        CustomRects;        // Rectangles for packing custom texture data into the atlas.
+  // ImVector<ImFontConfig>      ConfigData;         // Internal data
+  // int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList
+  get CurrentFont(): ImFont {
+    return new ImFont(this.native.CurrentFont);
+  }
 }
 
 // Font runtime data and rendering
 // ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
 
-export interface DOMFontConfig
-{
-    name:string;
-    fontsize:number;
-    ascent?:number;
-    descent?:number;
-}
-
-export { ImFont as Font }
-export class ImFont
-{
-    constructor(public readonly native: Bind.reference_ImFont) {}
-
-    public setFont(config:DOMFontConfig):void {
-        this.native.FontName=config.name;
-        this.native.FontSize=config.fontsize;
-        this.native.Ascent=config.ascent?config.ascent:0;
-        this.native.Descent=config.descent?config.descent:0;
-    }
-
-    // Members: Hot ~62/78 bytes
-    // float                       FontSize;           // <user set>   // Height of characters, set during loading (don't change after loading)
-    get FontStyle(): string { return this.native.FontStyle; }
-    set FontStyle(v:string) {this.native.FontStyle=v;}
-
-    get FontName(): string { return this.native.FontName; }
-    set FontName(v:string) {this.native.FontName=v;}
-
-    get FontSize(): number { return this.native.FontSize; }
-    set FontSize(v:number) {this.native.FontSize=v;}
-
-    get SpaceX():number[] {return [this.native.SpaceX0, this.native.SpaceX1];}
-    set SpaceX(v:number[]) {this.native.SpaceX0=v[0]; this.native.SpaceX1=v[1];}
-
-    // float                       Scale;              // = 1.f        // Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()
-    get Scale(): number { return this.native.Scale; }
-    set Scale(value: number) { this.native.Scale = value; }
-    // ImVector<ImFontGlyph>       Glyphs;             //              // All glyphs.
-    get Glyphs(): ImVector<ImFontGlyph> {
-        const glyphs = new ImVector<ImFontGlyph>();
-        this.native.IterateGlyphs((glyph: Bind.reference_ImFontGlyph): void => {
-            glyphs.push(new ImFontGlyph(glyph)); // TODO: wrap native
-        });
-        return glyphs;
-    }
-    // ImVector<float>             IndexAdvanceX;      //              // Sparse. Glyphs->AdvanceX in a directly indexable way (more cache-friendly, for CalcTextSize functions which are often bottleneck in large UI).
-    get IndexAdvanceX(): number[] { 
-        let a=[...Array(this.native.IndexAdvanceXSize)];
-        for(let i=0;i<this.native.IndexAdvanceXSize;i++) {
-            a[i]=this.GetAdvanceX(i);
-        }
-        return a;
-        //return new Float32Array(this.native.IndexAdvanceX.buffer,0,this.native.IndexAdvanceX.length/Float32Array.BYTES_PER_ELEMENT); 
-    }
-    //get IndexAdvanceX():Uint8Array {return this.native.IndexAdvanceX;}
-    get IndexAdvanceXSize():number {return this.native.IndexAdvanceXSize;}
-
-    get NotReadyChar():number[] {
-        let a=[...Array(this.native.NotReadyCharSize)];
-        for(let i=0;i<this.native.NotReadyCharSize;i++) {
-            a[i]=this.GetNotReadyChar(i);
-        }
-        return a;
-    }
-    get NotReadyCharSize():number {return this.native.NotReadyCharSize;}
-    // ImVector<unsigned short>    IndexLookup;        //              // Sparse. Index glyphs by Unicode code-point.
-    // get IndexLookup(): any { return this.native.IndexLookup; }
-    // const ImFontGlyph*          FallbackGlyph;      // == FindGlyph(FontFallbackChar)
-    get FallbackGlyph(): ImFontGlyph | null {
-        const glyph = this.native.FallbackGlyph;
-        return glyph && new ImFontGlyph(glyph);
-    }
-    set FallbackGlyph(value: ImFontGlyph | null) {
-        this.native.FallbackGlyph = value && value.internal as Bind.reference_ImFontGlyph;
-    }
-    // float                       FallbackAdvanceX;   // == FallbackGlyph->AdvanceX
-    get FallbackAdvanceX(): number { return this.native.FallbackAdvanceX; }
-    // ImWchar                     FallbackChar;       // = '?'        // Replacement glyph if one isn't found. Only set via SetFallbackChar()
-    get FallbackChar(): number { return this.native.FallbackChar; }
-    // ImWchar                     EllipsisChar;       // 2     // out // = -1       // Character used for ellipsis rendering.
-    get EllipsisChar(): number { return this.native.EllipsisChar; }
-
-    // Members: Cold ~18/26 bytes
-    // short                       ConfigDataCount;    // ~ 1          // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
-    get ConfigDataCount(): number { return this.native.ConfigDataCount; }
-    // ImFontConfig*               ConfigData;         //              // Pointer within ContainerAtlas->ConfigData
-    get ConfigData(): ImFontConfig {
-        return new ImFontConfig(this.native.ConfigData);
-    }
-    // ImFontAtlas*                ContainerAtlas;     //              // What we has been loaded into
-    get ContainerAtlas(): ImFontAtlas | null { return null; }
-    // float                       Ascent, Descent;    //              // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
-    get Ascent(): number { return this.native.Ascent; }
-    set Ascent(v:number) {this.native.Ascent=v;}
-    get Descent(): number { return this.native.Descent; }
-    set Descent(v:number) {this.native.Descent=v;}
-    // int                         MetricsTotalSurface;//              // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
-    get MetricsTotalSurface(): number { return this.native.MetricsTotalSurface; }
-
-    // Methods
-    // IMGUI_API ImFont();
-    // IMGUI_API ~ImFont();
-    // IMGUI_API void              ClearOutputData();
-    public ClearOutputData(): void { return this.native.ClearOutputData(); }
-    // IMGUI_API void              BuildLookupTable();
-    public BuildLookupTable(): void { return this.native.BuildLookupTable(); }
-    // IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;
-    public FindGlyph(c: number): Readonly<ImFontGlyph> | null {
-        const glyph: Readonly<Bind.reference_ImFontGlyph> | null = this.native.FindGlyph(c);
-        return glyph && new ImFontGlyph(glyph);
-    }
-    // IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;
-    public FindGlyphNoFallback(c: number): ImFontGlyph | null {
-        const glyph: Readonly<Bind.reference_ImFontGlyph> | null = this.native.FindGlyphNoFallback(c);
-        return glyph && new ImFontGlyph(glyph);
-    }
-    // IMGUI_API void              SetFallbackChar(ImWchar c);
-    public SetFallbackChar(c: number): void { return this.native.SetFallbackChar(c); }
-    // float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
-    public GetCharAdvance(c: number): number { return this.native.GetCharAdvance(c); }
-    // bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }
-    public IsLoaded(): boolean { return this.native.IsLoaded(); }
-    // const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : "<unknown>"; }
-    public GetDebugName(): string { return this.native.GetDebugName(); }
-
-    // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.
-    // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.
-    // IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8
-    public CalcTextSizeA(size: number, max_width: number, wrap_width: number, text_begin: string, text_end: number | null = null, remaining: Bind.ImScalar<number> | null = null, isready:Bind.ImScalar<boolean>|null=null): Bind.interface_ImVec2 {
-        return this.native.CalcTextSizeA(size, max_width, wrap_width, text_end !== null ? text_begin.substring(0, text_end) : text_begin, remaining, isready, new ImVec2());
-    }
-    // IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
-    public CalcWordWrapPositionA(scale: number, text: string, text_end: number | null = null, wrap_width: number): number {
-        return this.native.CalcWordWrapPositionA(scale, text_end !== null ? text.substring(0, text_end) : text, wrap_width);
-    }
-    // IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const;
-    public RenderChar(draw_list: ImDrawList, size: number, pos: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, c: Bind.ImWchar): void {
-        this.native.RenderChar(draw_list.native, size, pos, col, c);
-    }
-    // IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;
-    public RenderText(draw_list: ImDrawList, size: number, pos: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, clip_rect: Readonly<Bind.interface_ImVec4>, text_begin: string, text_end: number | null = null, wrap_width: number = 0.0, cpu_fine_clip: boolean = false): void {
-        this.native.RenderText(draw_list.native, size, pos, col, clip_rect, text_begin, wrap_width, cpu_fine_clip);
-    }
-
-    // [Internal]
-    // IMGUI_API void              GrowIndex(int new_size);
-    // IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);
-    // IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.
-
-    // #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
-    // typedef ImFontGlyph Glyph; // OBSOLETE 1.52+
-    // #endif
-
-    // IMGUI_API bool              IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last);
-    public IsGlyphRangeUnused(c_begin: number, c_last: number): boolean { return false; } // TODO
-
-    get GlyphToCreate():ImFontGlyph {
-        let glyph=this.native.GlyphToCreate();
-        return glyph?new ImFontGlyph(glyph):null;
-    }
-
-    get IterateGlyphToCreate():ImFontGlyph[] {
-        const glyphs: ImFontGlyph[] = [];
-        this.native.IterateGlyphToCreate((glyph: Bind.reference_ImFontGlyph): void => {
-            glyphs.push(new ImFontGlyph(glyph));
-        });
-        return glyphs;
-    } 
-    public GlyphCreated(glyph:ImFontGlyph) {
-        this.native.GlyphCreated(glyph.internal);
-    }
-    public ClearGlyphCreated() {
-        this.native.ClearGlyphCreated();
-    }
-
-    public CreateGlyph(text: string) {
-        this.native.CreateGlyph(text);
-    }
-    AddFontRange(start:number, end:number) {
-        this.native.AddFontRange(start, end);
-    }
-    ClearFontRange() {
-        this.native.ClearFontRange();
-    }
-    MergeFont(font:ImFont) {
-        this.native.MergeFont(font.native);
-    }
-    ClearSubFont() {
-        this.native.ClearSubFont();
-    }
-    InRange(c:number):boolean {
-        return this.native.InRange(c);
-    }
-    GetAdvanceX(c:number):number {
-        return this.native.GetAdvanceX(c);
-    }
-    GetNotReadyChar(i:number):number {
-        return this.native.GetNotReadyChar(i);
-    }
+export interface DOMFontConfig {
+  name: string;
+  fontsize: number;
+  ascent?: number;
+  descent?: number;
+}
+
+export { ImFont as Font };
+export class ImFont {
+  constructor(public readonly native: Bind.reference_ImFont) {}
+
+  public setFont(config: DOMFontConfig): void {
+    this.native.FontName = config.name;
+    this.native.FontSize = config.fontsize;
+    this.native.Ascent = config.ascent ? config.ascent : 0;
+    this.native.Descent = config.descent ? config.descent : 0;
+  }
+
+  // Members: Hot ~62/78 bytes
+  // float                       FontSize;           // <user set>   // Height of characters, set during loading (don't change after loading)
+  get FontStyle(): string { return this.native.FontStyle; }
+  set FontStyle(v: string) { this.native.FontStyle = v; }
+
+  get FontName(): string { return this.native.FontName; }
+  set FontName(v: string) { this.native.FontName = v; }
+
+  get FontSize(): number { return this.native.FontSize; }
+  set FontSize(v: number) { this.native.FontSize = v; }
+
+  get SpaceX(): number[] { return [this.native.SpaceX0, this.native.SpaceX1]; }
+  set SpaceX(v: number[]) { this.native.SpaceX0 = v[0]; this.native.SpaceX1 = v[1]; }
+
+  // float                       Scale;              // = 1.f        // Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()
+  get Scale(): number { return this.native.Scale; }
+  set Scale(value: number) { this.native.Scale = value; }
+  // ImVector<ImFontGlyph>       Glyphs;             //              // All glyphs.
+  get Glyphs(): ImVector<ImFontGlyph> {
+    const glyphs = new ImVector<ImFontGlyph>();
+    this.native.IterateGlyphs((glyph: Bind.reference_ImFontGlyph): void => {
+      glyphs.push(new ImFontGlyph(glyph)); // TODO: wrap native
+    });
+    return glyphs;
+  }
+  // ImVector<float>             IndexAdvanceX;      //              // Sparse. Glyphs->AdvanceX in a directly indexable way (more cache-friendly, for CalcTextSize functions which are often bottleneck in large UI).
+  get IndexAdvanceX(): number[] {
+    let a = [...Array(this.native.IndexAdvanceXSize)];
+    for (let i = 0; i < this.native.IndexAdvanceXSize; i++) {
+      a[i] = this.GetAdvanceX(i);
+    }
+    return a;
+    //return new Float32Array(this.native.IndexAdvanceX.buffer,0,this.native.IndexAdvanceX.length/Float32Array.BYTES_PER_ELEMENT);
+  }
+  //get IndexAdvanceX():Uint8Array {return this.native.IndexAdvanceX;}
+  get IndexAdvanceXSize(): number { return this.native.IndexAdvanceXSize; }
+
+  get NotReadyChar(): number[] {
+    let a = [...Array(this.native.NotReadyCharSize)];
+    for (let i = 0; i < this.native.NotReadyCharSize; i++) {
+      a[i] = this.GetNotReadyChar(i);
+    }
+    return a;
+  }
+  get NotReadyCharSize(): number { return this.native.NotReadyCharSize; }
+  // ImVector<unsigned short>    IndexLookup;        //              // Sparse. Index glyphs by Unicode code-point.
+  // get IndexLookup(): any { return this.native.IndexLookup; }
+  // const ImFontGlyph*          FallbackGlyph;      // == FindGlyph(FontFallbackChar)
+  get FallbackGlyph(): ImFontGlyph | null {
+    const glyph = this.native.FallbackGlyph;
+    return glyph && new ImFontGlyph(glyph);
+  }
+  set FallbackGlyph(value: ImFontGlyph | null) {
+    this.native.FallbackGlyph = value && value.internal as Bind.reference_ImFontGlyph;
+  }
+  // float                       FallbackAdvanceX;   // == FallbackGlyph->AdvanceX
+  get FallbackAdvanceX(): number { return this.native.FallbackAdvanceX; }
+  // ImWchar                     FallbackChar;       // = '?'        // Replacement glyph if one isn't found. Only set via SetFallbackChar()
+  get FallbackChar(): number { return this.native.FallbackChar; }
+  // ImWchar                     EllipsisChar;       // 2     // out // = -1       // Character used for ellipsis rendering.
+  get EllipsisChar(): number { return this.native.EllipsisChar; }
+
+  // Members: Cold ~18/26 bytes
+  // short                       ConfigDataCount;    // ~ 1          // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
+  get ConfigDataCount(): number { return this.native.ConfigDataCount; }
+  // ImFontConfig*               ConfigData;         //              // Pointer within ContainerAtlas->ConfigData
+  get ConfigData(): ImFontConfig {
+    return new ImFontConfig(this.native.ConfigData);
+  }
+  // ImFontAtlas*                ContainerAtlas;     //              // What we has been loaded into
+  get ContainerAtlas(): ImFontAtlas | null { return null; }
+  // float                       Ascent, Descent;    //              // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
+  get Ascent(): number { return this.native.Ascent; }
+  set Ascent(v: number) { this.native.Ascent = v; }
+  get Descent(): number { return this.native.Descent; }
+  set Descent(v: number) { this.native.Descent = v; }
+  // int                         MetricsTotalSurface;//              // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
+  get MetricsTotalSurface(): number { return this.native.MetricsTotalSurface; }
+
+  // Methods
+  // IMGUI_API ImFont();
+  // IMGUI_API ~ImFont();
+  // IMGUI_API void              ClearOutputData();
+  public ClearOutputData(): void { return this.native.ClearOutputData(); }
+  // IMGUI_API void              BuildLookupTable();
+  public BuildLookupTable(): void { return this.native.BuildLookupTable(); }
+  // IMGUI_API const ImFontGlyph*FindGlyph(ImWchar c) const;
+  public FindGlyph(c: number): Readonly<ImFontGlyph> | null {
+    const glyph: Readonly<Bind.reference_ImFontGlyph> | null = this.native.FindGlyph(c);
+    return glyph && new ImFontGlyph(glyph);
+  }
+  // IMGUI_API const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;
+  public FindGlyphNoFallback(c: number): ImFontGlyph | null {
+    const glyph: Readonly<Bind.reference_ImFontGlyph> | null = this.native.FindGlyphNoFallback(c);
+    return glyph && new ImFontGlyph(glyph);
+  }
+  // IMGUI_API void              SetFallbackChar(ImWchar c);
+  public SetFallbackChar(c: number): void { return this.native.SetFallbackChar(c); }
+  // float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
+  public GetCharAdvance(c: number): number { return this.native.GetCharAdvance(c); }
+  // bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }
+  public IsLoaded(): boolean { return this.native.IsLoaded(); }
+  // const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : "<unknown>"; }
+  public GetDebugName(): string { return this.native.GetDebugName(); }
+
+  // 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.
+  // 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.
+  // IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8
+  public CalcTextSizeA(size: number, max_width: number, wrap_width: number, text_begin: string, text_end: number | null = null, remaining: Bind.ImScalar<number> | null = null, isready: Bind.ImScalar<boolean> | null = null): Bind.interface_ImVec2 {
+    return this.native.CalcTextSizeA(size, max_width, wrap_width, text_end !== null ? text_begin.substring(0, text_end) : text_begin, remaining, isready, new ImVec2());
+  }
+  // IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
+  public CalcWordWrapPositionA(scale: number, text: string, text_end: number | null = null, wrap_width: number): number {
+    return this.native.CalcWordWrapPositionA(scale, text_end !== null ? text.substring(0, text_end) : text, wrap_width);
+  }
+  // IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const;
+  public RenderChar(draw_list: ImDrawList, size: number, pos: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, c: Bind.ImWchar): void {
+    this.native.RenderChar(draw_list.native, size, pos, col, c);
+  }
+  // IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;
+  public RenderText(draw_list: ImDrawList, size: number, pos: Readonly<Bind.interface_ImVec2>, col: Bind.ImU32, clip_rect: Readonly<Bind.interface_ImVec4>, text_begin: string, text_end: number | null = null, wrap_width: number = 0.0, cpu_fine_clip: boolean = false): void {
+    this.native.RenderText(draw_list.native, size, pos, col, clip_rect, text_begin, wrap_width, cpu_fine_clip);
+  }
+
+  // [Internal]
+  // IMGUI_API void              GrowIndex(int new_size);
+  // IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);
+  // IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.
+
+  // #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
+  // typedef ImFontGlyph Glyph; // OBSOLETE 1.52+
+  // #endif
+
+  // IMGUI_API bool              IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last);
+  public IsGlyphRangeUnused(c_begin: number, c_last: number): boolean { return false; } // TODO
+
+  get GlyphToCreate(): ImFontGlyph {
+    let glyph = this.native.GlyphToCreate();
+    return glyph ? new ImFontGlyph(glyph) : null;
+  }
+
+  get IterateGlyphToCreate(): ImFontGlyph[] {
+    const glyphs: ImFontGlyph[] = [];
+    this.native.IterateGlyphToCreate((glyph: Bind.reference_ImFontGlyph): void => {
+      glyphs.push(new ImFontGlyph(glyph));
+    });
+    return glyphs;
+  }
+  public GlyphCreated(glyph: ImFontGlyph) {
+    this.native.GlyphCreated(glyph.internal);
+  }
+  public ClearGlyphCreated() {
+    this.native.ClearGlyphCreated();
+  }
+
+  public CreateGlyph(text: string) {
+    this.native.CreateGlyph(text);
+  }
+  AddFontRange(start: number, end: number) {
+    this.native.AddFontRange(start, end);
+  }
+  ClearFontRange() {
+    this.native.ClearFontRange();
+  }
+  MergeFont(font: ImFont) {
+    this.native.MergeFont(font.native);
+  }
+  ClearSubFont() {
+    this.native.ClearSubFont();
+  }
+  InRange(c: number): boolean {
+    return this.native.InRange(c);
+  }
+  GetAdvanceX(c: number): number {
+    return this.native.GetAdvanceX(c);
+  }
+  GetNotReadyChar(i: number): number {
+    return this.native.GetNotReadyChar(i);
+  }
 }
 
 // a script version of Bind.ImGuiStyle with matching interface
 class script_ImGuiStyle implements Bind.interface_ImGuiStyle {
-    public Alpha: number = 1.0;
-    public WindowPadding: ImVec2 = new ImVec2(8, 8);
-    public WindowRounding: number = 7.0;
-    public WindowBorderSize: number = 0.0;
-    public WindowMinSize: ImVec2 = new ImVec2(32, 32);
-    public WindowTitleAlign: ImVec2 = new ImVec2(0.0, 0.5);
-    public WindowMenuButtonPosition: ImGuiDir = ImGuiDir.Left;
-    public ChildRounding: number = 0.0;
-    public ChildBorderSize: number = 1.0;
-    public PopupRounding: number = 0.0;
-    public PopupBorderSize: number = 1.0;
-    public FramePadding: ImVec2 = new ImVec2(4, 3);
-    public FrameRounding: number = 0.0;
-    public FrameBorderSize: number = 0.0;
-    public ItemSpacing: ImVec2 = new ImVec2(8, 4);
-    public ItemInnerSpacing: ImVec2 = new ImVec2(4, 4);
-    public CellPadding: ImVec2 = new ImVec2(4, 2);
-    public TouchExtraPadding: ImVec2 = new ImVec2(0, 0);
-    public IndentSpacing: number = 21.0;
-    public ColumnsMinSpacing: number = 6.0;
-    public ScrollbarSize: number = 16.0;
-    public ScrollbarRounding: number = 9.0;
-    public GrabMinSize: number = 10.0;
-    public GrabRounding: number = 0.0;
-    public LogSliderDeadzone: number = 4.0;
-    public TabRounding: number = 0.0;
-    public TabBorderSize: number = 0.0;
-    public TabMinWidthForCloseButton: number = 0.0;
-    public ColorButtonPosition: ImGuiDir = ImGuiDir.Right;
-    public ButtonTextAlign: ImVec2 = new ImVec2(0.5, 0.5);
-    public SelectableTextAlign: ImVec2 = new ImVec2(0.0, 0.0);
-    public DisplayWindowPadding: ImVec2 = new ImVec2(22, 22);
-    public DisplaySafeAreaPadding: ImVec2 = new ImVec2(4, 4);
-    public MouseCursorScale: number = 1;
-    public AntiAliasedLines: boolean = true;
-    public AntiAliasedLinesUseTex: boolean = true;
-    public AntiAliasedFill: boolean = true;
-    public CurveTessellationTol: number = 1.25;
-    public CircleSegmentMaxError: number = 1.60;
-    private Colors: ImVec4[] = [];
-    public _getAt_Colors(index: number): Bind.interface_ImVec4 { return this.Colors[index]; }
-    public _setAt_Colors(index: number, color: Readonly<Bind.interface_ImVec4>): boolean { this.Colors[index].Copy(color); return true; }
-
-    constructor() {
-        for (let i = 0; i < ImGuiCol.COUNT; ++i) {
-            this.Colors[i] = new ImVec4();
-        }
-        const _this = new ImGuiStyle(this);
-        const native = new bind.ImGuiStyle();
-        const _that = new ImGuiStyle(native);
-        _that.Copy(_this);
-        bind.StyleColorsClassic(native);
-        _this.Copy(_that);
-        native.delete();
-    }
-
-    public ScaleAllSizes(scale_factor: number): void {
-        const _this = new ImGuiStyle(this);
-        const native = new bind.ImGuiStyle();
-        const _that = new ImGuiStyle(native);
-        _that.Copy(_this);
-        native.ScaleAllSizes(scale_factor);
-        _this.Copy(_that);
-        native.delete();
-    }
-}
-
-export { ImGuiStyle as Style }
-export class ImGuiStyle
-{
-    constructor(public readonly internal: Bind.interface_ImGuiStyle = new script_ImGuiStyle()) {}
-
-    get Alpha(): number { return this.internal.Alpha; } set Alpha(value: number) { this.internal.Alpha = value; }
-    get WindowPadding(): Bind.interface_ImVec2 { return this.internal.WindowPadding; }
-    get WindowRounding(): number { return this.internal.WindowRounding; } set WindowRounding(value: number) { this.internal.WindowRounding = value; }
-    get WindowBorderSize(): number { return this.internal.WindowBorderSize; } set WindowBorderSize(value: number) { this.internal.WindowBorderSize = value; }
-    get WindowMinSize(): Bind.interface_ImVec2 { return this.internal.WindowMinSize; }
-    get WindowTitleAlign(): Bind.interface_ImVec2 { return this.internal.WindowTitleAlign; }
-    get WindowMenuButtonPosition(): ImGuiDir { return this.internal.WindowMenuButtonPosition; } set WindowMenuButtonPosition(value: ImGuiDir) { this.internal.WindowMenuButtonPosition = value; }
-    get ChildRounding(): number { return this.internal.ChildRounding; } set ChildRounding(value: number) { this.internal.ChildRounding = value; }
-    get ChildBorderSize(): number { return this.internal.ChildBorderSize; } set ChildBorderSize(value: number) { this.internal.ChildBorderSize = value; }
-    get PopupRounding(): number { return this.internal.PopupRounding; } set PopupRounding(value: number) { this.internal.PopupRounding = value; }
-    get PopupBorderSize(): number { return this.internal.PopupBorderSize; } set PopupBorderSize(value: number) { this.internal.PopupBorderSize = value; }
-    get FramePadding(): Bind.interface_ImVec2 { return this.internal.FramePadding; }
-    get FrameRounding(): number { return this.internal.FrameRounding; } set FrameRounding(value: number) { this.internal.FrameRounding = value; }
-    get FrameBorderSize(): number { return this.internal.FrameBorderSize; } set FrameBorderSize(value: number) { this.internal.FrameBorderSize = value; }
-    get ItemSpacing(): Bind.interface_ImVec2 { return this.internal.ItemSpacing; }
-    get ItemInnerSpacing(): Bind.interface_ImVec2 { return this.internal.ItemInnerSpacing; }
-    get CellPadding(): Bind.interface_ImVec2 { return this.internal.CellPadding; }
-    get TouchExtraPadding(): Bind.interface_ImVec2 { return this.internal.TouchExtraPadding; }
-    get IndentSpacing(): number { return this.internal.IndentSpacing; } set IndentSpacing(value: number) { this.internal.IndentSpacing = value; }
-    get ColumnsMinSpacing(): number { return this.internal.ColumnsMinSpacing; } set ColumnsMinSpacing(value: number) { this.internal.ColumnsMinSpacing = value; }
-    get ScrollbarSize(): number { return this.internal.ScrollbarSize; } set ScrollbarSize(value: number) { this.internal.ScrollbarSize = value; }
-    get ScrollbarRounding(): number { return this.internal.ScrollbarRounding; } set ScrollbarRounding(value: number) { this.internal.ScrollbarRounding = value; }
-    get GrabMinSize(): number { return this.internal.GrabMinSize; } set GrabMinSize(value: number) { this.internal.GrabMinSize = value; }
-    get GrabRounding(): number { return this.internal.GrabRounding; } set GrabRounding(value: number) { this.internal.GrabRounding = value; }
-    get LogSliderDeadzone(): number { return this.internal.LogSliderDeadzone; } set LogSliderDeadzone(value: number) { this.internal.LogSliderDeadzone = value; }
-    get TabRounding(): number { return this.internal.TabRounding; } set TabRounding(value: number) { this.internal.TabRounding = value; }
-    get TabBorderSize(): number { return this.internal.TabBorderSize; } set TabBorderSize(value: number) { this.internal.TabBorderSize = value; }
-    get TabMinWidthForCloseButton(): number { return this.internal.TabMinWidthForCloseButton; } set TabMinWidthForCloseButton(value: number) { this.internal.TabMinWidthForCloseButton = value; }
-    get ColorButtonPosition(): number { return this.internal.ColorButtonPosition; } set ColorButtonPosition(value: number) { this.internal.ColorButtonPosition = value; }
-    get ButtonTextAlign(): Bind.interface_ImVec2 { return this.internal.ButtonTextAlign; }
-    get SelectableTextAlign(): Bind.interface_ImVec2 { return this.internal.SelectableTextAlign; }
-    get DisplayWindowPadding(): Bind.interface_ImVec2 { return this.internal.DisplayWindowPadding; }
-    get DisplaySafeAreaPadding(): Bind.interface_ImVec2 { return this.internal.DisplaySafeAreaPadding; }
-    get MouseCursorScale(): number { return this.internal.MouseCursorScale; } set MouseCursorScale(value: number) { this.internal.MouseCursorScale = value; }
-    get AntiAliasedLines(): boolean { return this.internal.AntiAliasedLines; } set AntiAliasedLines(value: boolean) { this.internal.AntiAliasedLines = value; }
-    get AntiAliasedLinesUseTex(): boolean { return this.internal.AntiAliasedLinesUseTex; } set AntiAliasedLinesUseTex(value: boolean) { this.internal.AntiAliasedLinesUseTex = value; }
-    get AntiAliasedFill(): boolean { return this.internal.AntiAliasedFill; } set AntiAliasedFill(value: boolean) { this.internal.AntiAliasedFill = value; }
-    get CurveTessellationTol(): number { return this.internal.CurveTessellationTol; } set CurveTessellationTol(value: number) { this.internal.CurveTessellationTol = value; }
-    get CircleSegmentMaxError(): number { return this.internal.CircleSegmentMaxError; } set CircleSegmentMaxError(value: number) { this.internal.CircleSegmentMaxError = value; }
-    public Colors: Bind.interface_ImVec4[] = new Proxy([], {
-        get: (target: Bind.interface_ImVec4[], key: PropertyKey): number | Bind.interface_ImVec4 => {
-            if (key === "length") { return ImGuiCol.COUNT; }
-            return this.internal._getAt_Colors(Number(key));
-        },
-        set: (target: Bind.interface_ImVec4[], key: PropertyKey, value: Readonly<Bind.interface_ImVec4>): boolean => {
-            return this.internal._setAt_Colors(Number(key), value);
-        },
-    });
-
-    public Copy(other: Readonly<ImGuiStyle>): this {
-        this.Alpha = other.Alpha;
-        this.WindowPadding.Copy(other.WindowPadding);
-        this.WindowRounding = other.WindowRounding;
-        this.WindowBorderSize = other.WindowBorderSize;
-        this.WindowMinSize.Copy(other.WindowMinSize);
-        this.WindowTitleAlign.Copy(other.WindowTitleAlign);
-        this.WindowMenuButtonPosition = other.WindowMenuButtonPosition;
-        this.ChildRounding = other.ChildRounding;
-        this.ChildBorderSize = other.ChildBorderSize;
-        this.PopupRounding = other.PopupRounding;
-        this.PopupBorderSize = other.PopupBorderSize;
-        this.FramePadding.Copy(other.FramePadding);
-        this.FrameRounding = other.FrameRounding;
-        this.FrameBorderSize = other.FrameBorderSize;
-        this.ItemSpacing.Copy(other.ItemSpacing);
-        this.ItemInnerSpacing.Copy(other.ItemInnerSpacing);
-        this.CellPadding.Copy(other.CellPadding);
-        this.TouchExtraPadding.Copy(other.TouchExtraPadding);
-        this.IndentSpacing = other.IndentSpacing;
-        this.ColumnsMinSpacing = other.ColumnsMinSpacing;
-        this.ScrollbarSize = other.ScrollbarSize;
-        this.ScrollbarRounding = other.ScrollbarRounding;
-        this.GrabMinSize = other.GrabMinSize;
-        this.GrabRounding = other.GrabRounding;
-        this.LogSliderDeadzone = other.LogSliderDeadzone;
-        this.TabRounding = other.TabRounding;
-        this.TabBorderSize = other.TabBorderSize;
-        this.TabMinWidthForCloseButton = other.TabMinWidthForCloseButton;
-        this.ColorButtonPosition = other.ColorButtonPosition;
-        this.ButtonTextAlign.Copy(other.ButtonTextAlign);
-        this.DisplayWindowPadding.Copy(other.DisplayWindowPadding);
-        this.DisplaySafeAreaPadding.Copy(other.DisplaySafeAreaPadding);
-        this.MouseCursorScale = other.MouseCursorScale;
-        this.AntiAliasedLines = other.AntiAliasedLines;
-        this.AntiAliasedLinesUseTex = other.AntiAliasedLinesUseTex;
-        this.AntiAliasedFill = other.AntiAliasedFill;
-        this.CurveTessellationTol = other.CurveTessellationTol;
-        this.CircleSegmentMaxError = other.CircleSegmentMaxError;
-        for (let i = 0; i < ImGuiCol.COUNT; ++i) {
-            this.Colors[i].Copy(other.Colors[i]);
-        }
-        return this;
-    }
-
-    public ScaleAllSizes(scale_factor: number): void { this.internal.ScaleAllSizes(scale_factor); }
+  public Alpha: number = 1.0;
+  public WindowPadding: ImVec2 = new ImVec2(8, 8);
+  public WindowRounding: number = 7.0;
+  public WindowBorderSize: number = 0.0;
+  public WindowMinSize: ImVec2 = new ImVec2(32, 32);
+  public WindowTitleAlign: ImVec2 = new ImVec2(0.0, 0.5);
+  public WindowMenuButtonPosition: ImGuiDir = ImGuiDir.Left;
+  public ChildRounding: number = 0.0;
+  public ChildBorderSize: number = 1.0;
+  public PopupRounding: number = 0.0;
+  public PopupBorderSize: number = 1.0;
+  public FramePadding: ImVec2 = new ImVec2(4, 3);
+  public FrameRounding: number = 0.0;
+  public FrameBorderSize: number = 0.0;
+  public ItemSpacing: ImVec2 = new ImVec2(8, 4);
+  public ItemInnerSpacing: ImVec2 = new ImVec2(4, 4);
+  public CellPadding: ImVec2 = new ImVec2(4, 2);
+  public TouchExtraPadding: ImVec2 = new ImVec2(0, 0);
+  public IndentSpacing: number = 21.0;
+  public ColumnsMinSpacing: number = 6.0;
+  public ScrollbarSize: number = 16.0;
+  public ScrollbarRounding: number = 9.0;
+  public GrabMinSize: number = 10.0;
+  public GrabRounding: number = 0.0;
+  public LogSliderDeadzone: number = 4.0;
+  public TabRounding: number = 0.0;
+  public TabBorderSize: number = 0.0;
+  public TabMinWidthForCloseButton: number = 0.0;
+  public ColorButtonPosition: ImGuiDir = ImGuiDir.Right;
+  public ButtonTextAlign: ImVec2 = new ImVec2(0.5, 0.5);
+  public SelectableTextAlign: ImVec2 = new ImVec2(0.0, 0.0);
+  public DisplayWindowPadding: ImVec2 = new ImVec2(22, 22);
+  public DisplaySafeAreaPadding: ImVec2 = new ImVec2(4, 4);
+  public MouseCursorScale: number = 1;
+  public AntiAliasedLines: boolean = true;
+  public AntiAliasedLinesUseTex: boolean = true;
+  public AntiAliasedFill: boolean = true;
+  public CurveTessellationTol: number = 1.25;
+  public CircleSegmentMaxError: number = 1.60;
+  private Colors: ImVec4[] = [];
+  public _getAt_Colors(index: number): Bind.interface_ImVec4 { return this.Colors[index]; }
+  public _setAt_Colors(index: number, color: Readonly<Bind.interface_ImVec4>): boolean { this.Colors[index].Copy(color); return true; }
+
+  constructor() {
+    for (let i = 0; i < ImGuiCol.COUNT; ++i) {
+      this.Colors[i] = new ImVec4();
+    }
+    const _this = new ImGuiStyle(this);
+    const native = new bind.ImGuiStyle();
+    const _that = new ImGuiStyle(native);
+    _that.Copy(_this);
+    bind.StyleColorsClassic(native);
+    _this.Copy(_that);
+    native.delete();
+  }
+
+  public ScaleAllSizes(scale_factor: number): void {
+    const _this = new ImGuiStyle(this);
+    const native = new bind.ImGuiStyle();
+    const _that = new ImGuiStyle(native);
+    _that.Copy(_this);
+    native.ScaleAllSizes(scale_factor);
+    _this.Copy(_that);
+    native.delete();
+  }
+}
+
+export { ImGuiStyle as Style };
+export class ImGuiStyle {
+  constructor(public readonly internal: Bind.interface_ImGuiStyle = new script_ImGuiStyle()) {}
+
+  get Alpha(): number { return this.internal.Alpha; } set Alpha(value: number) { this.internal.Alpha = value; }
+  get WindowPadding(): Bind.interface_ImVec2 { return this.internal.WindowPadding; }
+  get WindowRounding(): number { return this.internal.WindowRounding; } set WindowRounding(value: number) { this.internal.WindowRounding = value; }
+  get WindowBorderSize(): number { return this.internal.WindowBorderSize; } set WindowBorderSize(value: number) { this.internal.WindowBorderSize = value; }
+  get WindowMinSize(): Bind.interface_ImVec2 { return this.internal.WindowMinSize; }
+  get WindowTitleAlign(): Bind.interface_ImVec2 { return this.internal.WindowTitleAlign; }
+  get WindowMenuButtonPosition(): ImGuiDir { return this.internal.WindowMenuButtonPosition; } set WindowMenuButtonPosition(value: ImGuiDir) { this.internal.WindowMenuButtonPosition = value; }
+  get ChildRounding(): number { return this.internal.ChildRounding; } set ChildRounding(value: number) { this.internal.ChildRounding = value; }
+  get ChildBorderSize(): number { return this.internal.ChildBorderSize; } set ChildBorderSize(value: number) { this.internal.ChildBorderSize = value; }
+  get PopupRounding(): number { return this.internal.PopupRounding; } set PopupRounding(value: number) { this.internal.PopupRounding = value; }
+  get PopupBorderSize(): number { return this.internal.PopupBorderSize; } set PopupBorderSize(value: number) { this.internal.PopupBorderSize = value; }
+  get FramePadding(): Bind.interface_ImVec2 { return this.internal.FramePadding; }
+  get FrameRounding(): number { return this.internal.FrameRounding; } set FrameRounding(value: number) { this.internal.FrameRounding = value; }
+  get FrameBorderSize(): number { return this.internal.FrameBorderSize; } set FrameBorderSize(value: number) { this.internal.FrameBorderSize = value; }
+  get ItemSpacing(): Bind.interface_ImVec2 { return this.internal.ItemSpacing; }
+  get ItemInnerSpacing(): Bind.interface_ImVec2 { return this.internal.ItemInnerSpacing; }
+  get CellPadding(): Bind.interface_ImVec2 { return this.internal.CellPadding; }
+  get TouchExtraPadding(): Bind.interface_ImVec2 { return this.internal.TouchExtraPadding; }
+  get IndentSpacing(): number { return this.internal.IndentSpacing; } set IndentSpacing(value: number) { this.internal.IndentSpacing = value; }
+  get ColumnsMinSpacing(): number { return this.internal.ColumnsMinSpacing; } set ColumnsMinSpacing(value: number) { this.internal.ColumnsMinSpacing = value; }
+  get ScrollbarSize(): number { return this.internal.ScrollbarSize; } set ScrollbarSize(value: number) { this.internal.ScrollbarSize = value; }
+  get ScrollbarRounding(): number { return this.internal.ScrollbarRounding; } set ScrollbarRounding(value: number) { this.internal.ScrollbarRounding = value; }
+  get GrabMinSize(): number { return this.internal.GrabMinSize; } set GrabMinSize(value: number) { this.internal.GrabMinSize = value; }
+  get GrabRounding(): number { return this.internal.GrabRounding; } set GrabRounding(value: number) { this.internal.GrabRounding = value; }
+  get LogSliderDeadzone(): number { return this.internal.LogSliderDeadzone; } set LogSliderDeadzone(value: number) { this.internal.LogSliderDeadzone = value; }
+  get TabRounding(): number { return this.internal.TabRounding; } set TabRounding(value: number) { this.internal.TabRounding = value; }
+  get TabBorderSize(): number { return this.internal.TabBorderSize; } set TabBorderSize(value: number) { this.internal.TabBorderSize = value; }
+  get TabMinWidthForCloseButton(): number { return this.internal.TabMinWidthForCloseButton; } set TabMinWidthForCloseButton(value: number) { this.internal.TabMinWidthForCloseButton = value; }
+  get ColorButtonPosition(): number { return this.internal.ColorButtonPosition; } set ColorButtonPosition(value: number) { this.internal.ColorButtonPosition = value; }
+  get ButtonTextAlign(): Bind.interface_ImVec2 { return this.internal.ButtonTextAlign; }
+  get SelectableTextAlign(): Bind.interface_ImVec2 { return this.internal.SelectableTextAlign; }
+  get DisplayWindowPadding(): Bind.interface_ImVec2 { return this.internal.DisplayWindowPadding; }
+  get DisplaySafeAreaPadding(): Bind.interface_ImVec2 { return this.internal.DisplaySafeAreaPadding; }
+  get MouseCursorScale(): number { return this.internal.MouseCursorScale; } set MouseCursorScale(value: number) { this.internal.MouseCursorScale = value; }
+  get AntiAliasedLines(): boolean { return this.internal.AntiAliasedLines; } set AntiAliasedLines(value: boolean) { this.internal.AntiAliasedLines = value; }
+  get AntiAliasedLinesUseTex(): boolean { return this.internal.AntiAliasedLinesUseTex; } set AntiAliasedLinesUseTex(value: boolean) { this.internal.AntiAliasedLinesUseTex = value; }
+  get AntiAliasedFill(): boolean { return this.internal.AntiAliasedFill; } set AntiAliasedFill(value: boolean) { this.internal.AntiAliasedFill = value; }
+  get CurveTessellationTol(): number { return this.internal.CurveTessellationTol; } set CurveTessellationTol(value: number) { this.internal.CurveTessellationTol = value; }
+  get CircleSegmentMaxError(): number { return this.internal.CircleSegmentMaxError; } set CircleSegmentMaxError(value: number) { this.internal.CircleSegmentMaxError = value; }
+  public Colors: Bind.interface_ImVec4[] = new Proxy([], {
+    get: (target: Bind.interface_ImVec4[], key: PropertyKey): number | Bind.interface_ImVec4 => {
+      if (key === "length") { return ImGuiCol.COUNT; }
+      return this.internal._getAt_Colors(Number(key));
+    },
+    set: (target: Bind.interface_ImVec4[], key: PropertyKey, value: Readonly<Bind.interface_ImVec4>): boolean => {
+      return this.internal._setAt_Colors(Number(key), value);
+    },
+  });
+
+  public Copy(other: Readonly<ImGuiStyle>): this {
+    this.Alpha = other.Alpha;
+    this.WindowPadding.Copy(other.WindowPadding);
+    this.WindowRounding = other.WindowRounding;
+    this.WindowBorderSize = other.WindowBorderSize;
+    this.WindowMinSize.Copy(other.WindowMinSize);
+    this.WindowTitleAlign.Copy(other.WindowTitleAlign);
+    this.WindowMenuButtonPosition = other.WindowMenuButtonPosition;
+    this.ChildRounding = other.ChildRounding;
+    this.ChildBorderSize = other.ChildBorderSize;
+    this.PopupRounding = other.PopupRounding;
+    this.PopupBorderSize = other.PopupBorderSize;
+    this.FramePadding.Copy(other.FramePadding);
+    this.FrameRounding = other.FrameRounding;
+    this.FrameBorderSize = other.FrameBorderSize;
+    this.ItemSpacing.Copy(other.ItemSpacing);
+    this.ItemInnerSpacing.Copy(other.ItemInnerSpacing);
+    this.CellPadding.Copy(other.CellPadding);
+    this.TouchExtraPadding.Copy(other.TouchExtraPadding);
+    this.IndentSpacing = other.IndentSpacing;
+    this.ColumnsMinSpacing = other.ColumnsMinSpacing;
+    this.ScrollbarSize = other.ScrollbarSize;
+    this.ScrollbarRounding = other.ScrollbarRounding;
+    this.GrabMinSize = other.GrabMinSize;
+    this.GrabRounding = other.GrabRounding;
+    this.LogSliderDeadzone = other.LogSliderDeadzone;
+    this.TabRounding = other.TabRounding;
+    this.TabBorderSize = other.TabBorderSize;
+    this.TabMinWidthForCloseButton = other.TabMinWidthForCloseButton;
+    this.ColorButtonPosition = other.ColorButtonPosition;
+    this.ButtonTextAlign.Copy(other.ButtonTextAlign);
+    this.DisplayWindowPadding.Copy(other.DisplayWindowPadding);
+    this.DisplaySafeAreaPadding.Copy(other.DisplaySafeAreaPadding);
+    this.MouseCursorScale = other.MouseCursorScale;
+    this.AntiAliasedLines = other.AntiAliasedLines;
+    this.AntiAliasedLinesUseTex = other.AntiAliasedLinesUseTex;
+    this.AntiAliasedFill = other.AntiAliasedFill;
+    this.CurveTessellationTol = other.CurveTessellationTol;
+    this.CircleSegmentMaxError = other.CircleSegmentMaxError;
+    for (let i = 0; i < ImGuiCol.COUNT; ++i) {
+      this.Colors[i].Copy(other.Colors[i]);
+    }
+    return this;
+  }
+
+  public ScaleAllSizes(scale_factor: number): void { this.internal.ScaleAllSizes(scale_factor); }
 }
 
 // This is where your app communicate with Dear ImGui. Access via ImGui::GetIO().
 // Read 'Programmer guide' section in .cpp file for general usage.
-export { ImGuiIO as IO }
-export class ImGuiIO
-{
-    constructor(public readonly native: Bind.reference_ImGuiIO) {}
-
-    //------------------------------------------------------------------
-    // Settings (fill once)                 // Default value:
-    //------------------------------------------------------------------
-
-    // ImGuiConfigFlags   ConfigFlags;         // = 0                  // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.
-    get ConfigFlags(): ImGuiConfigFlags { return this.native.ConfigFlags; }
-    set ConfigFlags(value: ImGuiConfigFlags) { this.native.ConfigFlags = value; }
-    // ImGuiBackendFlags  BackendFlags;        // = 0                  // Set ImGuiBackendFlags_ enum. Set by imgui_impl_xxx files or custom back-end to communicate features supported by the back-end.
-    get BackendFlags(): ImGuiBackendFlags { return this.native.BackendFlags; }
-    set BackendFlags(value: ImGuiBackendFlags) { this.native.BackendFlags = value; }
-    // ImVec2        DisplaySize;              // <unset>              // Display size, in pixels. For clamping windows positions.
-    get DisplaySize(): Bind.reference_ImVec2 { return this.native.DisplaySize; }
-    // float         DeltaTime;                // = 1.0f/60.0f         // Time elapsed since last frame, in seconds.
-    get DeltaTime(): number { return this.native.DeltaTime; }
-    set DeltaTime(value: number) { this.native.DeltaTime = value; }
-    // float         IniSavingRate;            // = 5.0f               // Maximum time between saving positions/sizes to .ini file, in seconds.
-    get IniSavingRate(): number { return this.native.IniSavingRate; }
-    set IniSavingRate(value: number) { this.native.IniSavingRate = value; }
-    // const char*   IniFilename;              // = "imgui.ini"        // Path to .ini file. NULL to disable .ini saving.
-    get IniFilename(): string { return this.native.IniFilename; }
-    set IniFilename(value: string) { this.native.IniFilename = value; }
-    // const char*   LogFilename;              // = "imgui_log.txt"    // Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
-    get LogFilename(): string { return this.native.LogFilename; }
-    set LogFilename(value: string) { this.native.LogFilename = value; }
-    // float         MouseDoubleClickTime;     // = 0.30f              // Time for a double-click, in seconds.
-    get MouseDoubleClickTime(): number { return this.native.MouseDoubleClickTime; }
-    set MouseDoubleClickTime(value: number) { this.native.MouseDoubleClickTime = value; }
-    // float         MouseDoubleClickMaxDist;  // = 6.0f               // Distance threshold to stay in to validate a double-click, in pixels.
-    get MouseDoubleClickMaxDist(): number { return this.native.MouseDoubleClickMaxDist; }
-    set MouseDoubleClickMaxDist(value: number) { this.native.MouseDoubleClickMaxDist = value; }
-    // float         MouseDragThreshold;       // = 6.0f               // Distance threshold before considering we are dragging
-    get MouseDragThreshold(): number { return this.native.MouseDragThreshold; }
-    set MouseDragThreshold(value: number) { this.native.MouseDragThreshold = value; }
-    // int           KeyMap[ImGuiKey_COUNT];   // <unset>              // Map of indices into the KeysDown[512] entries array
-    public KeyMap: number[] = new Proxy([], {
-        get: (target: number[], key: PropertyKey): number => {
-            if (key === "length") { return ImGuiKey.COUNT; }
-            return this.native._getAt_KeyMap(Number(key));
-        },
-        set: (target: number[], key: PropertyKey, value: number): boolean => {
-            return this.native._setAt_KeyMap(Number(key), value);
-        },
-    });
-    // float         KeyRepeatDelay;           // = 0.250f             // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
-    get KeyRepeatDelay(): number { return this.native.KeyRepeatDelay; }
-    set KeyRepeatDelay(value: number) { this.native.KeyRepeatDelay = value; }
-    // float         KeyRepeatRate;            // = 0.050f             // When holding a key/button, rate at which it repeats, in seconds.
-    get KeyRepeatRate(): number { return this.native.KeyRepeatRate; }
-    set KeyRepeatRate(value: number) { this.native.KeyRepeatRate = value; }
-    // void*         UserData;                 // = NULL               // Store your own data for retrieval by callbacks.
-    get UserData(): any { return this.native.UserData; }
-    set UserData(value: any) { this.native.UserData = value; }
-
-    // ImFontAtlas*  Fonts;                    // <auto>               // Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.
-    get Fonts(): ImFontAtlas { return new ImFontAtlas(this.native.Fonts); }
-    // float         FontGlobalScale;          // = 1.0f               // Global scale all fonts
-    get FontGlobalScale(): number { return this.native.FontGlobalScale; }
-    set FontGlobalScale(value: number) { this.native.FontGlobalScale = value; }
-    // bool          FontAllowUserScaling;     // = false              // Allow user scaling text of individual window with CTRL+Wheel.
-    get FontAllowUserScaling(): boolean { return this.native.FontAllowUserScaling; }
-    set FontAllowUserScaling(value: boolean) { this.native.FontAllowUserScaling = value; }
-    // ImFont*       FontDefault;              // = NULL               // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
-    get FontDefault(): ImFont | null {
-        const font: Bind.reference_ImFont | null = this.native.FontDefault;
-        return (font === null) ? null : new ImFont(font);
-    }
-    set FontDefault(value: ImFont | null) {
-        this.native.FontDefault = value && value.native;
-    }
-    // ImVec2        DisplayFramebufferScale;  // = (1.0f,1.0f)        // For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.
-    get DisplayFramebufferScale(): Bind.reference_ImVec2 { return this.native.DisplayFramebufferScale; }
-
-    // Miscellaneous configuration options
-    // bool          OptMacOSXBehaviors;       // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl
-    get ConfigMacOSXBehaviors(): boolean { return this.native.ConfigMacOSXBehaviors; }
-    set ConfigMacOSXBehaviors(value: boolean) { this.native.ConfigMacOSXBehaviors = value; }
-    // bool          ConfigInputTextCursorBlink;   // = true               // Enable blinking cursor, for users who consider it annoying.
-    get ConfigInputTextCursorBlink(): boolean { return this.native.ConfigInputTextCursorBlink; }
-    set ConfigInputTextCursorBlink(value: boolean) { this.native.ConfigInputTextCursorBlink = value; }
-    // bool        ConfigDragClickToInputText;     // = false          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.
-    get ConfigDragClickToInputText(): boolean { return this.native.ConfigDragClickToInputText; }
-    set ConfigDragClickToInputText(value: boolean) { this.native.ConfigDragClickToInputText = value; }
-    // bool          ConfigWindowsResizeFromEdges; // = false          // [BETA] Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be the ImGuiWindowFlags_ResizeFromAnySide flag)
-    get ConfigWindowsResizeFromEdges(): boolean { return this.native.ConfigWindowsResizeFromEdges; }
-    set ConfigWindowsResizeFromEdges(value: boolean) { this.native.ConfigWindowsResizeFromEdges = value; }
-    // bool        ConfigWindowsMoveFromTitleBarOnly;// = false        // [BETA] Set to true to only allow moving windows when clicked+dragged from the title bar. Windows without a title bar are not affected.
-    get ConfigWindowsMoveFromTitleBarOnly(): boolean { return this.native.ConfigWindowsMoveFromTitleBarOnly; }
-    set ConfigWindowsMoveFromTitleBarOnly(value: boolean) { this.native.ConfigWindowsMoveFromTitleBarOnly = value; }
-    // float       ConfigMemoryCompactTimer;       // = 60.0f          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0f to disable.
-    get ConfigMemoryCompactTimer(): number { return this.native.ConfigMemoryCompactTimer; }
-    set ConfigMemoryCompactTimer(value: number) { this.native.ConfigMemoryCompactTimer = value; }
-
-    //------------------------------------------------------------------
-    // Settings (User Functions)
-    //------------------------------------------------------------------
-
-    // Optional: Platform/Renderer back-end name (informational only! will be displayed in About Window) + User data for back-end/wrappers to store their own stuff.
-    // const char* BackendPlatformName;            // = NULL
-    get BackendPlatformName(): string | null { return this.native.BackendPlatformName; }
-    set BackendPlatformName(value: string | null) { this.native.BackendPlatformName = value; }
-    // const char* BackendRendererName;            // = NULL
-    get BackendRendererName(): string | null { return this.native.BackendRendererName; }
-    set BackendRendererName(value: string | null) { this.native.BackendRendererName = value; }
-    // void*       BackendPlatformUserData;        // = NULL
-    get BackendPlatformUserData(): string | null { return this.native.BackendPlatformUserData; }
-    set BackendPlatformUserData(value: string | null) { this.native.BackendPlatformUserData = value; }
-    // void*       BackendRendererUserData;        // = NULL
-    get BackendRendererUserData(): string | null { return this.native.BackendRendererUserData; }
-    set BackendRendererUserData(value: string | null) { this.native.BackendRendererUserData = value; }
-    // void*       BackendLanguageUserData;        // = NULL
-    get BackendLanguageUserData(): string | null { return this.native.BackendLanguageUserData; }
-    set BackendLanguageUserData(value: string | null) { this.native.BackendLanguageUserData = value; }
-
-    // Optional: access OS clipboard
-    // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
-    // const char* (*GetClipboardTextFn)(void* user_data);
-    get GetClipboardTextFn(): ((user_data: any) => string) | null { return this.native.GetClipboardTextFn; }
-    set GetClipboardTextFn(value: ((user_data: any) => string) | null) { this.native.GetClipboardTextFn = value; }
-    // void        (*SetClipboardTextFn)(void* user_data, const char* text);
-    get SetClipboardTextFn(): ((user_data: any, text: string) => void) | null { return this.native.SetClipboardTextFn; }
-    set SetClipboardTextFn(value: ((user_data: any, text: string) => void) | null) { this.native.SetClipboardTextFn = value; }
-    // void*       ClipboardUserData;
-    get ClipboardUserData(): any { return this.native.ClipboardUserData; }
-    set ClipboardUserData(value: any) { this.native.ClipboardUserData = value; }
-
-    // Optional: override memory allocations. MemFreeFn() may be called with a NULL pointer.
-    // (default to posix malloc/free)
-    // void*       (*MemAllocFn)(size_t sz);
-    // void        (*MemFreeFn)(void* ptr);
-
-    // Optional: notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME in Windows)
-    // (default to use native imm32 api on Windows)
-    // void        (*ImeSetInputScreenPosFn)(int x, int y);
-    // void*       ImeWindowHandle;            // (Windows) Set this to your HWND to get automatic IME cursor positioning.
-
-    //------------------------------------------------------------------
-    // Input - Fill before calling NewFrame()
-    //------------------------------------------------------------------
-
-    // ImVec2      MousePos;                   // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)
-    get MousePos(): Bind.reference_ImVec2 { return this.native.MousePos; }
-    // bool        MouseDown[5];               // Mouse buttons: left, right, middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
-    public MouseDown: boolean[] = new Proxy([], {
-        get: (target: boolean[], key: PropertyKey): number | boolean => {
-            if (key === "length") { return 5; }
-            return this.native._getAt_MouseDown(Number(key));
-        },
-        set: (target: boolean[], key: PropertyKey, value: boolean): boolean => {
-            return this.native._setAt_MouseDown(Number(key), value);
-        },
-    });
-    // float       MouseWheel;                 // Mouse wheel: 1 unit scrolls about 5 lines text.
-    public get MouseWheel(): number { return this.native.MouseWheel; }
-    public set MouseWheel(value: number) { this.native.MouseWheel = value; }
-    // float       MouseWheelH;                    // Mouse wheel (Horizontal). Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.
-    public get MouseWheelH(): number { return this.native.MouseWheelH; }
-    public set MouseWheelH(value: number) { this.native.MouseWheelH = value; }
-    // bool        MouseDrawCursor;            // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).
-    get MouseDrawCursor(): boolean { return this.native.MouseDrawCursor; } set MouseDrawCursor(value: boolean) { this.native.MouseDrawCursor = value; }
-    // bool        KeyCtrl;                    // Keyboard modifier pressed: Control
-    get KeyCtrl(): boolean { return this.native.KeyCtrl; } set KeyCtrl(value: boolean) { this.native.KeyCtrl = value; }
-    // bool        KeyShift;                   // Keyboard modifier pressed: Shift
-    get KeyShift(): boolean { return this.native.KeyShift; } set KeyShift(value: boolean) { this.native.KeyShift = value; }
-    // bool        KeyAlt;                     // Keyboard modifier pressed: Alt
-    get KeyAlt(): boolean { return this.native.KeyAlt; } set KeyAlt(value: boolean) { this.native.KeyAlt = value; }
-    // bool        KeySuper;                   // Keyboard modifier pressed: Cmd/Super/Windows
-    get KeySuper(): boolean { return this.native.KeySuper; } set KeySuper(value: boolean) { this.native.KeySuper = value; }
-    // bool        KeysDown[512];              // Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)
-    public KeysDown: boolean[] = new Proxy([], {
-        get: (target: boolean[], key: PropertyKey): number | boolean => {
-            if (key === "length") { return 512; }
-            return this.native._getAt_KeysDown(Number(key));
-        },
-        set: (target: boolean[], key: PropertyKey, value: boolean): boolean => {
-            return this.native._setAt_KeysDown(Number(key), value);
-        },
-    });
-    // float       NavInputs[ImGuiNavInput_COUNT]; // Gamepad inputs (keyboard keys will be auto-mapped and be written here by ImGui::NewFrame)
-    public NavInputs: number[] = new Proxy([], {
-        get: (target: number[], key: PropertyKey): number => {
-            if (key === "length") { return ImGuiNavInput.COUNT; }
-            return this.native._getAt_NavInputs(Number(key));
-        },
-        set: (target: number[], key: PropertyKey, value: number): boolean => {
-            return this.native._setAt_NavInputs(Number(key), value);
-        },
-    });
-
-    // Functions
-    // IMGUI_API void AddInputCharacter(ImWchar c);                        // Add new character into InputCharacters[]
-    public AddInputCharacter(c: number): void { this.native.AddInputCharacter(c); }
-    // IMGUI_API void  AddInputCharacterUTF16(ImWchar16 c);        // Queue new character input from an UTF-16 character, it can be a surrogate
-    public AddInputCharacterUTF16(c: number): void { this.native.AddInputCharacterUTF16(c); }
-    // IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);      // Add new characters into InputCharacters[] from an UTF-8 string
-    public AddInputCharactersUTF8(utf8_chars: string): void { this.native.AddInputCharactersUTF8(utf8_chars); }
-    // inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   // Clear the text input buffer manually
-    public ClearInputCharacters(): void { this.native.ClearInputCharacters(); }
-
-    //------------------------------------------------------------------
-    // Output - Retrieve after calling NewFrame()
-    //------------------------------------------------------------------
-
-    // bool        WantCaptureMouse;           // When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application. This is set by ImGui when it wants to use your mouse (e.g. unclicked mouse is hovering a window, or a widget is active).
-    get WantCaptureMouse(): boolean { return this.native.WantCaptureMouse; } set WantCaptureMouse(value: boolean) { this.native.WantCaptureMouse = value; }
-    // bool        WantCaptureKeyboard;        // When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application. This is set by ImGui when it wants to use your keyboard inputs.
-    get WantCaptureKeyboard(): boolean { return this.native.WantCaptureKeyboard; } set WantCaptureKeyboard(value: boolean) { this.native.WantCaptureKeyboard = value; }
-    // bool        WantTextInput;              // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
-    get WantTextInput(): boolean { return this.native.WantTextInput; } set WantTextInput(value: boolean) { this.native.WantTextInput = value; }
-    // bool        WantSetMousePos;              // [BETA-NAV] MousePos has been altered, back-end should reposition mouse on next frame. Set only when 'NavMovesMouse=true'.
-    get WantSetMousePos(): boolean { return this.native.WantSetMousePos; } set WantSetMousePos(value: boolean) { this.native.WantSetMousePos = value; }
-    // bool        WantSaveIniSettings;        // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need to clear io.WantSaveIniSettings yourself.
-    get WantSaveIniSettings(): boolean { return this.native.WantSaveIniSettings; } set WantSaveIniSettings(value: boolean) { this.native.WantSaveIniSettings = value; }
-    // bool        NavActive;                  // Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
-    get NavActive(): boolean { return this.native.NavActive; } set NavActive(value: boolean) { this.native.NavActive = value; }
-    // bool        NavVisible;                 // Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).
-    get NavVisible(): boolean { return this.native.NavVisible; } set NavVisible(value: boolean) { this.native.NavVisible = value; }
-    // float       Framerate;                  // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames
-    get Framerate(): number { return this.native.Framerate; }
-    // int         MetricsRenderVertices;      // Vertices output during last call to Render()
-    get MetricsRenderVertices(): number { return this.native.MetricsRenderVertices; }
-    // int         MetricsRenderIndices;       // Indices output during last call to Render() = number of triangles * 3
-    get MetricsRenderIndices(): number { return this.native.MetricsRenderIndices; }
-    // int         MetricsRenderWindows;       // Number of visible windows
-    get MetricsRenderWindows(): number { return this.native.MetricsRenderWindows; }
-    // int         MetricsActiveWindows;       // Number of visible root windows (exclude child windows)
-    get MetricsActiveWindows(): number { return this.native.MetricsActiveWindows; }
-    // int         MetricsActiveAllocations;   // Number of active allocations, updated by MemAlloc/MemFree based on current context. May be off if you have multiple imgui contexts.
-    get MetricsActiveAllocations(): number { return this.native.MetricsActiveAllocations; }
-    // ImVec2      MouseDelta;                 // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.
-    get MouseDelta(): Readonly<Bind.reference_ImVec2> { return this.native.MouseDelta; }
-
-    //------------------------------------------------------------------
-    // [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed!
-    //------------------------------------------------------------------
-
-    // ImGuiKeyModFlags KeyMods;                   // Key mods flags (same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags), updated by NewFrame()
-    // ImVec2      MousePosPrev;               // Previous mouse position temporary storage (nb: not for public use, set to MousePos in NewFrame())
-    // ImVec2      MouseClickedPos[5];         // Position at time of clicking
-    public MouseClickedPos: Array<Readonly<Bind.reference_ImVec2>> = new Proxy([], {
-        get: (target: Array<Readonly<Bind.reference_ImVec2>>, key: PropertyKey): number | Readonly<Bind.reference_ImVec2> => {
-            if (key === "length") { return 5; }
-            return this.native._getAt_MouseClickedPos(Number(key));
-        },
-    });
-    // float       MouseClickedTime[5];        // Time of last click (used to figure out double-click)
-    // bool        MouseClicked[5];            // Mouse button went from !Down to Down
-    // bool        MouseDoubleClicked[5];      // Has mouse button been double-clicked?
-    // bool        MouseReleased[5];           // Mouse button went from Down to !Down
-    // bool        MouseDownOwned[5];          // Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.
-    // float       MouseDownDuration[5];       // Duration the mouse button has been down (0.0f == just clicked)
-    public MouseDownDuration: number[] = new Proxy([], {
-        get: (target: number[], key: PropertyKey): number => {
-            if (key === "length") { return 5; }
-            return this.native._getAt_MouseDownDuration(Number(key));
-        },
-    });
-    // float       MouseDownDurationPrev[5];   // Previous time the mouse button has been down
-    // ImVec2      MouseDragMaxDistanceAbs[5]; // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
-    // float       MouseDragMaxDistanceSqr[5]; // Squared maximum distance of how much mouse has traveled from the clicking point
-    // float       KeysDownDuration[512];      // Duration the keyboard key has been down (0.0f == just pressed)
-    public KeysDownDuration: number[] = new Proxy([], {
-        get: (target: number[], key: PropertyKey): number => {
-            if (key === "length") { return 512; }
-            return this.native._getAt_KeysDownDuration(Number(key));
-        },
-    });
-    // float       KeysDownDurationPrev[512];  // Previous duration the key has been down
-    // float       NavInputsDownDuration[ImGuiNavInput_COUNT];
-    public NavInputsDownDuration: number[] = new Proxy([], {
-        get: (target: number[], key: PropertyKey): number => {
-            if (key === "length") { return ImGuiNavInput.COUNT; }
-            return this.native._getAt_NavInputsDownDuration(Number(key));
-        },
-    });
-    // float       NavInputsDownDurationPrev[ImGuiNavInput_COUNT];
-    // float       PenPressure;                    // Touch/Pen pressure (0.0f to 1.0f, should be >0.0f only when MouseDown[0] == true). Helper storage currently unused by Dear ImGui.
-    // ImWchar16   InputQueueSurrogate;            // For AddInputCharacterUTF16
-    // ImVector<ImWchar> InputQueueCharacters;     // Queue of _characters_ input (obtained by platform backend). Fill using AddInputCharacter() helper.
+export { ImGuiIO as IO };
+export class ImGuiIO {
+  constructor(public readonly native: Bind.reference_ImGuiIO) {}
+
+  //------------------------------------------------------------------
+  // Settings (fill once)                 // Default value:
+  //------------------------------------------------------------------
+
+  // ImGuiConfigFlags   ConfigFlags;         // = 0                  // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.
+  get ConfigFlags(): ImGuiConfigFlags { return this.native.ConfigFlags; }
+  set ConfigFlags(value: ImGuiConfigFlags) { this.native.ConfigFlags = value; }
+  // ImGuiBackendFlags  BackendFlags;        // = 0                  // Set ImGuiBackendFlags_ enum. Set by imgui_impl_xxx files or custom back-end to communicate features supported by the back-end.
+  get BackendFlags(): ImGuiBackendFlags { return this.native.BackendFlags; }
+  set BackendFlags(value: ImGuiBackendFlags) { this.native.BackendFlags = value; }
+  // ImVec2        DisplaySize;              // <unset>              // Display size, in pixels. For clamping windows positions.
+  get DisplaySize(): Bind.reference_ImVec2 { return this.native.DisplaySize; }
+  // float         DeltaTime;                // = 1.0f/60.0f         // Time elapsed since last frame, in seconds.
+  get DeltaTime(): number { return this.native.DeltaTime; }
+  set DeltaTime(value: number) { this.native.DeltaTime = value; }
+  // float         IniSavingRate;            // = 5.0f               // Maximum time between saving positions/sizes to .ini file, in seconds.
+  get IniSavingRate(): number { return this.native.IniSavingRate; }
+  set IniSavingRate(value: number) { this.native.IniSavingRate = value; }
+  // const char*   IniFilename;              // = "imgui.ini"        // Path to .ini file. NULL to disable .ini saving.
+  get IniFilename(): string { return this.native.IniFilename; }
+  set IniFilename(value: string) { this.native.IniFilename = value; }
+  // const char*   LogFilename;              // = "imgui_log.txt"    // Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
+  get LogFilename(): string { return this.native.LogFilename; }
+  set LogFilename(value: string) { this.native.LogFilename = value; }
+  // float         MouseDoubleClickTime;     // = 0.30f              // Time for a double-click, in seconds.
+  get MouseDoubleClickTime(): number { return this.native.MouseDoubleClickTime; }
+  set MouseDoubleClickTime(value: number) { this.native.MouseDoubleClickTime = value; }
+  // float         MouseDoubleClickMaxDist;  // = 6.0f               // Distance threshold to stay in to validate a double-click, in pixels.
+  get MouseDoubleClickMaxDist(): number { return this.native.MouseDoubleClickMaxDist; }
+  set MouseDoubleClickMaxDist(value: number) { this.native.MouseDoubleClickMaxDist = value; }
+  // float         MouseDragThreshold;       // = 6.0f               // Distance threshold before considering we are dragging
+  get MouseDragThreshold(): number { return this.native.MouseDragThreshold; }
+  set MouseDragThreshold(value: number) { this.native.MouseDragThreshold = value; }
+  // int           KeyMap[ImGuiKey_COUNT];   // <unset>              // Map of indices into the KeysDown[512] entries array
+  public KeyMap: number[] = new Proxy([], {
+    get: (target: number[], key: PropertyKey): number => {
+      if (key === "length") { return ImGuiKey.COUNT; }
+      return this.native._getAt_KeyMap(Number(key));
+    },
+    set: (target: number[], key: PropertyKey, value: number): boolean => {
+      return this.native._setAt_KeyMap(Number(key), value);
+    },
+  });
+  // float         KeyRepeatDelay;           // = 0.250f             // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
+  get KeyRepeatDelay(): number { return this.native.KeyRepeatDelay; }
+  set KeyRepeatDelay(value: number) { this.native.KeyRepeatDelay = value; }
+  // float         KeyRepeatRate;            // = 0.050f             // When holding a key/button, rate at which it repeats, in seconds.
+  get KeyRepeatRate(): number { return this.native.KeyRepeatRate; }
+  set KeyRepeatRate(value: number) { this.native.KeyRepeatRate = value; }
+  // void*         UserData;                 // = NULL               // Store your own data for retrieval by callbacks.
+  get UserData(): any { return this.native.UserData; }
+  set UserData(value: any) { this.native.UserData = value; }
+
+  // ImFontAtlas*  Fonts;                    // <auto>               // Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.
+  get Fonts(): ImFontAtlas { return new ImFontAtlas(this.native.Fonts); }
+  // float         FontGlobalScale;          // = 1.0f               // Global scale all fonts
+  get FontGlobalScale(): number { return this.native.FontGlobalScale; }
+  set FontGlobalScale(value: number) { this.native.FontGlobalScale = value; }
+  // bool          FontAllowUserScaling;     // = false              // Allow user scaling text of individual window with CTRL+Wheel.
+  get FontAllowUserScaling(): boolean { return this.native.FontAllowUserScaling; }
+  set FontAllowUserScaling(value: boolean) { this.native.FontAllowUserScaling = value; }
+  // ImFont*       FontDefault;              // = NULL               // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
+  get FontDefault(): ImFont | null {
+    const font: Bind.reference_ImFont | null = this.native.FontDefault;
+    return (font === null) ? null : new ImFont(font);
+  }
+  set FontDefault(value: ImFont | null) {
+    this.native.FontDefault = value && value.native;
+  }
+  // ImVec2        DisplayFramebufferScale;  // = (1.0f,1.0f)        // For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.
+  get DisplayFramebufferScale(): Bind.reference_ImVec2 { return this.native.DisplayFramebufferScale; }
+
+  // Miscellaneous configuration options
+  // bool          OptMacOSXBehaviors;       // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl
+  get ConfigMacOSXBehaviors(): boolean { return this.native.ConfigMacOSXBehaviors; }
+  set ConfigMacOSXBehaviors(value: boolean) { this.native.ConfigMacOSXBehaviors = value; }
+  // bool          ConfigInputTextCursorBlink;   // = true               // Enable blinking cursor, for users who consider it annoying.
+  get ConfigInputTextCursorBlink(): boolean { return this.native.ConfigInputTextCursorBlink; }
+  set ConfigInputTextCursorBlink(value: boolean) { this.native.ConfigInputTextCursorBlink = value; }
+  // bool        ConfigDragClickToInputText;     // = false          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.
+  get ConfigDragClickToInputText(): boolean { return this.native.ConfigDragClickToInputText; }
+  set ConfigDragClickToInputText(value: boolean) { this.native.ConfigDragClickToInputText = value; }
+  // bool          ConfigWindowsResizeFromEdges; // = false          // [BETA] Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be the ImGuiWindowFlags_ResizeFromAnySide flag)
+  get ConfigWindowsResizeFromEdges(): boolean { return this.native.ConfigWindowsResizeFromEdges; }
+  set ConfigWindowsResizeFromEdges(value: boolean) { this.native.ConfigWindowsResizeFromEdges = value; }
+  // bool        ConfigWindowsMoveFromTitleBarOnly;// = false        // [BETA] Set to true to only allow moving windows when clicked+dragged from the title bar. Windows without a title bar are not affected.
+  get ConfigWindowsMoveFromTitleBarOnly(): boolean { return this.native.ConfigWindowsMoveFromTitleBarOnly; }
+  set ConfigWindowsMoveFromTitleBarOnly(value: boolean) { this.native.ConfigWindowsMoveFromTitleBarOnly = value; }
+  // float       ConfigMemoryCompactTimer;       // = 60.0f          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0f to disable.
+  get ConfigMemoryCompactTimer(): number { return this.native.ConfigMemoryCompactTimer; }
+  set ConfigMemoryCompactTimer(value: number) { this.native.ConfigMemoryCompactTimer = value; }
+
+  //------------------------------------------------------------------
+  // Settings (User Functions)
+  //------------------------------------------------------------------
+
+  // Optional: Platform/Renderer back-end name (informational only! will be displayed in About Window) + User data for back-end/wrappers to store their own stuff.
+  // const char* BackendPlatformName;            // = NULL
+  get BackendPlatformName(): string | null { return this.native.BackendPlatformName; }
+  set BackendPlatformName(value: string | null) { this.native.BackendPlatformName = value; }
+  // const char* BackendRendererName;            // = NULL
+  get BackendRendererName(): string | null { return this.native.BackendRendererName; }
+  set BackendRendererName(value: string | null) { this.native.BackendRendererName = value; }
+  // void*       BackendPlatformUserData;        // = NULL
+  get BackendPlatformUserData(): string | null { return this.native.BackendPlatformUserData; }
+  set BackendPlatformUserData(value: string | null) { this.native.BackendPlatformUserData = value; }
+  // void*       BackendRendererUserData;        // = NULL
+  get BackendRendererUserData(): string | null { return this.native.BackendRendererUserData; }
+  set BackendRendererUserData(value: string | null) { this.native.BackendRendererUserData = value; }
+  // void*       BackendLanguageUserData;        // = NULL
+  get BackendLanguageUserData(): string | null { return this.native.BackendLanguageUserData; }
+  set BackendLanguageUserData(value: string | null) { this.native.BackendLanguageUserData = value; }
+
+  // Optional: access OS clipboard
+  // (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
+  // const char* (*GetClipboardTextFn)(void* user_data);
+  get GetClipboardTextFn(): ((user_data: any) => string) | null { return this.native.GetClipboardTextFn; }
+  set GetClipboardTextFn(value: ((user_data: any) => string) | null) { this.native.GetClipboardTextFn = value; }
+  // void        (*SetClipboardTextFn)(void* user_data, const char* text);
+  get SetClipboardTextFn(): ((user_data: any, text: string) => void) | null { return this.native.SetClipboardTextFn; }
+  set SetClipboardTextFn(value: ((user_data: any, text: string) => void) | null) { this.native.SetClipboardTextFn = value; }
+  // void*       ClipboardUserData;
+  get ClipboardUserData(): any { return this.native.ClipboardUserData; }
+  set ClipboardUserData(value: any) { this.native.ClipboardUserData = value; }
+
+  // Optional: override memory allocations. MemFreeFn() may be called with a NULL pointer.
+  // (default to posix malloc/free)
+  // void*       (*MemAllocFn)(size_t sz);
+  // void        (*MemFreeFn)(void* ptr);
+
+  // Optional: notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME in Windows)
+  // (default to use native imm32 api on Windows)
+  // void        (*ImeSetInputScreenPosFn)(int x, int y);
+  // void*       ImeWindowHandle;            // (Windows) Set this to your HWND to get automatic IME cursor positioning.
+
+  //------------------------------------------------------------------
+  // Input - Fill before calling NewFrame()
+  //------------------------------------------------------------------
+
+  // ImVec2      MousePos;                   // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)
+  get MousePos(): Bind.reference_ImVec2 { return this.native.MousePos; }
+  // bool        MouseDown[5];               // Mouse buttons: left, right, middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
+  public MouseDown: boolean[] = new Proxy([], {
+    get: (target: boolean[], key: PropertyKey): number | boolean => {
+      if (key === "length") { return 5; }
+      return this.native._getAt_MouseDown(Number(key));
+    },
+    set: (target: boolean[], key: PropertyKey, value: boolean): boolean => {
+      return this.native._setAt_MouseDown(Number(key), value);
+    },
+  });
+  // float       MouseWheel;                 // Mouse wheel: 1 unit scrolls about 5 lines text.
+  public get MouseWheel(): number { return this.native.MouseWheel; }
+  public set MouseWheel(value: number) { this.native.MouseWheel = value; }
+  // float       MouseWheelH;                    // Mouse wheel (Horizontal). Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.
+  public get MouseWheelH(): number { return this.native.MouseWheelH; }
+  public set MouseWheelH(value: number) { this.native.MouseWheelH = value; }
+  // bool        MouseDrawCursor;            // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).
+  get MouseDrawCursor(): boolean { return this.native.MouseDrawCursor; } set MouseDrawCursor(value: boolean) { this.native.MouseDrawCursor = value; }
+  // bool        KeyCtrl;                    // Keyboard modifier pressed: Control
+  get KeyCtrl(): boolean { return this.native.KeyCtrl; } set KeyCtrl(value: boolean) { this.native.KeyCtrl = value; }
+  // bool        KeyShift;                   // Keyboard modifier pressed: Shift
+  get KeyShift(): boolean { return this.native.KeyShift; } set KeyShift(value: boolean) { this.native.KeyShift = value; }
+  // bool        KeyAlt;                     // Keyboard modifier pressed: Alt
+  get KeyAlt(): boolean { return this.native.KeyAlt; } set KeyAlt(value: boolean) { this.native.KeyAlt = value; }
+  // bool        KeySuper;                   // Keyboard modifier pressed: Cmd/Super/Windows
+  get KeySuper(): boolean { return this.native.KeySuper; } set KeySuper(value: boolean) { this.native.KeySuper = value; }
+  // bool        KeysDown[512];              // Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)
+  public KeysDown: boolean[] = new Proxy([], {
+    get: (target: boolean[], key: PropertyKey): number | boolean => {
+      if (key === "length") { return 512; }
+      return this.native._getAt_KeysDown(Number(key));
+    },
+    set: (target: boolean[], key: PropertyKey, value: boolean): boolean => {
+      return this.native._setAt_KeysDown(Number(key), value);
+    },
+  });
+  // float       NavInputs[ImGuiNavInput_COUNT]; // Gamepad inputs (keyboard keys will be auto-mapped and be written here by ImGui::NewFrame)
+  public NavInputs: number[] = new Proxy([], {
+    get: (target: number[], key: PropertyKey): number => {
+      if (key === "length") { return ImGuiNavInput.COUNT; }
+      return this.native._getAt_NavInputs(Number(key));
+    },
+    set: (target: number[], key: PropertyKey, value: number): boolean => {
+      return this.native._setAt_NavInputs(Number(key), value);
+    },
+  });
+
+  // Functions
+  // IMGUI_API void AddInputCharacter(ImWchar c);                        // Add new character into InputCharacters[]
+  public AddInputCharacter(c: number): void { this.native.AddInputCharacter(c); }
+  // IMGUI_API void  AddInputCharacterUTF16(ImWchar16 c);        // Queue new character input from an UTF-16 character, it can be a surrogate
+  public AddInputCharacterUTF16(c: number): void { this.native.AddInputCharacterUTF16(c); }
+  // IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);      // Add new characters into InputCharacters[] from an UTF-8 string
+  public AddInputCharactersUTF8(utf8_chars: string): void { this.native.AddInputCharactersUTF8(utf8_chars); }
+  // inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   // Clear the text input buffer manually
+  public ClearInputCharacters(): void { this.native.ClearInputCharacters(); }
+
+  //------------------------------------------------------------------
+  // Output - Retrieve after calling NewFrame()
+  //------------------------------------------------------------------
+
+  // bool        WantCaptureMouse;           // When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application. This is set by ImGui when it wants to use your mouse (e.g. unclicked mouse is hovering a window, or a widget is active).
+  get WantCaptureMouse(): boolean { return this.native.WantCaptureMouse; } set WantCaptureMouse(value: boolean) { this.native.WantCaptureMouse = value; }
+  // bool        WantCaptureKeyboard;        // When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application. This is set by ImGui when it wants to use your keyboard inputs.
+  get WantCaptureKeyboard(): boolean { return this.native.WantCaptureKeyboard; } set WantCaptureKeyboard(value: boolean) { this.native.WantCaptureKeyboard = value; }
+  // bool        WantTextInput;              // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
+  get WantTextInput(): boolean { return this.native.WantTextInput; } set WantTextInput(value: boolean) { this.native.WantTextInput = value; }
+  // bool        WantSetMousePos;              // [BETA-NAV] MousePos has been altered, back-end should reposition mouse on next frame. Set only when 'NavMovesMouse=true'.
+  get WantSetMousePos(): boolean { return this.native.WantSetMousePos; } set WantSetMousePos(value: boolean) { this.native.WantSetMousePos = value; }
+  // bool        WantSaveIniSettings;        // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need to clear io.WantSaveIniSettings yourself.
+  get WantSaveIniSettings(): boolean { return this.native.WantSaveIniSettings; } set WantSaveIniSettings(value: boolean) { this.native.WantSaveIniSettings = value; }
+  // bool        NavActive;                  // Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
+  get NavActive(): boolean { return this.native.NavActive; } set NavActive(value: boolean) { this.native.NavActive = value; }
+  // bool        NavVisible;                 // Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).
+  get NavVisible(): boolean { return this.native.NavVisible; } set NavVisible(value: boolean) { this.native.NavVisible = value; }
+  // float       Framerate;                  // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames
+  get Framerate(): number { return this.native.Framerate; }
+  // int         MetricsRenderVertices;      // Vertices output during last call to Render()
+  get MetricsRenderVertices(): number { return this.native.MetricsRenderVertices; }
+  // int         MetricsRenderIndices;       // Indices output during last call to Render() = number of triangles * 3
+  get MetricsRenderIndices(): number { return this.native.MetricsRenderIndices; }
+  // int         MetricsRenderWindows;       // Number of visible windows
+  get MetricsRenderWindows(): number { return this.native.MetricsRenderWindows; }
+  // int         MetricsActiveWindows;       // Number of visible root windows (exclude child windows)
+  get MetricsActiveWindows(): number { return this.native.MetricsActiveWindows; }
+  // int         MetricsActiveAllocations;   // Number of active allocations, updated by MemAlloc/MemFree based on current context. May be off if you have multiple imgui contexts.
+  get MetricsActiveAllocations(): number { return this.native.MetricsActiveAllocations; }
+  // ImVec2      MouseDelta;                 // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.
+  get MouseDelta(): Readonly<Bind.reference_ImVec2> { return this.native.MouseDelta; }
+
+  //------------------------------------------------------------------
+  // [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed!
+  //------------------------------------------------------------------
+
+  // ImGuiKeyModFlags KeyMods;                   // Key mods flags (same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags), updated by NewFrame()
+  // ImVec2      MousePosPrev;               // Previous mouse position temporary storage (nb: not for public use, set to MousePos in NewFrame())
+  // ImVec2      MouseClickedPos[5];         // Position at time of clicking
+  public MouseClickedPos: Array<Readonly<Bind.reference_ImVec2>> = new Proxy([], {
+    get: (target: Array<Readonly<Bind.reference_ImVec2>>, key: PropertyKey): number | Readonly<Bind.reference_ImVec2> => {
+      if (key === "length") { return 5; }
+      return this.native._getAt_MouseClickedPos(Number(key));
+    },
+  });
+  // float       MouseClickedTime[5];        // Time of last click (used to figure out double-click)
+  // bool        MouseClicked[5];            // Mouse button went from !Down to Down
+  // bool        MouseDoubleClicked[5];      // Has mouse button been double-clicked?
+  // bool        MouseReleased[5];           // Mouse button went from Down to !Down
+  // bool        MouseDownOwned[5];          // Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.
+  // float       MouseDownDuration[5];       // Duration the mouse button has been down (0.0f == just clicked)
+  public MouseDownDuration: number[] = new Proxy([], {
+    get: (target: number[], key: PropertyKey): number => {
+      if (key === "length") { return 5; }
+      return this.native._getAt_MouseDownDuration(Number(key));
+    },
+  });
+  // float       MouseDownDurationPrev[5];   // Previous time the mouse button has been down
+  // ImVec2      MouseDragMaxDistanceAbs[5]; // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
+  // float       MouseDragMaxDistanceSqr[5]; // Squared maximum distance of how much mouse has traveled from the clicking point
+  // float       KeysDownDuration[512];      // Duration the keyboard key has been down (0.0f == just pressed)
+  public KeysDownDuration: number[] = new Proxy([], {
+    get: (target: number[], key: PropertyKey): number => {
+      if (key === "length") { return 512; }
+      return this.native._getAt_KeysDownDuration(Number(key));
+    },
+  });
+  // float       KeysDownDurationPrev[512];  // Previous duration the key has been down
+  // float       NavInputsDownDuration[ImGuiNavInput_COUNT];
+  public NavInputsDownDuration: number[] = new Proxy([], {
+    get: (target: number[], key: PropertyKey): number => {
+      if (key === "length") { return ImGuiNavInput.COUNT; }
+      return this.native._getAt_NavInputsDownDuration(Number(key));
+    },
+  });
+  // float       NavInputsDownDurationPrev[ImGuiNavInput_COUNT];
+  // float       PenPressure;                    // Touch/Pen pressure (0.0f to 1.0f, should be >0.0f only when MouseDown[0] == true). Helper storage currently unused by Dear ImGui.
+  // ImWchar16   InputQueueSurrogate;            // For AddInputCharacterUTF16
+  // ImVector<ImWchar> InputQueueCharacters;     // Queue of _characters_ input (obtained by platform backend). Fill using AddInputCharacter() helper.
 
-    // IMGUI_API   ImGuiIO();
+  // IMGUI_API   ImGuiIO();
 }
 
 // Context creation and access
@@ -3029,57 +2984,57 @@ export class ImGuiIO
 // IMGUI_API ImGuiContext* GetCurrentContext();
 // IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);
 export class ImGuiContext {
-    public static current_ctx: ImGuiContext | null = null;
-    public static getTexture(index: number): ImTextureID | null {
-        if (ImGuiContext.current_ctx === null) { throw new Error(); }
-        return ImGuiContext.current_ctx._getTexture(index);
-    }
-    public static setTexture(texture: ImTextureID | null): number {
-        if (ImGuiContext.current_ctx === null) { throw new Error(); }
-        return ImGuiContext.current_ctx._setTexture(texture);
-    }
-
-    private static textures: Array<ImTextureID | null> = [];
-    constructor(public readonly native: Bind.WrapImGuiContext) {}
-    private _getTexture(index: number): ImTextureID | null {
-        return ImGuiContext.textures[index] || null;
-    }
-    private _setTexture(texture: ImTextureID | null): number {
-        let index = ImGuiContext.textures.indexOf(texture);
-        if (index === -1) {
-            for (let i = 0; i < ImGuiContext.textures.length; ++i) {
-                if (ImGuiContext.textures[i] === null) {
-                    ImGuiContext.textures[i] = texture;
-                    return i;
-                }
-            }
-            index = ImGuiContext.textures.length;
-            ImGuiContext.textures.push(texture);
+  public static current_ctx: ImGuiContext | null = null;
+  public static getTexture(index: number): ImTextureID | null {
+    if (ImGuiContext.current_ctx === null) { throw new Error(); }
+    return ImGuiContext.current_ctx._getTexture(index);
+  }
+  public static setTexture(texture: ImTextureID | null): number {
+    if (ImGuiContext.current_ctx === null) { throw new Error(); }
+    return ImGuiContext.current_ctx._setTexture(texture);
+  }
+
+  private static textures: Array<ImTextureID | null> = [];
+  constructor(public readonly native: Bind.WrapImGuiContext) {}
+  private _getTexture(index: number): ImTextureID | null {
+    return ImGuiContext.textures[index] || null;
+  }
+  private _setTexture(texture: ImTextureID | null): number {
+    let index = ImGuiContext.textures.indexOf(texture);
+    if (index === -1) {
+      for (let i = 0; i < ImGuiContext.textures.length; ++i) {
+        if (ImGuiContext.textures[i] === null) {
+          ImGuiContext.textures[i] = texture;
+          return i;
         }
-        return index;
+      }
+      index = ImGuiContext.textures.length;
+      ImGuiContext.textures.push(texture);
     }
+    return index;
+  }
 }
 export function CreateContext(shared_font_atlas: ImFontAtlas | null = null): ImGuiContext | null {
-    const ctx: ImGuiContext = new ImGuiContext(bind.CreateContext(shared_font_atlas !== null ? shared_font_atlas.native : null));
-    if (ImGuiContext.current_ctx === null) {
-        ImGuiContext.current_ctx = ctx;
-    }
-    return ctx;
+  const ctx: ImGuiContext = new ImGuiContext(bind.CreateContext(shared_font_atlas !== null ? shared_font_atlas.native : null));
+  if (ImGuiContext.current_ctx === null) {
+    ImGuiContext.current_ctx = ctx;
+  }
+  return ctx;
 }
 export function DestroyContext(ctx: ImGuiContext | null = null): void {
-    if (ctx === null) {
-        ctx = ImGuiContext.current_ctx;
-        ImGuiContext.current_ctx = null;
-    }
-    bind.DestroyContext((ctx === null) ? null : ctx.native);
+  if (ctx === null) {
+    ctx = ImGuiContext.current_ctx;
+    ImGuiContext.current_ctx = null;
+  }
+  bind.DestroyContext((ctx === null) ? null : ctx.native);
 }
 export function GetCurrentContext(): ImGuiContext | null {
-    // const ctx_native: Bind.ImGuiContext | null = bind.GetCurrentContext();
-    return ImGuiContext.current_ctx;
+  // const ctx_native: Bind.ImGuiContext | null = bind.GetCurrentContext();
+  return ImGuiContext.current_ctx;
 }
 export function SetCurrentContext(ctx: ImGuiContext | null): void {
-    bind.SetCurrentContext((ctx === null) ? null : ctx.native);
-    ImGuiContext.current_ctx = ctx;
+  bind.SetCurrentContext((ctx === null) ? null : ctx.native);
+  ImGuiContext.current_ctx = ctx;
 }
 
 // Main
@@ -3095,8 +3050,8 @@ export function NewFrame(): void { bind.NewFrame(); }
 export function EndFrame(): void { bind.EndFrame(); }
 export function Render(): void { bind.Render(); }
 export function GetDrawData(): ImDrawData | null {
-    const draw_data: Bind.reference_ImDrawData | null = bind.GetDrawData();
-    return (draw_data === null) ? null : new ImDrawData(draw_data);
+  const draw_data: Bind.reference_ImDrawData | null = bind.GetDrawData();
+  return (draw_data === null) ? null : new ImDrawData(draw_data);
 }
 
 // Demo, Debug, Information
@@ -3111,40 +3066,40 @@ export function GetDrawData(): ImDrawData | null {
 
 export function ShowDemoWindow(p_open: Bind.ImScalar<boolean> | null = null): void { bind.ShowDemoWindow(p_open); }
 export function ShowMetricsWindow(p_open: Bind.ImScalar<boolean> | Bind.ImAccess<boolean> | null = null): void {
-    if (p_open === null) {
-        bind.ShowMetricsWindow(null);
-    } else if (Array.isArray(p_open)) {
-        bind.ShowMetricsWindow(p_open);
-    } else {
-        const ref_open: Bind.ImScalar<boolean> = [ p_open() ];
-        bind.ShowMetricsWindow(ref_open);
-        p_open(ref_open[0]);
-    }
+  if (p_open === null) {
+    bind.ShowMetricsWindow(null);
+  } else if (Array.isArray(p_open)) {
+    bind.ShowMetricsWindow(p_open);
+  } else {
+    const ref_open: Bind.ImScalar<boolean> = [p_open()];
+    bind.ShowMetricsWindow(ref_open);
+    p_open(ref_open[0]);
+  }
 }
 export function ShowAboutWindow(p_open: Bind.ImScalar<boolean> | Bind.ImAccess<boolean> | null = null): void {
-    if (p_open === null) {
-        bind.ShowAboutWindow(null);
-    } else if (Array.isArray(p_open)) {
-        bind.ShowAboutWindow(p_open);
-    } else {
-        const ref_open: Bind.ImScalar<boolean> = [ p_open() ];
-        bind.ShowAboutWindow(ref_open);
-        p_open(ref_open[0]);
-    }
+  if (p_open === null) {
+    bind.ShowAboutWindow(null);
+  } else if (Array.isArray(p_open)) {
+    bind.ShowAboutWindow(p_open);
+  } else {
+    const ref_open: Bind.ImScalar<boolean> = [p_open()];
+    bind.ShowAboutWindow(ref_open);
+    p_open(ref_open[0]);
+  }
 }
 export function ShowStyleEditor(ref: ImGuiStyle | null = null): void {
-    if (ref === null) {
-        bind.ShowStyleEditor(null);
-    } else if (ref.internal instanceof bind.ImGuiStyle) {
-        bind.ShowStyleEditor(ref.internal);
-    } else {
-        const native = new bind.ImGuiStyle();
-        const wrap = new ImGuiStyle(native);
-        wrap.Copy(ref);
-        bind.ShowStyleEditor(native);
-        ref.Copy(wrap);
-        native.delete();
-    }
+  if (ref === null) {
+    bind.ShowStyleEditor(null);
+  } else if (ref.internal instanceof bind.ImGuiStyle) {
+    bind.ShowStyleEditor(ref.internal);
+  } else {
+    const native = new bind.ImGuiStyle();
+    const wrap = new ImGuiStyle(native);
+    wrap.Copy(ref);
+    bind.ShowStyleEditor(native);
+    ref.Copy(wrap);
+    native.delete();
+  }
 }
 export function ShowStyleSelector(label: string): boolean { return bind.ShowStyleSelector(label); }
 export function ShowFontSelector(label: string): void { bind.ShowFontSelector(label); }
@@ -3157,46 +3112,46 @@ export function GetVersion(): string { return bind.GetVersion(); }
 // IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);   // best used with borders and a custom, thicker font
 // IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL); // classic imgui style
 export function StyleColorsDark(dst: ImGuiStyle | null = null): void {
-    if (dst === null) {
-        bind.StyleColorsDark(null);
-    } else if (dst.internal instanceof bind.ImGuiStyle) {
-        bind.StyleColorsDark(dst.internal);
-    } else {
-        const native = new bind.ImGuiStyle();
-        const wrap = new ImGuiStyle(native);
-        wrap.Copy(dst);
-        bind.StyleColorsDark(native);
-        dst.Copy(wrap);
-        native.delete();
-    }
+  if (dst === null) {
+    bind.StyleColorsDark(null);
+  } else if (dst.internal instanceof bind.ImGuiStyle) {
+    bind.StyleColorsDark(dst.internal);
+  } else {
+    const native = new bind.ImGuiStyle();
+    const wrap = new ImGuiStyle(native);
+    wrap.Copy(dst);
+    bind.StyleColorsDark(native);
+    dst.Copy(wrap);
+    native.delete();
+  }
 }
 export function StyleColorsLight(dst: ImGuiStyle | null = null): void {
-    if (dst === null) {
-        bind.StyleColorsLight(null);
-    } else if (dst.internal instanceof bind.ImGuiStyle) {
-        bind.StyleColorsLight(dst.internal);
-    } else {
-        const native = new bind.ImGuiStyle();
-        const wrap = new ImGuiStyle(native);
-        wrap.Copy(dst);
-        bind.StyleColorsLight(native);
-        dst.Copy(wrap);
-        native.delete();
-    }
+  if (dst === null) {
+    bind.StyleColorsLight(null);
+  } else if (dst.internal instanceof bind.ImGuiStyle) {
+    bind.StyleColorsLight(dst.internal);
+  } else {
+    const native = new bind.ImGuiStyle();
+    const wrap = new ImGuiStyle(native);
+    wrap.Copy(dst);
+    bind.StyleColorsLight(native);
+    dst.Copy(wrap);
+    native.delete();
+  }
 }
 export function StyleColorsClassic(dst: ImGuiStyle | null = null): void {
-    if (dst === null) {
-        bind.StyleColorsClassic(null);
-    } else if (dst.internal instanceof bind.ImGuiStyle) {
-        bind.StyleColorsClassic(dst.internal);
-    } else {
-        const native = new bind.ImGuiStyle();
-        const wrap = new ImGuiStyle(native);
-        wrap.Copy(dst);
-        bind.StyleColorsClassic(native);
-        dst.Copy(wrap);
-        native.delete();
-    }
+  if (dst === null) {
+    bind.StyleColorsClassic(null);
+  } else if (dst.internal instanceof bind.ImGuiStyle) {
+    bind.StyleColorsClassic(dst.internal);
+  } else {
+    const native = new bind.ImGuiStyle();
+    const wrap = new ImGuiStyle(native);
+    wrap.Copy(dst);
+    bind.StyleColorsClassic(native);
+    dst.Copy(wrap);
+    native.delete();
+  }
 }
 
 // Windows
@@ -3214,16 +3169,16 @@ export function StyleColorsClassic(dst: ImGuiStyle | null = null): void {
 // IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);
 // IMGUI_API void          End();
 export function Begin(name: string, open: Bind.ImScalar<boolean> | Bind.ImAccess<boolean> | null = null, flags: ImGuiWindowFlags = 0): boolean {
-    if (open === null) {
-        return bind.Begin(name, null, flags);
-    } else if (Array.isArray(open)) {
-        return bind.Begin(name, open, flags);
-    } else {
-        const ref_open: Bind.ImScalar<boolean> = [ open() ];
-        const opened: boolean = bind.Begin(name, ref_open, flags);
-        open(ref_open[0]);
-        return opened;
-    }
+  if (open === null) {
+    return bind.Begin(name, null, flags);
+  } else if (Array.isArray(open)) {
+    return bind.Begin(name, open, flags);
+  } else {
+    const ref_open: Bind.ImScalar<boolean> = [open()];
+    const opened: boolean = bind.Begin(name, ref_open, flags);
+    open(ref_open[0]);
+    return opened;
+  }
 }
 export function End(): void { bind.End(); }
 
@@ -3239,7 +3194,7 @@ export function End(): void { bind.End(); }
 // IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0, 0), bool border = false, ImGuiWindowFlags flags = 0);
 // IMGUI_API void          EndChild();
 export function BeginChild(id: string | ImGuiID, size: Readonly<Bind.interface_ImVec2> = ImVec2.ZERO, border: boolean = false, flags: ImGuiWindowFlags = 0): boolean {
-    return bind.BeginChild(id, size, border, flags);
+  return bind.BeginChild(id, size, border, flags);
 }
 export function EndChild(): void { bind.EndChild(); }
 
@@ -3286,46 +3241,46 @@ export function SetNextWindowSize(pos: Readonly<Bind.interface_ImVec2>, cond: Im
 export function SetNextWindowSizeConstraints(size_min: Readonly<Bind.interface_ImVec2>, size_max: Readonly<Bind.interface_ImVec2>): void;
 export function SetNextWindowSizeConstraints<T>(size_min: Readonly<Bind.interface_ImVec2>, size_max: Readonly<Bind.interface_ImVec2>, custom_callback: ImGuiSizeCallback<T>, custom_callback_data?: T): void;
 export function SetNextWindowSizeConstraints<T>(size_min: Readonly<Bind.interface_ImVec2>, size_max: Readonly<Bind.interface_ImVec2>, custom_callback: ImGuiSizeCallback<T | null> | null = null, custom_callback_data: T | null = null): void {
-    if (custom_callback) {
-        bind.SetNextWindowSizeConstraints(size_min, size_max, (data: Bind.reference_ImGuiSizeCallbackData): void => {
-            custom_callback(new ImGuiSizeCallbackData(data, custom_callback_data));
-        }, null);
-    } else {
-        bind.SetNextWindowSizeConstraints(size_min, size_max, null, null);
-    }
+  if (custom_callback) {
+    bind.SetNextWindowSizeConstraints(size_min, size_max, (data: Bind.reference_ImGuiSizeCallbackData): void => {
+      custom_callback(new ImGuiSizeCallbackData(data, custom_callback_data));
+    }, null);
+  } else {
+    bind.SetNextWindowSizeConstraints(size_min, size_max, null, null);
+  }
 }
 export function SetNextWindowContentSize(size: Readonly<Bind.interface_ImVec2>): void { bind.SetNextWindowContentSize(size); }
 export function SetNextWindowCollapsed(collapsed: boolean, cond: ImGuiCond = 0): void { bind.SetNextWindowCollapsed(collapsed, cond); }
 export function SetNextWindowFocus(): void { bind.SetNextWindowFocus(); }
 export function SetNextWindowBgAlpha(alpha: number): void { bind.SetNextWindowBgAlpha(alpha); }
 export function SetWindowPos(name_or_pos: string | Readonly<Bind.interface_ImVec2>, pos_or_cond: Readonly<Bind.interface_ImVec2> | ImGuiCond = 0, cond: ImGuiCond = 0): void {
-    if (typeof(name_or_pos) === "string") {
-        bind.SetWindowNamePos(name_or_pos, pos_or_cond as Readonly<Bind.interface_ImVec2>, cond);
-        return;
-    } else {
-        bind.SetWindowPos(name_or_pos, pos_or_cond as ImGuiCond);
-    }
+  if (typeof (name_or_pos) === "string") {
+    bind.SetWindowNamePos(name_or_pos, pos_or_cond as Readonly<Bind.interface_ImVec2>, cond);
+    return;
+  } else {
+    bind.SetWindowPos(name_or_pos, pos_or_cond as ImGuiCond);
+  }
 }
 export function SetWindowSize(name_or_size: string | Readonly<Bind.interface_ImVec2>, size_or_cond: Readonly<Bind.interface_ImVec2> | ImGuiCond = 0, cond: ImGuiCond = 0): void {
-    if (typeof(name_or_size) === "string") {
-        bind.SetWindowNamePos(name_or_size, size_or_cond as Readonly<Bind.interface_ImVec2>, cond);
-    } else {
-        bind.SetWindowSize(name_or_size, size_or_cond as ImGuiCond);
-    }
+  if (typeof (name_or_size) === "string") {
+    bind.SetWindowNamePos(name_or_size, size_or_cond as Readonly<Bind.interface_ImVec2>, cond);
+  } else {
+    bind.SetWindowSize(name_or_size, size_or_cond as ImGuiCond);
+  }
 }
 export function SetWindowCollapsed(name_or_collapsed: string | boolean, collapsed_or_cond: boolean | ImGuiCond = 0, cond: ImGuiCond = 0): void {
-    if (typeof(name_or_collapsed) === "string") {
-        bind.SetWindowNameCollapsed(name_or_collapsed, collapsed_or_cond as boolean, cond);
-    } else {
-        bind.SetWindowCollapsed(name_or_collapsed, collapsed_or_cond as ImGuiCond);
-    }
+  if (typeof (name_or_collapsed) === "string") {
+    bind.SetWindowNameCollapsed(name_or_collapsed, collapsed_or_cond as boolean, cond);
+  } else {
+    bind.SetWindowCollapsed(name_or_collapsed, collapsed_or_cond as ImGuiCond);
+  }
 }
 export function SetWindowFocus(name?: string): void {
-    if (typeof(name) === "string") {
-        bind.SetWindowNameFocus(name);
-    } else {
-        bind.SetWindowFocus();
-    }
+  if (typeof (name) === "string") {
+    bind.SetWindowNameFocus(name);
+  } else {
+    bind.SetWindowFocus();
+  }
 }
 export function SetWindowFontScale(scale: number): void { bind.SetWindowFontScale(scale); }
 
@@ -3381,11 +3336,11 @@ export function SetScrollFromPosY(pos_y: number, center_y_ratio: number = 0.5):
 export function PushFont(font: ImFont | null): void { bind.PushFont(font ? font.native : null); }
 export function PopFont(): void { bind.PopFont(); }
 export function PushStyleColor(idx: ImGuiCol, col: Bind.ImU32 | Readonly<Bind.interface_ImVec4> | Readonly<ImColor>): void {
-    if (col instanceof ImColor) {
-        bind.PushStyleColor(idx, col.Value);
-    } else {
-        bind.PushStyleColor(idx, col as (Bind.ImU32 | Readonly<Bind.interface_ImVec4>));
-    }
+  if (col instanceof ImColor) {
+    bind.PushStyleColor(idx, col.Value);
+  } else {
+    bind.PushStyleColor(idx, col as (Bind.ImU32 | Readonly<Bind.interface_ImVec4>));
+  }
 }
 export function PopStyleColor(count: number = 1): void { bind.PopStyleColor(count); }
 export function PushStyleVar(idx: ImGuiStyleVar, val: number | Readonly<Bind.interface_ImVec2>): void { bind.PushStyleVar(idx, val); }
@@ -3424,25 +3379,25 @@ export function GetColorU32(idx: ImGuiCol, alpha_mul?: number): Bind.ImU32;
 export function GetColorU32(col: Readonly<Bind.interface_ImVec4>): Bind.ImU32;
 export function GetColorU32(col: Bind.ImU32): Bind.ImU32;
 export function GetColorU32(...args: any[]): Bind.ImU32 {
-    if (args.length === 1) {
-        if (typeof(args[0]) === "number") {
-            if (0 <= args[0] && args[0] < ImGuiCol.COUNT) {
-                const idx: ImGuiCol = args[0];
-                return bind.GetColorU32_A(idx, 1.0);
-            }
-            else {
-                const col: Bind.ImU32 = args[0];
-                return bind.GetColorU32_C(col);
-            }
-        } else {
-            const col: Readonly<Bind.interface_ImVec4> = args[0];
-            return bind.GetColorU32_B(col);
-        }
-    } else {
+  if (args.length === 1) {
+    if (typeof (args[0]) === "number") {
+      if (0 <= args[0] && args[0] < ImGuiCol.COUNT) {
         const idx: ImGuiCol = args[0];
-        const alpha_mul: number = args[1];
-        return bind.GetColorU32_A(idx, alpha_mul);
+        return bind.GetColorU32_A(idx, 1.0);
+      }
+      else {
+        const col: Bind.ImU32 = args[0];
+        return bind.GetColorU32_C(col);
+      }
+    } else {
+      const col: Readonly<Bind.interface_ImVec4> = args[0];
+      return bind.GetColorU32_B(col);
     }
+  } else {
+    const idx: ImGuiCol = args[0];
+    const alpha_mul: number = args[1];
+    return bind.GetColorU32_A(idx, alpha_mul);
+  }
 }
 export function GetStyleColorVec4(idx: ImGuiCol): Readonly<Bind.reference_ImVec4> { return bind.GetStyleColorVec4(idx); }
 
@@ -3562,48 +3517,48 @@ export function SmallButton(label: string): boolean { return bind.SmallButton(la
 export function ArrowButton(str_id: string, dir: ImGuiDir): boolean { return bind.ArrowButton(str_id, dir); }
 export function InvisibleButton(str_id: string, size: Readonly<Bind.interface_ImVec2>, flags: ImGuiButtonFlags = 0): boolean { return bind.InvisibleButton(str_id, size, flags); }
 export function Image(user_texture_id: ImTextureID | null, size: Readonly<Bind.interface_ImVec2>, uv0: Readonly<Bind.interface_ImVec2> = ImVec2.ZERO, uv1: Readonly<Bind.interface_ImVec2> = ImVec2.UNIT, tint_col: Readonly<Bind.interface_ImVec4> = ImVec4.WHITE, border_col: Readonly<Bind.interface_ImVec4> = ImVec4.ZERO): void {
-    bind.Image(ImGuiContext.setTexture(user_texture_id), size, uv0, uv1, tint_col, border_col);
+  bind.Image(ImGuiContext.setTexture(user_texture_id), size, uv0, uv1, tint_col, border_col);
 }
 export function ImageButton(user_texture_id: ImTextureID | null, size: Readonly<Bind.interface_ImVec2> = new ImVec2(Number.MIN_SAFE_INTEGER, 0), uv0: Readonly<Bind.interface_ImVec2> = ImVec2.ZERO, uv1: Readonly<Bind.interface_ImVec2> = ImVec2.UNIT, frame_padding: number = -1, bg_col: Readonly<Bind.interface_ImVec4> = ImVec4.ZERO, tint_col: Readonly<Bind.interface_ImVec4> = ImVec4.WHITE): boolean {
-    return bind.ImageButton(ImGuiContext.setTexture(user_texture_id), size, uv0, uv1, frame_padding, bg_col, tint_col);
+  return bind.ImageButton(ImGuiContext.setTexture(user_texture_id), size, uv0, uv1, frame_padding, bg_col, tint_col);
 }
 export function Checkbox(label: string, v: Bind.ImScalar<boolean> | Bind.ImAccess<boolean>): boolean {
-    if (Array.isArray(v)) {
-        return bind.Checkbox(label, v);
-    } else {
-        const ref_v: Bind.ImScalar<boolean> = [ v() ];
-        const ret = bind.Checkbox(label, ref_v);
-        v(ref_v[0]);
-        return ret;
-    }
+  if (Array.isArray(v)) {
+    return bind.Checkbox(label, v);
+  } else {
+    const ref_v: Bind.ImScalar<boolean> = [v()];
+    const ret = bind.Checkbox(label, ref_v);
+    v(ref_v[0]);
+    return ret;
+  }
 }
 export function CheckboxFlags(label: string, flags: Bind.ImAccess<number> | Bind.ImScalar<number>, flags_value: number): boolean {
-    if (Array.isArray(flags)) {
-        return bind.CheckboxFlags(label, flags, flags_value);
-    } else {
-        const ref_flags: Bind.ImScalar<number> = [ flags() ];
-        const ret = bind.CheckboxFlags(label, ref_flags, flags_value);
-        flags(ref_flags[0]);
-        return ret;
-    }
+  if (Array.isArray(flags)) {
+    return bind.CheckboxFlags(label, flags, flags_value);
+  } else {
+    const ref_flags: Bind.ImScalar<number> = [flags()];
+    const ret = bind.CheckboxFlags(label, ref_flags, flags_value);
+    flags(ref_flags[0]);
+    return ret;
+  }
 }
 export function RadioButton(label: string, active: boolean): boolean;
 export function RadioButton(label: string, v: Bind.ImAccess<number> | Bind.ImScalar<number>, v_button: number): boolean;
 export function RadioButton(label: string, ...args: any[]): boolean {
-    if (typeof(args[0]) === "boolean") {
-        const active: boolean = args[0];
-        return bind.RadioButton_A(label, active);
-    } else {
-        const v: Bind.ImAccess<number> | Bind.ImScalar<number> = args[0];
-        const v_button: number = args[1];
-        const _v: Bind.ImScalar<number> = Array.isArray(v) ? v : [ v() ];
-        const ret = bind.RadioButton_B(label, _v, v_button);
-        if (!Array.isArray(v)) { v(_v[0]); }
-        return ret;
-    }
+  if (typeof (args[0]) === "boolean") {
+    const active: boolean = args[0];
+    return bind.RadioButton_A(label, active);
+  } else {
+    const v: Bind.ImAccess<number> | Bind.ImScalar<number> = args[0];
+    const v_button: number = args[1];
+    const _v: Bind.ImScalar<number> = Array.isArray(v) ? v : [v()];
+    const ret = bind.RadioButton_B(label, _v, v_button);
+    if (!Array.isArray(v)) { v(_v[0]); }
+    return ret;
+  }
 }
 export function ProgressBar(fraction: number, size_arg: Readonly<Bind.interface_ImVec2> = new ImVec2(-1, 0), overlay: string | null = null): void {
-    bind.ProgressBar(fraction, size_arg, overlay);
+  bind.ProgressBar(fraction, size_arg, overlay);
 }
 export function Bullet(): void { bind.Bullet(); }
 
@@ -3622,30 +3577,30 @@ export function Combo(label: string, current_item: Bind.ImAccess<number> | Bind.
 export function Combo(label: string, current_item: Bind.ImAccess<number> | Bind.ImScalar<number>, items_separated_by_zeros: string, popup_max_height_in_items?: number): boolean;
 export function Combo<T>(label: string, current_item: Bind.ImAccess<number> | Bind.ImScalar<number>, items_getter: ComboValueGetter<T>, data: T, items_count: number, popup_max_height_in_items?: number): boolean;
 export function Combo<T>(label: string, current_item: Bind.ImAccess<number> | Bind.ImScalar<number>, ...args: any[]): boolean {
-    let ret = false;
-    const _current_item: Bind.ImScalar<number> = Array.isArray(current_item) ? current_item : [ current_item() ];
-    if (Array.isArray(args[0])) {
-        const items: string[] = args[0];
-        const items_count = typeof(args[1]) === "number" ? args[1] : items.length;
-        const popup_max_height_in_items: number = typeof(args[2]) === "number" ? args[2] : -1;
-        const items_getter = (data: null, idx: number, out_text: [string]): boolean => { out_text[0] = items[idx]; return true; };
-        ret = bind.Combo(label, _current_item, items_getter, null, items_count, popup_max_height_in_items);
-    } else if (typeof(args[0]) === "string") {
-        const items_separated_by_zeros: string = args[0]
-        const popup_max_height_in_items: number = typeof(args[1]) === "number" ? args[1] : -1;
-        const items: string[] = items_separated_by_zeros.replace(/^\0+|\0+$/g, "").split("\0");
-        const items_count: number = items.length;
-        const items_getter = (data: null, idx: number, out_text: [string]): boolean => { out_text[0] = items[idx]; return true; };
-        ret = bind.Combo(label, _current_item, items_getter, null, items_count, popup_max_height_in_items);
-    } else {
-        const items_getter: (data: T, idx: number, out_text: [string]) => boolean = args[0];
-        const data: T = args[1];
-        const items_count = args[2];
-        const popup_max_height_in_items: number = typeof(args[3]) === "number" ? args[3] : -1;
-        ret = bind.Combo(label, _current_item, items_getter, data, items_count, popup_max_height_in_items);
-    }
-    if (!Array.isArray(current_item)) { current_item(_current_item[0]); }
-    return ret;
+  let ret = false;
+  const _current_item: Bind.ImScalar<number> = Array.isArray(current_item) ? current_item : [current_item()];
+  if (Array.isArray(args[0])) {
+    const items: string[] = args[0];
+    const items_count = typeof (args[1]) === "number" ? args[1] : items.length;
+    const popup_max_height_in_items: number = typeof (args[2]) === "number" ? args[2] : -1;
+    const items_getter = (data: null, idx: number, out_text: [string]): boolean => { out_text[0] = items[idx]; return true; };
+    ret = bind.Combo(label, _current_item, items_getter, null, items_count, popup_max_height_in_items);
+  } else if (typeof (args[0]) === "string") {
+    const items_separated_by_zeros: string = args[0]
+    const popup_max_height_in_items: number = typeof (args[1]) === "number" ? args[1] : -1;
+    const items: string[] = items_separated_by_zeros.replace(/^\0+|\0+$/g, "").split("\0");
+    const items_count: number = items.length;
+    const items_getter = (data: null, idx: number, out_text: [string]): boolean => { out_text[0] = items[idx]; return true; };
+    ret = bind.Combo(label, _current_item, items_getter, null, items_count, popup_max_height_in_items);
+  } else {
+    const items_getter: (data: T, idx: number, out_text: [string]) => boolean = args[0];
+    const data: T = args[1];
+    const items_count = args[2];
+    const popup_max_height_in_items: number = typeof (args[3]) === "number" ? args[3] : -1;
+    ret = bind.Combo(label, _current_item, items_getter, data, items_count, popup_max_height_in_items);
+  }
+  if (!Array.isArray(current_item)) { current_item(_current_item[0]); }
+  return ret;
 }
 
 // Widgets: Drag Sliders
@@ -3672,81 +3627,81 @@ export function Combo<T>(label: string, current_item: Bind.ImAccess<number> | Bi
 // IMGUI_API bool          DragScalar(const char* label, ImGuiDataType data_type, void* p_data, float v_speed, const void* p_min = NULL, const void* p_max = NULL, const char* format = NULL, ImGuiSliderFlags flags = 0);
 // IMGUI_API bool          DragScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed, const void* p_min = NULL, const void* p_max = NULL, const char* format = NULL, ImGuiSliderFlags flags = 0);
 export function DragFloat(label: string, v: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_speed: number = 1.0, v_min: number = 0.0, v_max: number = 0.0, display_format: string | null = "%.3f", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Scalar(v);
-    const ret = bind.DragFloat(label, _v, v_speed, v_min, v_max, display_format, flags);
-    export_Scalar(_v, v);
-    return ret;
+  const _v = import_Scalar(v);
+  const ret = bind.DragFloat(label, _v, v_speed, v_min, v_max, display_format, flags);
+  export_Scalar(_v, v);
+  return ret;
 }
 export function DragFloat2(label: string, v: XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number> | ImVec2, v_speed: number = 1.0, v_min: number = 0.0, v_max: number = 0.0, display_format: string = "%.3f", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Vector2(v);
-    const ret = bind.DragFloat2(label, _v, v_speed, v_min, v_max, display_format, flags);
-    export_Vector2(_v, v);
-    return ret;
+  const _v = import_Vector2(v);
+  const ret = bind.DragFloat2(label, _v, v_speed, v_min, v_max, display_format, flags);
+  export_Vector2(_v, v);
+  return ret;
 }
 export function DragFloat3(label: string, v: XYZ | XYZW | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_speed: number = 1.0, v_min: number = 0.0, v_max: number = 0.0, display_format: string = "%.3f", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Vector3(v);
-    const ret = bind.DragFloat3(label, _v, v_speed, v_min, v_max, display_format, flags);
-    export_Vector3(_v, v);
-    return ret;
+  const _v = import_Vector3(v);
+  const ret = bind.DragFloat3(label, _v, v_speed, v_min, v_max, display_format, flags);
+  export_Vector3(_v, v);
+  return ret;
 }
 export function DragFloat4(label: string, v: XYZW | Bind.ImTuple4<number> | ImVec4, v_speed: number = 1.0, v_min: number = 0.0, v_max: number = 0.0, display_format: string = "%.3f", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Vector4(v);
-    const ret = bind.DragFloat4(label, _v, v_speed, v_min, v_max, display_format, flags);
-    export_Vector4(_v, v);
-    return ret;
+  const _v = import_Vector4(v);
+  const ret = bind.DragFloat4(label, _v, v_speed, v_min, v_max, display_format, flags);
+  export_Vector4(_v, v);
+  return ret;
 }
 export function DragFloatRange2(label: string, v_current_min: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_current_max: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_speed: number = 1.0, v_min: number = 0.0, v_max: number = 0.0, display_format: string = "%.3f", display_format_max: string | null = null, flags: ImGuiSliderFlags = 0): boolean {
-    const _v_current_min = import_Scalar(v_current_min);
-    const _v_current_max = import_Scalar(v_current_max);
-    const ret = bind.DragFloatRange2(label, _v_current_min, _v_current_max, v_speed, v_min, v_max, display_format, display_format_max, flags);
-    export_Scalar(_v_current_min, v_current_min);
-    export_Scalar(_v_current_max, v_current_max);
-    return ret;
+  const _v_current_min = import_Scalar(v_current_min);
+  const _v_current_max = import_Scalar(v_current_max);
+  const ret = bind.DragFloatRange2(label, _v_current_min, _v_current_max, v_speed, v_min, v_max, display_format, display_format_max, flags);
+  export_Scalar(_v_current_min, v_current_min);
+  export_Scalar(_v_current_max, v_current_max);
+  return ret;
 }
 export function DragInt(label: string, v: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_speed: number = 1.0, v_min: number = 0, v_max: number = 0, format: string = "%d", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Scalar(v);
-    const ret = bind.DragInt(label, _v, v_speed, v_min, v_max, format, flags);
-    export_Scalar(_v, v);
-    return ret;
+  const _v = import_Scalar(v);
+  const ret = bind.DragInt(label, _v, v_speed, v_min, v_max, format, flags);
+  export_Scalar(_v, v);
+  return ret;
 }
 export function DragInt2(label: string, v: XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_speed: number = 1.0, v_min: number = 0, v_max: number = 0, format: string = "%d", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Vector2(v);
-    const ret = bind.DragInt2(label, _v, v_speed, v_min, v_max, format, flags);
-    export_Vector2(_v, v);
-    return ret;
+  const _v = import_Vector2(v);
+  const ret = bind.DragInt2(label, _v, v_speed, v_min, v_max, format, flags);
+  export_Vector2(_v, v);
+  return ret;
 }
 export function DragInt3(label: string, v: XYZ | XYZW | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_speed: number = 1.0, v_min: number = 0, v_max: number = 0, format: string = "%d", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Vector3(v);
-    const ret = bind.DragInt3(label, _v, v_speed, v_min, v_max, format, flags);
-    export_Vector3(_v, v);
-    return ret;
+  const _v = import_Vector3(v);
+  const ret = bind.DragInt3(label, _v, v_speed, v_min, v_max, format, flags);
+  export_Vector3(_v, v);
+  return ret;
 }
 export function DragInt4(label: string, v: XYZW | Bind.ImTuple4<number>, v_speed: number = 1.0, v_min: number = 0, v_max: number = 0, format: string = "%d", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Vector4(v);
-    const ret = bind.DragInt4(label, _v, v_speed, v_min, v_max, format, flags);
-    export_Vector4(_v, v);
-    return ret;
+  const _v = import_Vector4(v);
+  const ret = bind.DragInt4(label, _v, v_speed, v_min, v_max, format, flags);
+  export_Vector4(_v, v);
+  return ret;
 }
 export function DragIntRange2(label: string, v_current_min: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_current_max: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_speed: number = 1.0, v_min: number = 0, v_max: number = 0, format: string = "%d", format_max: string | null = null, flags: ImGuiSliderFlags = 0): boolean {
-    const _v_current_min = import_Scalar(v_current_min);
-    const _v_current_max = import_Scalar(v_current_max);
-    const ret = bind.DragIntRange2(label, _v_current_min, _v_current_max, v_speed, v_min, v_max, format, format_max, flags);
-    export_Scalar(_v_current_min, v_current_min);
-    export_Scalar(_v_current_max, v_current_max);
-    return ret;
+  const _v_current_min = import_Scalar(v_current_min);
+  const _v_current_max = import_Scalar(v_current_max);
+  const ret = bind.DragIntRange2(label, _v_current_min, _v_current_max, v_speed, v_min, v_max, format, format_max, flags);
+  export_Scalar(_v_current_min, v_current_min);
+  export_Scalar(_v_current_max, v_current_max);
+  return ret;
 }
 export function DragScalar(label: string, v: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array, v_speed: number, v_min: number | null = null, v_max: number | null = null, format: string | null = null, flags: ImGuiSliderFlags = 0): boolean {
-    if (v instanceof Int8Array) { return bind.DragScalar(label, ImGuiDataType.S8, v, v_speed, v_min, v_max, format, flags); }
-    if (v instanceof Uint8Array) { return bind.DragScalar(label, ImGuiDataType.U8, v, v_speed, v_min, v_max, format, flags); }
-    if (v instanceof Int16Array) { return bind.DragScalar(label, ImGuiDataType.S16, v, v_speed, v_min, v_max, format, flags); }
-    if (v instanceof Uint16Array) { return bind.DragScalar(label, ImGuiDataType.U16, v, v_speed, v_min, v_max, format, flags); }
-    if (v instanceof Int32Array) { return bind.DragScalar(label, ImGuiDataType.S32, v, v_speed, v_min, v_max, format, flags); }
-    if (v instanceof Uint32Array) { return bind.DragScalar(label, ImGuiDataType.U32, v, v_speed, v_min, v_max, format, flags); }
-    // if (v instanceof Int64Array) { return bind.DragScalar(label, ImGuiDataType.S64, v, v_speed, v_min, v_max, format, flags); }
-    // if (v instanceof Uint64Array) { return bind.DragScalar(label, ImGuiDataType.U64, v, v_speed, v_min, v_max, format, flags); }
-    if (v instanceof Float32Array) { return bind.DragScalar(label, ImGuiDataType.Float, v, v_speed, v_min, v_max, format, flags); }
-    if (v instanceof Float64Array) { return bind.DragScalar(label, ImGuiDataType.Double, v, v_speed, v_min, v_max, format, flags); }
-    throw new Error();
+  if (v instanceof Int8Array) { return bind.DragScalar(label, ImGuiDataType.S8, v, v_speed, v_min, v_max, format, flags); }
+  if (v instanceof Uint8Array) { return bind.DragScalar(label, ImGuiDataType.U8, v, v_speed, v_min, v_max, format, flags); }
+  if (v instanceof Int16Array) { return bind.DragScalar(label, ImGuiDataType.S16, v, v_speed, v_min, v_max, format, flags); }
+  if (v instanceof Uint16Array) { return bind.DragScalar(label, ImGuiDataType.U16, v, v_speed, v_min, v_max, format, flags); }
+  if (v instanceof Int32Array) { return bind.DragScalar(label, ImGuiDataType.S32, v, v_speed, v_min, v_max, format, flags); }
+  if (v instanceof Uint32Array) { return bind.DragScalar(label, ImGuiDataType.U32, v, v_speed, v_min, v_max, format, flags); }
+  // if (v instanceof Int64Array) { return bind.DragScalar(label, ImGuiDataType.S64, v, v_speed, v_min, v_max, format, flags); }
+  // if (v instanceof Uint64Array) { return bind.DragScalar(label, ImGuiDataType.U64, v, v_speed, v_min, v_max, format, flags); }
+  if (v instanceof Float32Array) { return bind.DragScalar(label, ImGuiDataType.Float, v, v_speed, v_min, v_max, format, flags); }
+  if (v instanceof Float64Array) { return bind.DragScalar(label, ImGuiDataType.Double, v, v_speed, v_min, v_max, format, flags); }
+  throw new Error();
 }
 
 // Widgets: Regular Sliders
@@ -3770,108 +3725,108 @@ export function DragScalar(label: string, v: Int8Array | Uint8Array | Int16Array
 // IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
 // IMGUI_API bool          VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = NULL, ImGuiSliderFlags flags = 0);
 export function SliderFloat(label: string, v: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_min: number, v_max: number, format: string = "%.3f", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Scalar(v);
-    const ret = bind.SliderFloat(label, _v, v_min, v_max, format, flags);
-    export_Scalar(_v, v);
-    return ret;
+  const _v = import_Scalar(v);
+  const ret = bind.SliderFloat(label, _v, v_min, v_max, format, flags);
+  export_Scalar(_v, v);
+  return ret;
 }
 export function SliderFloat2(label: string, v: XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number> | Bind.interface_ImVec2, v_min: number, v_max: number, format: string = "%.3f", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Vector2(v);
-    const ret = bind.SliderFloat2(label, _v, v_min, v_max, format, flags);
-    export_Vector2(_v, v);
-    return ret;
+  const _v = import_Vector2(v);
+  const ret = bind.SliderFloat2(label, _v, v_min, v_max, format, flags);
+  export_Vector2(_v, v);
+  return ret;
 }
 export function SliderFloat3(label: string, v: XYZ | XYZW | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_min: number, v_max: number, format: string = "%.3f", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Vector3(v);
-    const ret = bind.SliderFloat3(label, _v, v_min, v_max, format, flags);
-    export_Vector3(_v, v);
-    return ret;
+  const _v = import_Vector3(v);
+  const ret = bind.SliderFloat3(label, _v, v_min, v_max, format, flags);
+  export_Vector3(_v, v);
+  return ret;
 }
 export function SliderFloat4(label: string, v: XYZW | Bind.ImTuple4<number> | XYZW, v_min: number, v_max: number, format: string = "%.3f", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Vector4(v);
-    const ret = bind.SliderFloat4(label, _v, v_min, v_max, format, flags);
-    export_Vector4(_v, v);
-    return ret;
+  const _v = import_Vector4(v);
+  const ret = bind.SliderFloat4(label, _v, v_min, v_max, format, flags);
+  export_Vector4(_v, v);
+  return ret;
 }
 export function SliderAngle(label: string, v_rad: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_degrees_min: number = -360.0, v_degrees_max: number = +360.0, format: string = "%.0f deg", flags: ImGuiSliderFlags = 0): boolean {
-    const _v_rad = import_Scalar(v_rad);
-    const ret = bind.SliderAngle(label, _v_rad, v_degrees_min, v_degrees_max, format, flags);
-    export_Scalar(_v_rad, v_rad);
-    return ret;
+  const _v_rad = import_Scalar(v_rad);
+  const ret = bind.SliderAngle(label, _v_rad, v_degrees_min, v_degrees_max, format, flags);
+  export_Scalar(_v_rad, v_rad);
+  return ret;
 }
 export function SliderAngle3(label: string, v_rad: XYZ | XYZW | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_degrees_min: number = -360.0, v_degrees_max: number = +360.0, format: string = "%.0f deg", flags: ImGuiSliderFlags = 0): boolean {
-    const _v_rad = import_Vector3(v_rad);
-    _v_rad[0] = Math.floor(_v_rad[0] * 180 / Math.PI);
-    _v_rad[1] = Math.floor(_v_rad[1] * 180 / Math.PI);
-    _v_rad[2] = Math.floor(_v_rad[2] * 180 / Math.PI);
-    const ret = bind.SliderInt3(label, _v_rad, v_degrees_min, v_degrees_max, format, flags);
-    _v_rad[0] = _v_rad[0] * Math.PI / 180;
-    _v_rad[1] = _v_rad[1] * Math.PI / 180;
-    _v_rad[2] = _v_rad[2] * Math.PI / 180;
-    export_Vector3(_v_rad, v_rad);
-    return ret;
+  const _v_rad = import_Vector3(v_rad);
+  _v_rad[0] = Math.floor(_v_rad[0] * 180 / Math.PI);
+  _v_rad[1] = Math.floor(_v_rad[1] * 180 / Math.PI);
+  _v_rad[2] = Math.floor(_v_rad[2] * 180 / Math.PI);
+  const ret = bind.SliderInt3(label, _v_rad, v_degrees_min, v_degrees_max, format, flags);
+  _v_rad[0] = _v_rad[0] * Math.PI / 180;
+  _v_rad[1] = _v_rad[1] * Math.PI / 180;
+  _v_rad[2] = _v_rad[2] * Math.PI / 180;
+  export_Vector3(_v_rad, v_rad);
+  return ret;
 }
 export function SliderInt(label: string, v: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_min: number, v_max: number, format: string = "%d", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Scalar(v);
-    const ret = bind.SliderInt(label, _v, v_min, v_max, format, flags);
-    export_Scalar(_v, v);
-    return ret;
+  const _v = import_Scalar(v);
+  const ret = bind.SliderInt(label, _v, v_min, v_max, format, flags);
+  export_Scalar(_v, v);
+  return ret;
 }
 export function SliderInt2(label: string, v: XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_min: number, v_max: number, format: string = "%d", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Vector2(v);
-    const ret = bind.SliderInt2(label, _v, v_min, v_max, format, flags);
-    export_Vector2(_v, v);
-    return ret;
+  const _v = import_Vector2(v);
+  const ret = bind.SliderInt2(label, _v, v_min, v_max, format, flags);
+  export_Vector2(_v, v);
+  return ret;
 }
 export function SliderInt3(label: string, v: XYZ | XYZW | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_min: number, v_max: number, format: string = "%d", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Vector3(v);
-    const ret = bind.SliderInt3(label, _v, v_min, v_max, format, flags);
-    export_Vector3(_v, v);
-    return ret;
+  const _v = import_Vector3(v);
+  const ret = bind.SliderInt3(label, _v, v_min, v_max, format, flags);
+  export_Vector3(_v, v);
+  return ret;
 }
 export function SliderInt4(label: string, v: XYZW | Bind.ImTuple4<number>, v_min: number, v_max: number, format: string = "%d", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Vector4(v);
-    const ret = bind.SliderInt4(label, _v, v_min, v_max, format, flags);
-    export_Vector4(_v, v);
-    return ret;
+  const _v = import_Vector4(v);
+  const ret = bind.SliderInt4(label, _v, v_min, v_max, format, flags);
+  export_Vector4(_v, v);
+  return ret;
 }
 export function SliderScalar(label: string, v: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array, v_min: number, v_max: number, format: string | null = null, flags: ImGuiSliderFlags = 0): boolean {
-    if (v instanceof Int8Array) { return bind.SliderScalar(label, ImGuiDataType.S8, v, v_min, v_max, format, flags); }
-    if (v instanceof Uint8Array) { return bind.SliderScalar(label, ImGuiDataType.U8, v, v_min, v_max, format, flags); }
-    if (v instanceof Int16Array) { return bind.SliderScalar(label, ImGuiDataType.S16, v, v_min, v_max, format, flags); }
-    if (v instanceof Uint16Array) { return bind.SliderScalar(label, ImGuiDataType.U16, v, v_min, v_max, format, flags); }
-    if (v instanceof Int32Array) { return bind.SliderScalar(label, ImGuiDataType.S32, v, v_min, v_max, format, flags); }
-    if (v instanceof Uint32Array) { return bind.SliderScalar(label, ImGuiDataType.U32, v, v_min, v_max, format, flags); }
-    // if (v instanceof Int64Array) { return bind.SliderScalar(label, ImGuiDataType.S64, v, v_min, v_max, format, flags); }
-    // if (v instanceof Uint64Array) { return bind.SliderScalar(label, ImGuiDataType.U64, v, v_min, v_max, format, flags); }
-    if (v instanceof Float32Array) { return bind.SliderScalar(label, ImGuiDataType.Float, v, v_min, v_max, format, flags); }
-    if (v instanceof Float64Array) { return bind.SliderScalar(label, ImGuiDataType.Double, v, v_min, v_max, format, flags); }
-    throw new Error();
+  if (v instanceof Int8Array) { return bind.SliderScalar(label, ImGuiDataType.S8, v, v_min, v_max, format, flags); }
+  if (v instanceof Uint8Array) { return bind.SliderScalar(label, ImGuiDataType.U8, v, v_min, v_max, format, flags); }
+  if (v instanceof Int16Array) { return bind.SliderScalar(label, ImGuiDataType.S16, v, v_min, v_max, format, flags); }
+  if (v instanceof Uint16Array) { return bind.SliderScalar(label, ImGuiDataType.U16, v, v_min, v_max, format, flags); }
+  if (v instanceof Int32Array) { return bind.SliderScalar(label, ImGuiDataType.S32, v, v_min, v_max, format, flags); }
+  if (v instanceof Uint32Array) { return bind.SliderScalar(label, ImGuiDataType.U32, v, v_min, v_max, format, flags); }
+  // if (v instanceof Int64Array) { return bind.SliderScalar(label, ImGuiDataType.S64, v, v_min, v_max, format, flags); }
+  // if (v instanceof Uint64Array) { return bind.SliderScalar(label, ImGuiDataType.U64, v, v_min, v_max, format, flags); }
+  if (v instanceof Float32Array) { return bind.SliderScalar(label, ImGuiDataType.Float, v, v_min, v_max, format, flags); }
+  if (v instanceof Float64Array) { return bind.SliderScalar(label, ImGuiDataType.Double, v, v_min, v_max, format, flags); }
+  throw new Error();
 }
 export function VSliderFloat(label: string, size: Readonly<Bind.interface_ImVec2>, v: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_min: number, v_max: number, format: string = "%.3f", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Scalar(v);
-    const ret = bind.VSliderFloat(label, size, _v, v_min, v_max, format, flags);
-    export_Scalar(_v, v);
-    return ret;
+  const _v = import_Scalar(v);
+  const ret = bind.VSliderFloat(label, size, _v, v_min, v_max, format, flags);
+  export_Scalar(_v, v);
+  return ret;
 }
 export function VSliderInt(label: string, size: Readonly<Bind.interface_ImVec2>, v: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, v_min: number, v_max: number, format: string = "%d", flags: ImGuiSliderFlags = 0): boolean {
-    const _v = import_Scalar(v);
-    const ret = bind.VSliderInt(label, size, _v, v_min, v_max, format, flags);
-    export_Scalar(_v, v);
-    return ret;
+  const _v = import_Scalar(v);
+  const ret = bind.VSliderInt(label, size, _v, v_min, v_max, format, flags);
+  export_Scalar(_v, v);
+  return ret;
 }
 export function VSliderScalar(label: string, size: Readonly<Bind.interface_ImVec2>, data_type: ImGuiDataType, v: Bind.ImAccess<number> | Bind.ImScalar<number>, v_min: number, v_max: number, format: string | null = null, flags: ImGuiSliderFlags = 0): boolean {
-    if (v instanceof Int8Array) { return bind.VSliderScalar(label, size, ImGuiDataType.S8, v, v_min, v_max, format, flags); }
-    if (v instanceof Uint8Array) { return bind.VSliderScalar(label, size, ImGuiDataType.U8, v, v_min, v_max, format, flags); }
-    if (v instanceof Int16Array) { return bind.VSliderScalar(label, size, ImGuiDataType.S16, v, v_min, v_max, format, flags); }
-    if (v instanceof Uint16Array) { return bind.VSliderScalar(label, size, ImGuiDataType.U16, v, v_min, v_max, format, flags); }
-    if (v instanceof Int32Array) { return bind.VSliderScalar(label, size, ImGuiDataType.S32, v, v_min, v_max, format, flags); }
-    if (v instanceof Uint32Array) { return bind.VSliderScalar(label, size, ImGuiDataType.U32, v, v_min, v_max, format, flags); }
-    // if (v instanceof Int64Array) { return bind.VSliderScalar(label, size, ImGuiDataType.S64, v, v_min, v_max, format, flags); }
-    // if (v instanceof Uint64Array) { return bind.VSliderScalar(label, size, ImGuiDataType.U64, v, v_min, v_max, format, flags); }
-    if (v instanceof Float32Array) { return bind.VSliderScalar(label, size, ImGuiDataType.Float, v, v_min, v_max, format, flags); }
-    if (v instanceof Float64Array) { return bind.VSliderScalar(label, size, ImGuiDataType.Double, v, v_min, v_max, format, flags); }
-    throw new Error();
+  if (v instanceof Int8Array) { return bind.VSliderScalar(label, size, ImGuiDataType.S8, v, v_min, v_max, format, flags); }
+  if (v instanceof Uint8Array) { return bind.VSliderScalar(label, size, ImGuiDataType.U8, v, v_min, v_max, format, flags); }
+  if (v instanceof Int16Array) { return bind.VSliderScalar(label, size, ImGuiDataType.S16, v, v_min, v_max, format, flags); }
+  if (v instanceof Uint16Array) { return bind.VSliderScalar(label, size, ImGuiDataType.U16, v, v_min, v_max, format, flags); }
+  if (v instanceof Int32Array) { return bind.VSliderScalar(label, size, ImGuiDataType.S32, v, v_min, v_max, format, flags); }
+  if (v instanceof Uint32Array) { return bind.VSliderScalar(label, size, ImGuiDataType.U32, v, v_min, v_max, format, flags); }
+  // if (v instanceof Int64Array) { return bind.VSliderScalar(label, size, ImGuiDataType.S64, v, v_min, v_max, format, flags); }
+  // if (v instanceof Uint64Array) { return bind.VSliderScalar(label, size, ImGuiDataType.U64, v, v_min, v_max, format, flags); }
+  if (v instanceof Float32Array) { return bind.VSliderScalar(label, size, ImGuiDataType.Float, v, v_min, v_max, format, flags); }
+  if (v instanceof Float64Array) { return bind.VSliderScalar(label, size, ImGuiDataType.Double, v, v_min, v_max, format, flags); }
+  throw new Error();
 }
 
 // Widgets: Input with Keyboard
@@ -3892,133 +3847,133 @@ export function VSliderScalar(label: string, size: Readonly<Bind.interface_ImVec
 // IMGUI_API bool          InputScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_step = NULL, const void* p_step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);
 // IMGUI_API bool          InputScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_step = NULL, const void* p_step_fast = NULL, const char* format = NULL, ImGuiInputTextFlags flags = 0);
 export function InputText<T>(label: string, buf: ImStringBuffer | Bind.ImAccess<string> | Bind.ImScalar<string>, buf_size: number = buf instanceof ImStringBuffer ? buf.size : ImGuiInputTextDefaultSize, flags: ImGuiInputTextFlags = 0, callback: ImGuiInputTextCallback<T> | null = null, user_data: T | null = null): boolean {
-    let ret:boolean=false;
-    let text:string;
-    const _callback = callback && ((data: Bind.reference_ImGuiInputTextCallbackData): number => callback(new ImGuiInputTextCallbackData<T>(data, user_data))) || null;
-    if (Array.isArray(buf)) {
-        return bind.InputText(label, buf, buf_size, flags, _callback, null);
-    } else if (buf instanceof ImStringBuffer) {
-        const ref_buf: Bind.ImScalar<string> = [ buf.buffer ];
-        const _buf_size: number = Math.min(buf_size, buf.size);
-        text=buf.buffer;
-        ret = bind.InputText(label, ref_buf, _buf_size, flags, _callback, null);
-        buf.buffer = ref_buf[0];
-    } else {
-        const ref_buf: Bind.ImScalar<string> = [ buf() ];
-        text=buf();
-        ret = bind.InputText(label, ref_buf, buf_size + 1, flags, _callback, null);
-        buf(ref_buf[0]);
-    }
-    return ret;
+  let ret: boolean = false;
+  let text: string;
+  const _callback = callback && ((data: Bind.reference_ImGuiInputTextCallbackData): number => callback(new ImGuiInputTextCallbackData<T>(data, user_data))) || null;
+  if (Array.isArray(buf)) {
+    return bind.InputText(label, buf, buf_size, flags, _callback, null);
+  } else if (buf instanceof ImStringBuffer) {
+    const ref_buf: Bind.ImScalar<string> = [buf.buffer];
+    const _buf_size: number = Math.min(buf_size, buf.size);
+    text = buf.buffer;
+    ret = bind.InputText(label, ref_buf, _buf_size, flags, _callback, null);
+    buf.buffer = ref_buf[0];
+  } else {
+    const ref_buf: Bind.ImScalar<string> = [buf()];
+    text = buf();
+    ret = bind.InputText(label, ref_buf, buf_size + 1, flags, _callback, null);
+    buf(ref_buf[0]);
+  }
+  return ret;
 }
 export function InputTextMultiline<T>(label: string, buf: ImStringBuffer | Bind.ImAccess<string> | Bind.ImScalar<string>, buf_size: number = buf instanceof ImStringBuffer ? buf.size : ImGuiInputTextDefaultSize, size: Readonly<Bind.interface_ImVec2> = ImVec2.ZERO, flags: ImGuiInputTextFlags = 0, callback: ImGuiInputTextCallback<T> | null = null, user_data: T | null = null): boolean {
-    let ret:boolean=false;
-    let text:string;
-
-    const _callback = callback && ((data: Bind.reference_ImGuiInputTextCallbackData): number => callback(new ImGuiInputTextCallbackData<T>(data, user_data))) || null;
-    if (Array.isArray(buf)) {
-        return bind.InputTextMultiline(label, buf, buf_size, size, flags, _callback, null);
-    } else if (buf instanceof ImStringBuffer) {
-        const ref_buf: Bind.ImScalar<string> = [ buf.buffer ];
-        const _buf_size: number = Math.min(buf_size, buf.size);
-        text=buf.buffer;
-        ret = bind.InputTextMultiline(label, ref_buf, _buf_size, size, flags, _callback, null);
-        buf.buffer = ref_buf[0];
-    } else {
-        const ref_buf: Bind.ImScalar<string> = [ buf() ];
-        text=buf();
-        ret = bind.InputTextMultiline(label, ref_buf, buf_size, size, flags, _callback, null);
-        buf(ref_buf[0]);        
-    }
-    return ret;
+  let ret: boolean = false;
+  let text: string;
+
+  const _callback = callback && ((data: Bind.reference_ImGuiInputTextCallbackData): number => callback(new ImGuiInputTextCallbackData<T>(data, user_data))) || null;
+  if (Array.isArray(buf)) {
+    return bind.InputTextMultiline(label, buf, buf_size, size, flags, _callback, null);
+  } else if (buf instanceof ImStringBuffer) {
+    const ref_buf: Bind.ImScalar<string> = [buf.buffer];
+    const _buf_size: number = Math.min(buf_size, buf.size);
+    text = buf.buffer;
+    ret = bind.InputTextMultiline(label, ref_buf, _buf_size, size, flags, _callback, null);
+    buf.buffer = ref_buf[0];
+  } else {
+    const ref_buf: Bind.ImScalar<string> = [buf()];
+    text = buf();
+    ret = bind.InputTextMultiline(label, ref_buf, buf_size, size, flags, _callback, null);
+    buf(ref_buf[0]);
+  }
+  return ret;
 }
 export function InputTextWithHint<T>(label: string, hint: string, buf: ImStringBuffer | Bind.ImAccess<string> | Bind.ImScalar<string>, buf_size: number = buf instanceof ImStringBuffer ? buf.size : ImGuiInputTextDefaultSize, flags: ImGuiInputTextFlags = 0, callback: ImGuiInputTextCallback<T> | null = null, user_data: T | null = null): boolean {
-    let ret:boolean=false;
-    let text:string;
-
-    const _callback = callback && ((data: Bind.reference_ImGuiInputTextCallbackData): number => callback(new ImGuiInputTextCallbackData<T>(data, user_data))) || null;
-    if (Array.isArray(buf)) {
-        return bind.InputTextWithHint(label, hint, buf, buf_size, flags, _callback, null);
-    } else if (buf instanceof ImStringBuffer) {
-        const ref_buf: Bind.ImScalar<string> = [ buf.buffer ];
-        const _buf_size: number = Math.min(buf_size, buf.size);
-        text=buf.buffer;
-        ret = bind.InputTextWithHint(label, hint, ref_buf, _buf_size, flags, _callback, null);
-        buf.buffer = ref_buf[0];
-    } else {
-        const ref_buf: Bind.ImScalar<string> = [ buf() ];
-        text=buf();
-        ret = bind.InputTextWithHint(label, hint, ref_buf, buf_size, flags, _callback, null);
-        buf(ref_buf[0]);
-    }
-    return ret;
+  let ret: boolean = false;
+  let text: string;
+
+  const _callback = callback && ((data: Bind.reference_ImGuiInputTextCallbackData): number => callback(new ImGuiInputTextCallbackData<T>(data, user_data))) || null;
+  if (Array.isArray(buf)) {
+    return bind.InputTextWithHint(label, hint, buf, buf_size, flags, _callback, null);
+  } else if (buf instanceof ImStringBuffer) {
+    const ref_buf: Bind.ImScalar<string> = [buf.buffer];
+    const _buf_size: number = Math.min(buf_size, buf.size);
+    text = buf.buffer;
+    ret = bind.InputTextWithHint(label, hint, ref_buf, _buf_size, flags, _callback, null);
+    buf.buffer = ref_buf[0];
+  } else {
+    const ref_buf: Bind.ImScalar<string> = [buf()];
+    text = buf();
+    ret = bind.InputTextWithHint(label, hint, ref_buf, buf_size, flags, _callback, null);
+    buf(ref_buf[0]);
+  }
+  return ret;
 }
 export function InputFloat(label: string, v: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, step: number = 0.0, step_fast: number = 0.0, format: string = "%.3f", flags: ImGuiInputTextFlags = 0): boolean {
-    const _v = import_Scalar(v);
-    const ret = bind.InputFloat(label, _v, step, step_fast, format, flags);
-    export_Scalar(_v, v);
-    return ret;
+  const _v = import_Scalar(v);
+  const ret = bind.InputFloat(label, _v, step, step_fast, format, flags);
+  export_Scalar(_v, v);
+  return ret;
 }
 export function InputFloat2(label: string, v: XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, format: string = "%.3f", flags: ImGuiInputTextFlags = 0): boolean {
-    const _v = import_Vector2(v);
-    const ret = bind.InputFloat2(label, _v, format, flags);
-    export_Vector2(_v, v);
-    return ret;
+  const _v = import_Vector2(v);
+  const ret = bind.InputFloat2(label, _v, format, flags);
+  export_Vector2(_v, v);
+  return ret;
 }
 export function InputFloat3(label: string, v: XYZ | XYZW | Bind.ImTuple3<number> | Bind.ImTuple4<number>, format: string = "%.3f", flags: ImGuiInputTextFlags = 0): boolean {
-    const _v = import_Vector3(v);
-    const ret = bind.InputFloat3(label, _v, format, flags);
-    export_Vector3(_v, v);
-    return ret;
+  const _v = import_Vector3(v);
+  const ret = bind.InputFloat3(label, _v, format, flags);
+  export_Vector3(_v, v);
+  return ret;
 }
 export function InputFloat4(label: string, v: XYZW | Bind.ImTuple4<number>, format: string = "%.3f", flags: ImGuiInputTextFlags = 0): boolean {
-    const _v = import_Vector4(v);
-    const ret = bind.InputFloat4(label, _v, format, flags);
-    export_Vector4(_v, v);
-    return ret;
+  const _v = import_Vector4(v);
+  const ret = bind.InputFloat4(label, _v, format, flags);
+  export_Vector4(_v, v);
+  return ret;
 }
 export function InputInt(label: string, v: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, step: number = 1, step_fast: number = 100, flags: ImGuiInputTextFlags = 0): boolean {
-    const _v = import_Scalar(v);
-    const ret = bind.InputInt(label, _v, step, step_fast, flags);
-    export_Scalar(_v, v);
-    return ret;
+  const _v = import_Scalar(v);
+  const ret = bind.InputInt(label, _v, step, step_fast, flags);
+  export_Scalar(_v, v);
+  return ret;
 }
 export function InputInt2(label: string, v: XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, flags: ImGuiInputTextFlags = 0): boolean {
-    const _v = import_Vector2(v);
-    const ret = bind.InputInt2(label, _v, flags);
-    export_Vector2(_v, v);
-    return ret;
+  const _v = import_Vector2(v);
+  const ret = bind.InputInt2(label, _v, flags);
+  export_Vector2(_v, v);
+  return ret;
 }
 export function InputInt3(label: string, v: XYZ | XYZW | Bind.ImTuple3<number> | Bind.ImTuple4<number>, flags: ImGuiInputTextFlags = 0): boolean {
-    const _v = import_Vector3(v);
-    const ret = bind.InputInt3(label, _v, flags);
-    export_Vector3(_v, v);
-    return ret;
+  const _v = import_Vector3(v);
+  const ret = bind.InputInt3(label, _v, flags);
+  export_Vector3(_v, v);
+  return ret;
 }
 export function InputInt4(label: string, v: XYZW | Bind.ImTuple4<number>, flags: ImGuiInputTextFlags = 0): boolean {
-    const _v = import_Vector4(v);
-    const ret = bind.InputInt4(label, _v, flags);
-    export_Vector4(_v, v);
-    return ret;
+  const _v = import_Vector4(v);
+  const ret = bind.InputInt4(label, _v, flags);
+  export_Vector4(_v, v);
+  return ret;
 }
 export function InputDouble(label: string, v: Bind.ImAccess<number> | Bind.ImScalar<number> | XY | XYZ | XYZW | Bind.ImTuple2<number> | Bind.ImTuple3<number> | Bind.ImTuple4<number>, step: number = 0.0, step_fast: number = 0.0, format: string = "%.6f", flags: ImGuiInputTextFlags = 0): boolean {
-    const _v = import_Scalar(v);
-    const ret = bind.InputDouble(label, _v, step, step_fast, format, flags);
-    export_Scalar(_v, v);
-    return ret;
+  const _v = import_Scalar(v);
+  const ret = bind.InputDouble(label, _v, step, step_fast, format, flags);
+  export_Scalar(_v, v);
+  return ret;
 }
 export function InputScalar(label: string, v: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array, step: number | null = null, step_fast: number | null = null, format: string | null = null, flags: ImGuiInputTextFlags = 0): boolean {
-    if (v instanceof Int8Array) { return bind.InputScalar(label, ImGuiDataType.S8, v, step, step_fast, format, flags); }
-    if (v instanceof Uint8Array) { return bind.InputScalar(label, ImGuiDataType.U8, v, step, step_fast, format, flags); }
-    if (v instanceof Int16Array) { return bind.InputScalar(label, ImGuiDataType.S16, v, step, step_fast, format, flags); }
-    if (v instanceof Uint16Array) { return bind.InputScalar(label, ImGuiDataType.U16, v, step, step_fast, format, flags); }
-    if (v instanceof Int32Array) { return bind.InputScalar(label, ImGuiDataType.S32, v, step, step_fast, format, flags); }
-    if (v instanceof Uint32Array) { return bind.InputScalar(label, ImGuiDataType.U32, v, step, step_fast, format, flags); }
-    // if (v instanceof Int64Array) { return bind.InputScalar(label, ImGuiDataType.S64, v, step, step_fast, format, flags); }
-    // if (v instanceof Uint64Array) { return bind.InputScalar(label, ImGuiDataType.U64, v, step, step_fast, format, flags); }
-    if (v instanceof Float32Array) { return bind.InputScalar(label, ImGuiDataType.Float, v, step, step_fast, format, flags); }
-    if (v instanceof Float64Array) { return bind.InputScalar(label, ImGuiDataType.Double, v, step, step_fast, format, flags); }
-    throw new Error();
+  if (v instanceof Int8Array) { return bind.InputScalar(label, ImGuiDataType.S8, v, step, step_fast, format, flags); }
+  if (v instanceof Uint8Array) { return bind.InputScalar(label, ImGuiDataType.U8, v, step, step_fast, format, flags); }
+  if (v instanceof Int16Array) { return bind.InputScalar(label, ImGuiDataType.S16, v, step, step_fast, format, flags); }
+  if (v instanceof Uint16Array) { return bind.InputScalar(label, ImGuiDataType.U16, v, step, step_fast, format, flags); }
+  if (v instanceof Int32Array) { return bind.InputScalar(label, ImGuiDataType.S32, v, step, step_fast, format, flags); }
+  if (v instanceof Uint32Array) { return bind.InputScalar(label, ImGuiDataType.U32, v, step, step_fast, format, flags); }
+  // if (v instanceof Int64Array) { return bind.InputScalar(label, ImGuiDataType.S64, v, step, step_fast, format, flags); }
+  // if (v instanceof Uint64Array) { return bind.InputScalar(label, ImGuiDataType.U64, v, step, step_fast, format, flags); }
+  if (v instanceof Float32Array) { return bind.InputScalar(label, ImGuiDataType.Float, v, step, step_fast, format, flags); }
+  if (v instanceof Float64Array) { return bind.InputScalar(label, ImGuiDataType.Double, v, step, step_fast, format, flags); }
+  throw new Error();
 }
 
 // Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little color square that can be left-clicked to open a picker, and right-clicked to open an option menu.)
@@ -4031,36 +3986,36 @@ export function InputScalar(label: string, v: Int8Array | Uint8Array | Int16Arra
 // IMGUI_API bool          ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0, 0)); // display a color square/button, hover for details, return true when pressed.
 // IMGUI_API void          SetColorEditOptions(ImGuiColorEditFlags flags);                     // initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.
 export function ColorEdit3(label: string, col: RGB | RGBA | Bind.ImTuple3<number> | Bind.ImTuple4<number> | Bind.interface_ImVec4, flags: ImGuiColorEditFlags = 0): boolean {
-    const _col = import_Color3(col);
-    const ret = bind.ColorEdit3(label, _col, flags);
-    export_Color3(_col, col);
-    return ret;
+  const _col = import_Color3(col);
+  const ret = bind.ColorEdit3(label, _col, flags);
+  export_Color3(_col, col);
+  return ret;
 }
 export function ColorEdit4(label: string, col: RGBA | Bind.ImTuple4<number> | Bind.interface_ImVec4, flags: ImGuiColorEditFlags = 0): boolean {
-    const _col = import_Color4(col);
-    const ret = bind.ColorEdit4(label, _col, flags);
-    export_Color4(_col, col);
-    return ret;
+  const _col = import_Color4(col);
+  const ret = bind.ColorEdit4(label, _col, flags);
+  export_Color4(_col, col);
+  return ret;
 }
 export function ColorPicker3(label: string, col: RGB | RGBA | Bind.ImTuple3<number> | Bind.ImTuple4<number> | Bind.interface_ImVec4, flags: ImGuiColorEditFlags = 0): boolean {
-    const _col = import_Color3(col);
-    const ret = bind.ColorPicker3(label, _col, flags);
-    export_Color3(_col, col);
-    return ret;
+  const _col = import_Color3(col);
+  const ret = bind.ColorPicker3(label, _col, flags);
+  export_Color3(_col, col);
+  return ret;
 }
 export function ColorPicker4(label: string, col: RGBA | Bind.ImTuple4<number> | Bind.interface_ImVec4, flags: ImGuiColorEditFlags = 0, ref_col: Bind.ImTuple4<number> | Bind.interface_ImVec4 | null = null): boolean {
-    const _col = import_Color4(col);
-    const _ref_col = ref_col ? import_Color4(ref_col) : null;
-    const ret = bind.ColorPicker4(label, _col, flags, _ref_col);
-    export_Color4(_col, col);
-    if (_ref_col && ref_col) { export_Color4(_ref_col, ref_col); }
-    return ret;
+  const _col = import_Color4(col);
+  const _ref_col = ref_col ? import_Color4(ref_col) : null;
+  const ret = bind.ColorPicker4(label, _col, flags, _ref_col);
+  export_Color4(_col, col);
+  if (_ref_col && ref_col) { export_Color4(_ref_col, ref_col); }
+  return ret;
 }
 export function ColorButton(desc_id: string, col: Readonly<Bind.interface_ImVec4>, flags: ImGuiColorEditFlags = 0, size: Readonly<Bind.interface_ImVec2> = ImVec2.ZERO): boolean {
-    return bind.ColorButton(desc_id, col, flags, size);
+  return bind.ColorButton(desc_id, col, flags, size);
 }
 export function SetColorEditOptions(flags: ImGuiColorEditFlags): void {
-    bind.SetColorEditOptions(flags);
+  bind.SetColorEditOptions(flags);
 }
 
 // Widgets: Trees
@@ -4086,77 +4041,77 @@ export function TreeNode(label: string): boolean;
 export function TreeNode(label: string, fmt: string): boolean;
 export function TreeNode(label: number, fmt: string): boolean;
 export function TreeNode(...args: any[]): boolean {
-    if (typeof(args[0]) === "string") {
-        if (args.length === 1) {
-            const label: string = args[0];
-            return bind.TreeNode_A(label);
-        } else {
-            const str_id: string = args[0];
-            const fmt: string = args[1];
-            return bind.TreeNode_B(str_id, fmt);
-        }
+  if (typeof (args[0]) === "string") {
+    if (args.length === 1) {
+      const label: string = args[0];
+      return bind.TreeNode_A(label);
     } else {
-        const ptr_id: number = args[0];
-        const fmt: string = args[1];
-        return bind.TreeNode_C(ptr_id, fmt);
+      const str_id: string = args[0];
+      const fmt: string = args[1];
+      return bind.TreeNode_B(str_id, fmt);
     }
+  } else {
+    const ptr_id: number = args[0];
+    const fmt: string = args[1];
+    return bind.TreeNode_C(ptr_id, fmt);
+  }
 }
 export function TreeNodeEx(label: string, flags?: ImGuiTreeNodeFlags): boolean;
 export function TreeNodeEx(str_id: string, flags: ImGuiTreeNodeFlags, fmt: string): boolean;
 export function TreeNodeEx(ptr_id: number, flags: ImGuiTreeNodeFlags, fmt: string): boolean;
 export function TreeNodeEx(...args: any[]): boolean {
-    if (typeof(args[0]) === "string") {
-        if (args.length < 3) {
-            const label: string = args[0];
-            const flags: ImGuiTreeNodeFlags = args[1] || 0;
-            return bind.TreeNodeEx_A(label, flags);
-        } else {
-            const str_id: string = args[0];
-            const flags: ImGuiTreeNodeFlags = args[1];
-            const fmt: string = args[2];
-            return bind.TreeNodeEx_B(str_id, flags, fmt);
-        }
+  if (typeof (args[0]) === "string") {
+    if (args.length < 3) {
+      const label: string = args[0];
+      const flags: ImGuiTreeNodeFlags = args[1] || 0;
+      return bind.TreeNodeEx_A(label, flags);
     } else {
-        const ptr_id: number = args[0];
-        const flags: ImGuiTreeNodeFlags = args[1];
-        const fmt: string = args[2];
-        return bind.TreeNodeEx_C(ptr_id, flags, fmt);
-    }
+      const str_id: string = args[0];
+      const flags: ImGuiTreeNodeFlags = args[1];
+      const fmt: string = args[2];
+      return bind.TreeNodeEx_B(str_id, flags, fmt);
+    }
+  } else {
+    const ptr_id: number = args[0];
+    const flags: ImGuiTreeNodeFlags = args[1];
+    const fmt: string = args[2];
+    return bind.TreeNodeEx_C(ptr_id, flags, fmt);
+  }
 }
 export function TreePush(str_id: string): void;
 export function TreePush(ptr_id: number): void;
 export function TreePush(...args: any[]): void {
-    if (typeof(args[0]) === "string") {
-        const str_id: string = args[0];
-        bind.TreePush_A(str_id);
-    } else {
-        const ptr_id: number = args[0];
-        bind.TreePush_B(ptr_id);
-    }
+  if (typeof (args[0]) === "string") {
+    const str_id: string = args[0];
+    bind.TreePush_A(str_id);
+  } else {
+    const ptr_id: number = args[0];
+    bind.TreePush_B(ptr_id);
+  }
 }
 export function TreePop(): void { bind.TreePop(); }
 export function GetTreeNodeToLabelSpacing(): number { return bind.GetTreeNodeToLabelSpacing(); }
 export function CollapsingHeader(label: string, flags?: ImGuiTreeNodeFlags): boolean;
 export function CollapsingHeader(label: string, p_open: Bind.ImScalar<boolean> | Bind.ImAccess<boolean>, flags?: ImGuiTreeNodeFlags): boolean;
 export function CollapsingHeader(label: string, ...args: any[]): boolean {
-    if (args.length === 0) {
-        return bind.CollapsingHeader_A(label, 0);
+  if (args.length === 0) {
+    return bind.CollapsingHeader_A(label, 0);
+  } else {
+    if (typeof (args[0]) === "number") {
+      const flags: ImGuiTreeNodeFlags = args[0];
+      return bind.CollapsingHeader_A(label, flags);
     } else {
-        if (typeof(args[0]) === "number") {
-            const flags: ImGuiTreeNodeFlags = args[0];
-            return bind.CollapsingHeader_A(label, flags);
-        } else {
-            const p_open: Bind.ImScalar<boolean> | Bind.ImAccess<boolean> = args[0];
-            const flags: ImGuiTreeNodeFlags = args[1] || 0;
-            const ref_open: Bind.ImScalar<boolean> = Array.isArray(p_open) ? p_open : [ p_open() ];
-            const ret = bind.CollapsingHeader_B(label, ref_open, flags);
-            if (!Array.isArray(p_open)) { p_open(ref_open[0]); }
-            return ret;
-        }
+      const p_open: Bind.ImScalar<boolean> | Bind.ImAccess<boolean> = args[0];
+      const flags: ImGuiTreeNodeFlags = args[1] || 0;
+      const ref_open: Bind.ImScalar<boolean> = Array.isArray(p_open) ? p_open : [p_open()];
+      const ret = bind.CollapsingHeader_B(label, ref_open, flags);
+      if (!Array.isArray(p_open)) { p_open(ref_open[0]); }
+      return ret;
     }
+  }
 }
 export function SetNextItemOpen(is_open: boolean, cond: ImGuiCond = 0): void {
-    bind.SetNextItemOpen(is_open, cond);
+  bind.SetNextItemOpen(is_open, cond);
 }
 
 // Widgets: Selectables
@@ -4167,24 +4122,24 @@ export function SetNextItemOpen(is_open: boolean, cond: ImGuiCond = 0): void {
 export function Selectable(label: string, selected?: boolean, flags?: ImGuiSelectableFlags, size?: Readonly<Bind.interface_ImVec2>): boolean;
 export function Selectable(label: string, p_selected: Bind.ImScalar<boolean> | Bind.ImAccess<boolean>, flags?: ImGuiSelectableFlags, size?: Readonly<Bind.interface_ImVec2>): boolean;
 export function Selectable(label: string, ...args: any[]): boolean {
-    if (args.length === 0) {
-        return bind.Selectable_A(label, false, 0, ImVec2.ZERO);
+  if (args.length === 0) {
+    return bind.Selectable_A(label, false, 0, ImVec2.ZERO);
+  } else {
+    if (typeof (args[0]) === "boolean") {
+      const selected: boolean = args[0];
+      const flags: ImGuiSelectableFlags = args[1] || 0;
+      const size: Readonly<Bind.interface_ImVec2> = args[2] || ImVec2.ZERO;
+      return bind.Selectable_A(label, selected, flags, size);
     } else {
-        if (typeof(args[0]) === "boolean") {
-            const selected: boolean = args[0];
-            const flags: ImGuiSelectableFlags = args[1] || 0;
-            const size: Readonly<Bind.interface_ImVec2> = args[2] || ImVec2.ZERO;
-            return bind.Selectable_A(label, selected, flags, size);
-        } else {
-            const p_selected: Bind.ImScalar<boolean> | Bind.ImAccess<boolean> = args[0];
-            const flags: ImGuiSelectableFlags = args[1] || 0;
-            const size: Readonly<Bind.interface_ImVec2> = args[2] || ImVec2.ZERO;
-            const ref_selected: Bind.ImScalar<boolean> = Array.isArray(p_selected) ? p_selected : [ p_selected() ];
-            const ret = bind.Selectable_B(label, ref_selected, flags, size);
-            if (!Array.isArray(p_selected)) { p_selected(ref_selected[0]); }
-            return ret;
-        }
+      const p_selected: Bind.ImScalar<boolean> | Bind.ImAccess<boolean> = args[0];
+      const flags: ImGuiSelectableFlags = args[1] || 0;
+      const size: Readonly<Bind.interface_ImVec2> = args[2] || ImVec2.ZERO;
+      const ref_selected: Bind.ImScalar<boolean> = Array.isArray(p_selected) ? p_selected : [p_selected()];
+      const ret = bind.Selectable_B(label, ref_selected, flags, size);
+      if (!Array.isArray(p_selected)) { p_selected(ref_selected[0]); }
+      return ret;
     }
+  }
 }
 
 // Widgets: List Boxes
@@ -4198,34 +4153,34 @@ export type ListBoxItemGetter<T> = (data: T, idx: number, out_text: [string]) =>
 export function ListBox(label: string, current_item: Bind.ImAccess<number> | Bind.ImScalar<number>, items: string[], items_count?: number, height_in_items?: number): boolean;
 export function ListBox<T>(label: string, current_item: Bind.ImAccess<number> | Bind.ImScalar<number>, items_getter: ListBoxItemGetter<T>, data: T, items_count: number, height_in_items?: number): boolean;
 export function ListBox<T>(label: string, current_item: Bind.ImAccess<number> | Bind.ImScalar<number>, ...args: any[]): boolean {
-    let ret: boolean = false;
-    const _current_item: Bind.ImScalar<number> = Array.isArray(current_item) ? current_item : [ current_item() ];
-    if (Array.isArray(args[0])) {
-        const items: string[] = args[0];
-        const items_count: number = typeof(args[1]) === "number" ? args[1] : items.length;
-        const height_in_items: number = typeof(args[2]) === "number" ? args[2] : -1;
-        ret = bind.ListBox_A(label, _current_item, items, items_count, height_in_items);
-    } else {
-        const items_getter: ListBoxItemGetter<T> = args[0];
-        const data: any = args[1];
-        const items_count: number = args[2];
-        const height_in_items: number = typeof(args[3]) === "number" ? args[3] : -1;
-        ret = bind.ListBox_B(label, _current_item, items_getter, data, items_count, height_in_items);
-    }
-    if (!Array.isArray(current_item)) { current_item(_current_item[0]); }
-    return ret;
+  let ret: boolean = false;
+  const _current_item: Bind.ImScalar<number> = Array.isArray(current_item) ? current_item : [current_item()];
+  if (Array.isArray(args[0])) {
+    const items: string[] = args[0];
+    const items_count: number = typeof (args[1]) === "number" ? args[1] : items.length;
+    const height_in_items: number = typeof (args[2]) === "number" ? args[2] : -1;
+    ret = bind.ListBox_A(label, _current_item, items, items_count, height_in_items);
+  } else {
+    const items_getter: ListBoxItemGetter<T> = args[0];
+    const data: any = args[1];
+    const items_count: number = args[2];
+    const height_in_items: number = typeof (args[3]) === "number" ? args[3] : -1;
+    ret = bind.ListBox_B(label, _current_item, items_getter, data, items_count, height_in_items);
+  }
+  if (!Array.isArray(current_item)) { current_item(_current_item[0]); }
+  return ret;
 }
 export function ListBoxHeader(label: string, size: Readonly<Bind.interface_ImVec2>): boolean;
 export function ListBoxHeader(label: string, items_count: number, height_in_items?: number): boolean;
 export function ListBoxHeader(label: string, ...args: any[]): boolean {
-    if (typeof(args[0]) === "object") {
-        const size: Readonly<Bind.interface_ImVec2> = args[0];
-        return bind.ListBoxHeader_A(label, size);
-    } else {
-        const items_count: number = args[0];
-        const height_in_items: number = typeof(args[1]) === "number" ? args[1] : -1;
-        return bind.ListBoxHeader_B(label, items_count, height_in_items);
-    }
+  if (typeof (args[0]) === "object") {
+    const size: Readonly<Bind.interface_ImVec2> = args[0];
+    return bind.ListBoxHeader_A(label, size);
+  } else {
+    const items_count: number = args[0];
+    const height_in_items: number = typeof (args[1]) === "number" ? args[1] : -1;
+    return bind.ListBoxHeader_B(label, items_count, height_in_items);
+  }
 }
 export function ListBoxFooter(): void { bind.ListBoxFooter(); }
 
@@ -4238,55 +4193,55 @@ export type PlotLinesValueGetter<T> = (data: T, idx: number) => number;
 export function PlotLines(label: string, values: ArrayLike<number>, values_count?: number, value_offset?: number, overlay_text?: string | null, scale_min?: number, scale_max?: number, graph_size?: Readonly<Bind.interface_ImVec2>, stride?: number): void;
 export function PlotLines<T>(label: string, values_getter: PlotLinesValueGetter<T>, data: T, values_count?: number, value_offset?: number, overlay_text?: string | null, scale_min?: number, scale_max?: number, graph_size?: Readonly<Bind.interface_ImVec2>): void;
 export function PlotLines<T>(label: string, ...args: any[]): void {
-    if (Array.isArray(args[0])) {
-        const values: ArrayLike<number> = args[0];
-        const values_getter: PlotLinesValueGetter<null> = (data: null, idx: number): number => values[idx * stride];
-        const values_count: number = typeof(args[1]) === "number" ? args[1] : values.length;
-        const values_offset: number = typeof(args[2]) === "number" ? args[2] : 0;
-        const overlay_text: string | null = typeof(args[3]) === "string" ? args[3] : null;
-        const scale_min: number = typeof(args[4]) === "number" ? args[4] : Number.MAX_VALUE;
-        const scale_max: number = typeof(args[5]) === "number" ? args[5] : Number.MAX_VALUE;
-        const graph_size: Readonly<Bind.interface_ImVec2> = args[6] || ImVec2.ZERO;
-        const stride: number = typeof(args[7]) === "number" ? args[7] : 1;
-        bind.PlotLines(label, values_getter, null, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
-    } else {
-        const values_getter: PlotLinesValueGetter<T> = args[0];
-        const data: any = args[1];
-        const values_count: number = args[2];
-        const values_offset: number = typeof(args[3]) === "number" ? args[3] : 0;
-        const overlay_text: string | null = typeof(args[4]) === "string" ? args[4] : null;
-        const scale_min: number = typeof(args[5]) === "number" ? args[5] : Number.MAX_VALUE;
-        const scale_max: number = typeof(args[6]) === "number" ? args[6] : Number.MAX_VALUE;
-        const graph_size: Readonly<Bind.interface_ImVec2> = args[7] || ImVec2.ZERO;
-        bind.PlotLines(label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
-    }
+  if (Array.isArray(args[0])) {
+    const values: ArrayLike<number> = args[0];
+    const values_getter: PlotLinesValueGetter<null> = (data: null, idx: number): number => values[idx * stride];
+    const values_count: number = typeof (args[1]) === "number" ? args[1] : values.length;
+    const values_offset: number = typeof (args[2]) === "number" ? args[2] : 0;
+    const overlay_text: string | null = typeof (args[3]) === "string" ? args[3] : null;
+    const scale_min: number = typeof (args[4]) === "number" ? args[4] : Number.MAX_VALUE;
+    const scale_max: number = typeof (args[5]) === "number" ? args[5] : Number.MAX_VALUE;
+    const graph_size: Readonly<Bind.interface_ImVec2> = args[6] || ImVec2.ZERO;
+    const stride: number = typeof (args[7]) === "number" ? args[7] : 1;
+    bind.PlotLines(label, values_getter, null, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
+  } else {
+    const values_getter: PlotLinesValueGetter<T> = args[0];
+    const data: any = args[1];
+    const values_count: number = args[2];
+    const values_offset: number = typeof (args[3]) === "number" ? args[3] : 0;
+    const overlay_text: string | null = typeof (args[4]) === "string" ? args[4] : null;
+    const scale_min: number = typeof (args[5]) === "number" ? args[5] : Number.MAX_VALUE;
+    const scale_max: number = typeof (args[6]) === "number" ? args[6] : Number.MAX_VALUE;
+    const graph_size: Readonly<Bind.interface_ImVec2> = args[7] || ImVec2.ZERO;
+    bind.PlotLines(label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
+  }
 }
 export type PlotHistogramValueGetter<T> = (data: T, idx: number) => number;
 export function PlotHistogram(label: string, values: ArrayLike<number>, values_count?: number, value_offset?: number, overlay_text?: string | null, scale_min?: number, scale_max?: number, graph_size?: Readonly<Bind.interface_ImVec2>, stride?: number): void;
 export function PlotHistogram<T>(label: string, values_getter: PlotHistogramValueGetter<T>, data: T, values_count?: number, value_offset?: number, overlay_text?: string | null, scale_min?: number, scale_max?: number, graph_size?: Readonly<Bind.interface_ImVec2>): void;
 export function PlotHistogram<T>(label: string, ...args: any[]): void {
-    if (Array.isArray(args[0])) {
-        const values: ArrayLike<number> = args[0];
-        const values_getter: PlotHistogramValueGetter<null> = (data: null, idx: number): number => values[idx * stride];
-        const values_count: number = typeof(args[1]) === "number" ? args[1] : values.length;
-        const values_offset: number = typeof(args[2]) === "number" ? args[2] : 0;
-        const overlay_text: string | null = typeof(args[3]) === "string" ? args[3] : null;
-        const scale_min: number = typeof(args[4]) === "number" ? args[4] : Number.MAX_VALUE;
-        const scale_max: number = typeof(args[5]) === "number" ? args[5] : Number.MAX_VALUE;
-        const graph_size: Readonly<Bind.interface_ImVec2> = args[6] || ImVec2.ZERO;
-        const stride: number = typeof(args[7]) === "number" ? args[7] : 1;
-        bind.PlotHistogram(label, values_getter, null, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
-    } else {
-        const values_getter: PlotHistogramValueGetter<T> = args[0];
-        const data: T = args[1];
-        const values_count: number = args[2];
-        const values_offset: number = typeof(args[3]) === "number" ? args[3] : 0;
-        const overlay_text: string | null = typeof(args[4]) === "string" ? args[4] : null;
-        const scale_min: number = typeof(args[5]) === "number" ? args[5] : Number.MAX_VALUE;
-        const scale_max: number = typeof(args[6]) === "number" ? args[6] : Number.MAX_VALUE;
-        const graph_size: Readonly<Bind.interface_ImVec2> = args[7] || ImVec2.ZERO;
-        bind.PlotHistogram(label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
-    }
+  if (Array.isArray(args[0])) {
+    const values: ArrayLike<number> = args[0];
+    const values_getter: PlotHistogramValueGetter<null> = (data: null, idx: number): number => values[idx * stride];
+    const values_count: number = typeof (args[1]) === "number" ? args[1] : values.length;
+    const values_offset: number = typeof (args[2]) === "number" ? args[2] : 0;
+    const overlay_text: string | null = typeof (args[3]) === "string" ? args[3] : null;
+    const scale_min: number = typeof (args[4]) === "number" ? args[4] : Number.MAX_VALUE;
+    const scale_max: number = typeof (args[5]) === "number" ? args[5] : Number.MAX_VALUE;
+    const graph_size: Readonly<Bind.interface_ImVec2> = args[6] || ImVec2.ZERO;
+    const stride: number = typeof (args[7]) === "number" ? args[7] : 1;
+    bind.PlotHistogram(label, values_getter, null, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
+  } else {
+    const values_getter: PlotHistogramValueGetter<T> = args[0];
+    const data: T = args[1];
+    const values_count: number = args[2];
+    const values_offset: number = typeof (args[3]) === "number" ? args[3] : 0;
+    const overlay_text: string | null = typeof (args[4]) === "string" ? args[4] : null;
+    const scale_min: number = typeof (args[5]) === "number" ? args[5] : Number.MAX_VALUE;
+    const scale_max: number = typeof (args[6]) === "number" ? args[6] : Number.MAX_VALUE;
+    const graph_size: Readonly<Bind.interface_ImVec2> = args[7] || ImVec2.ZERO;
+    bind.PlotHistogram(label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
+  }
 }
 
 // Widgets: Value() Helpers.
@@ -4300,17 +4255,17 @@ export function Value(prefix: string, v: number): void;
 export function Value(prefix: string, v: number, float_format?: string | null): void;
 export function Value(prefix: string, v: any): void;
 export function Value(prefix: string, ...args: any[]): void {
-    if (typeof(args[0]) === "boolean") {
-        bind.Value_A(prefix, args[0]);
-    } else if (typeof(args[0]) === "number") {
-        if (Number.isInteger(args[0])) {
-            bind.Value_B(prefix, args[0]);
-        } else {
-            bind.Value_D(prefix, args[0], typeof(args[1]) === "string" ? args[1] : null);
-        }
+  if (typeof (args[0]) === "boolean") {
+    bind.Value_A(prefix, args[0]);
+  } else if (typeof (args[0]) === "number") {
+    if (Number.isInteger(args[0])) {
+      bind.Value_B(prefix, args[0]);
     } else {
-        bind.Text(prefix + String(args[0]));
+      bind.Value_D(prefix, args[0], typeof (args[1]) === "string" ? args[1] : null);
     }
+  } else {
+    bind.Text(prefix + String(args[0]));
+  }
 }
 
 // Widgets: Menus
@@ -4334,26 +4289,26 @@ export function EndMenu(): void { bind.EndMenu(); }
 export function MenuItem(label: string, shortcut?: string | null, selected?: boolean, enabled?: boolean): boolean;
 export function MenuItem(label: string, shortcut: string | null, p_selected: Bind.ImScalar<boolean> | Bind.ImAccess<boolean> | null, enabled?: boolean): boolean;
 export function MenuItem(label: string, ...args: any[]): boolean {
-    if (args.length === 0) {
-        return bind.MenuItem_A(label, null, false, true);
-    } else if (args.length === 1) {
-        const shortcut: string | null = args[0];
-        return bind.MenuItem_A(label, shortcut, false, true);
+  if (args.length === 0) {
+    return bind.MenuItem_A(label, null, false, true);
+  } else if (args.length === 1) {
+    const shortcut: string | null = args[0];
+    return bind.MenuItem_A(label, shortcut, false, true);
+  } else {
+    const shortcut: string | null = args[0];
+    if (typeof (args[1]) === "boolean") {
+      const selected: boolean = args[1];
+      const enabled: boolean = typeof (args[2]) === "boolean" ? args[2] : true;
+      return bind.MenuItem_A(label, shortcut, selected, enabled);
     } else {
-        const shortcut: string | null = args[0];
-        if (typeof(args[1]) === "boolean") {
-            const selected: boolean = args[1];
-            const enabled: boolean = typeof(args[2]) === "boolean" ? args[2] : true;
-            return bind.MenuItem_A(label, shortcut, selected, enabled);
-        } else {
-            const p_selected: Bind.ImScalar<boolean> | Bind.ImAccess<boolean> = args[1];
-            const enabled: boolean = typeof(args[2]) === "boolean" ? args[2] : true;
-            const ref_selected: Bind.ImScalar<boolean> = Array.isArray(p_selected) ? p_selected : [ p_selected() ];
-            const ret = bind.MenuItem_B(label, shortcut, ref_selected, enabled);
-            if (!Array.isArray(p_selected)) { p_selected(ref_selected[0]); }
-            return ret;
-        }
+      const p_selected: Bind.ImScalar<boolean> | Bind.ImAccess<boolean> = args[1];
+      const enabled: boolean = typeof (args[2]) === "boolean" ? args[2] : true;
+      const ref_selected: Bind.ImScalar<boolean> = Array.isArray(p_selected) ? p_selected : [p_selected()];
+      const ret = bind.MenuItem_B(label, shortcut, ref_selected, enabled);
+      if (!Array.isArray(p_selected)) { p_selected(ref_selected[0]); }
+      return ret;
     }
+  }
 }
 
 // Tooltips
@@ -4382,16 +4337,16 @@ export function SetTooltip(fmt: string): void { bind.SetTooltip(fmt); }
 // IMGUI_API void          EndPopup();                                                                         // only call EndPopup() if BeginPopupXXX() returns true!
 export function BeginPopup(str_id: string, flags: ImGuiWindowFlags = 0): boolean { return bind.BeginPopup(str_id, flags); }
 export function BeginPopupModal(str_id: string, p_open: Bind.ImScalar<boolean> | Bind.ImAccess<boolean> | null = null, flags: ImGuiWindowFlags = 0): boolean {
-    if (Array.isArray(p_open)) {
-        return bind.BeginPopupModal(str_id, p_open, flags);
-    } else if (typeof(p_open) === "function") {
-        const _p_open: Bind.ImScalar<boolean> = [ p_open() ];
-        const ret = bind.BeginPopupModal(str_id, _p_open, flags);
-        p_open(_p_open[0]);
-        return ret;
-    } else {
-        return bind.BeginPopupModal(str_id, null, flags);
-    }
+  if (Array.isArray(p_open)) {
+    return bind.BeginPopupModal(str_id, p_open, flags);
+  } else if (typeof (p_open) === "function") {
+    const _p_open: Bind.ImScalar<boolean> = [p_open()];
+    const ret = bind.BeginPopupModal(str_id, _p_open, flags);
+    p_open(_p_open[0]);
+    return ret;
+  } else {
+    return bind.BeginPopupModal(str_id, null, flags);
+  }
 }
 export function EndPopup(): void { bind.EndPopup(); }
 // Popups: open/close functions
@@ -4483,8 +4438,8 @@ export function TableHeader(label: string): void { bind.TableHeader(label); }
 // - Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable().
 // IMGUI_API ImGuiTableSortSpecs* TableGetSortSpecs();                        // get latest sort specs for the table (NULL if not sorting).
 export function TableGetSortSpecs(): ImGuiTableSortSpecs | null {
-    const sort_specs: Bind.reference_ImGuiTableSortSpecs | null = bind.TableGetSortSpecs();
-    return (sort_specs === null) ? null : new ImGuiTableSortSpecs(sort_specs);
+  const sort_specs: Bind.reference_ImGuiTableSortSpecs | null = bind.TableGetSortSpecs();
+  return (sort_specs === null) ? null : new ImGuiTableSortSpecs(sort_specs);
 }
 // Tables: Miscellaneous functions
 // - Functions args 'int column_n' treat the default value of -1 as the same as passing the current column index.
@@ -4530,16 +4485,16 @@ export function GetColumnsCount(): number { return bind.GetColumnsCount(); }
 export function BeginTabBar(str_id: string, flags: ImGuiTabBarFlags = 0): boolean { return bind.BeginTabBar(str_id, flags); }
 export function EndTabBar(): void { bind.EndTabBar(); }
 export function BeginTabItem(label: string, p_open: Bind.ImScalar<boolean> | Bind.ImAccess<boolean> | null = null, flags: ImGuiTabItemFlags = 0): boolean {
-    if (p_open === null) {
-        return bind.BeginTabItem(label, null, flags);
-    } else if (Array.isArray(p_open)) {
-        return bind.BeginTabItem(label, p_open, flags);
-    } else {
-        const ref_open: Bind.ImScalar<boolean> = [ p_open() ];
-        const ret = bind.BeginTabItem(label, ref_open, flags);
-        p_open(ref_open[0]);
-        return ret;
-    }
+  if (p_open === null) {
+    return bind.BeginTabItem(label, null, flags);
+  } else if (Array.isArray(p_open)) {
+    return bind.BeginTabItem(label, p_open, flags);
+  } else {
+    const ref_open: Bind.ImScalar<boolean> = [p_open()];
+    const ret = bind.BeginTabItem(label, ref_open, flags);
+    p_open(ref_open[0]);
+    return ret;
+  }
 }
 export function EndTabItem(): void { bind.EndTabItem(); }
 export function TabItemButton(label: string, flags: ImGuiTabItemFlags = 0): boolean { return bind.TabItemButton(label, flags); }
@@ -4569,29 +4524,29 @@ export function LogText(fmt: string): void { bind.LogText(fmt); }
 // IMGUI_API const ImGuiPayload*   AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);          // accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
 // IMGUI_API void                  EndDragDropTarget();                                                            // only call EndDragDropTarget() if BeginDragDropTarget() returns true!
 // IMGUI_API const ImGuiPayload*   GetDragDropPayload();                                                           // peek directly into the current payload from anywhere. may return NULL. use ImGuiPayload::IsDataType() to test for the payload type.
-const _ImGui_DragDropPayload_data: {[key: string]: any} = {};
+const _ImGui_DragDropPayload_data: { [key: string]: any } = {};
 export function BeginDragDropSource(flags: ImGuiDragDropFlags = 0): boolean {
-    return bind.BeginDragDropSource(flags);
+  return bind.BeginDragDropSource(flags);
 }
 export function SetDragDropPayload<T>(type: string, data: T, cond: ImGuiCond = 0): boolean {
-    _ImGui_DragDropPayload_data[type] = data;
-    return bind.SetDragDropPayload(type, data, 0, cond);
+  _ImGui_DragDropPayload_data[type] = data;
+  return bind.SetDragDropPayload(type, data, 0, cond);
 }
 export function EndDragDropSource(): void {
-    bind.EndDragDropSource();
+  bind.EndDragDropSource();
 }
 export function BeginDragDropTarget(): boolean {
-    return bind.BeginDragDropTarget();
+  return bind.BeginDragDropTarget();
 }
 export function AcceptDragDropPayload<T>(type: string, flags: ImGuiDragDropFlags = 0): ImGuiPayload<T> | null {
-    const data: T = _ImGui_DragDropPayload_data[type];
-    return bind.AcceptDragDropPayload(type, flags) ? { Data: data } : null;
+  const data: T = _ImGui_DragDropPayload_data[type];
+  return bind.AcceptDragDropPayload(type, flags) ? { Data: data } : null;
 }
 export function EndDragDropTarget(): void {
-    bind.EndDragDropTarget();
+  bind.EndDragDropTarget();
 }
 export function GetDragDropPayload<T>(): ImGuiPayload<T> | null {
-    return bind.GetDragDropPayload();
+  return bind.GetDragDropPayload();
 }
 
 // Clipping
@@ -4599,10 +4554,10 @@ export function GetDragDropPayload<T>(): ImGuiPayload<T> | null {
 // IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);
 // IMGUI_API void          PopClipRect();
 export function PushClipRect(clip_rect_min: Readonly<Bind.interface_ImVec2>, clip_rect_max: Readonly<Bind.interface_ImVec2>, intersect_with_current_clip_rect: boolean): void {
-    bind.PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
+  bind.PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
 }
 export function PopClipRect(): void {
-    bind.PopClipRect();
+  bind.PopClipRect();
 }
 
 // Focus, Activation
@@ -4667,31 +4622,31 @@ export function SetItemAllowOverlap(): void { bind.SetItemAllowOverlap(); }
 export function IsRectVisible(size: Readonly<Bind.interface_ImVec2>): boolean;
 export function IsRectVisible(rect_min: Readonly<Bind.interface_ImVec2>, rect_max: Readonly<Bind.interface_ImVec2>): boolean;
 export function IsRectVisible(...args: any[]): boolean {
-    if (args.length === 1) {
-        const size: Readonly<Bind.interface_ImVec2> = args[0];
-        return bind.IsRectVisible_A(size);
-    } else {
-        const rect_min: Readonly<Bind.interface_ImVec2> = args[0];
-        const rect_max: Readonly<Bind.interface_ImVec2> = args[1];
-        return bind.IsRectVisible_B(rect_min, rect_max);
-    }
+  if (args.length === 1) {
+    const size: Readonly<Bind.interface_ImVec2> = args[0];
+    return bind.IsRectVisible_A(size);
+  } else {
+    const rect_min: Readonly<Bind.interface_ImVec2> = args[0];
+    const rect_max: Readonly<Bind.interface_ImVec2> = args[1];
+    return bind.IsRectVisible_B(rect_min, rect_max);
+  }
 }
 export function GetTime(): number { return bind.GetTime(); }
 export function GetFrameCount(): number { return bind.GetFrameCount(); }
 export function GetBackgroundDrawList(): ImDrawList {
-    return new ImDrawList(bind.GetBackgroundDrawList());
+  return new ImDrawList(bind.GetBackgroundDrawList());
 }
 export function GetForegroundDrawList(): ImDrawList {
-    return new ImDrawList(bind.GetForegroundDrawList());
+  return new ImDrawList(bind.GetForegroundDrawList());
 }
 export function GetDrawListSharedData(): ImDrawListSharedData {
-    return new ImDrawListSharedData(bind.GetDrawListSharedData());
+  return new ImDrawListSharedData(bind.GetDrawListSharedData());
 }
 export function GetStyleColorName(idx: ImGuiCol): string { return bind.GetStyleColorName(idx); }
 // IMGUI_API void          SetStateStorage(ImGuiStorage* tree);
 // IMGUI_API ImGuiStorage* GetStateStorage();
 export function CalcListClipping(items_count: number, items_height: number, out_items_display_start: Bind.ImScalar<number>, out_items_display_end: Bind.ImScalar<number>): void {
-    return bind.CalcListClipping(items_count, items_height, out_items_display_start, out_items_display_end);
+  return bind.CalcListClipping(items_count, items_height, out_items_display_start, out_items_display_end);
 }
 export function BeginChildFrame(id: ImGuiID, size: Readonly<Bind.interface_ImVec2>, flags: ImGuiWindowFlags = 0): boolean { return bind.BeginChildFrame(id, size, flags); }
 export function EndChildFrame(): void { bind.EndChildFrame(); }
@@ -4699,7 +4654,7 @@ export function EndChildFrame(): void { bind.EndChildFrame(); }
 // Text Utilities
 // IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);
 export function CalcTextSize(text: string, text_end: number | null = null, hide_text_after_double_hash: boolean = false, wrap_width: number = -1, out: Bind.interface_ImVec2 = new ImVec2()): Bind.interface_ImVec2 {
-    return bind.CalcTextSize(text_end !== null ? text.substring(0, text_end) : text, hide_text_after_double_hash, wrap_width, out);
+  return bind.CalcTextSize(text_end !== null ? text.substring(0, text_end) : text, hide_text_after_double_hash, wrap_width, out);
 }
 
 // Color Utilities
@@ -4785,7 +4740,7 @@ export function SaveIniSettingsToMemory(out_ini_size: Bind.ImScalar<number> | nu
 // Debug Utilities
 // IMGUI_API bool          DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert, size_t sz_drawidx); // This is called by IMGUI_CHECKVERSION() macro.
 export function DebugCheckVersionAndDataLayout(version_str: string, sz_io: number, sz_style: number, sz_vec2: number, sz_vec4: number, sz_draw_vert: number, sz_draw_idx: number): boolean {
-    return bind.DebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_draw_vert, sz_draw_idx);
+  return bind.DebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_draw_vert, sz_draw_idx);
 }
 
 // Memory Allocators
@@ -4795,120 +4750,115 @@ export function DebugCheckVersionAndDataLayout(version_str: string, sz_io: numbe
 // IMGUI_API void*         MemAlloc(size_t size);
 // IMGUI_API void          MemFree(void* ptr);
 export function SetAllocatorFunctions(alloc_func: (sz: number, user_data: any) => number, free_func: (ptr: number, user_data: any) => void, user_data: any = null): void {
-    bind.SetAllocatorFunctions(alloc_func, free_func, user_data);
+  bind.SetAllocatorFunctions(alloc_func, free_func, user_data);
 }
 export function MemAlloc(sz: number): void { bind.MemAlloc(sz); }
 export function MemFree(ptr: any): void { bind.MemFree(ptr); }
 
-export { ImGuiWindow as Window }
-export class ImGuiWindow
-{
-    constructor(public readonly native: Bind.reference_ImGuiWindow) {}
+export { ImGuiWindow as Window };
+export class ImGuiWindow {
+  constructor(public readonly native: Bind.reference_ImGuiWindow) {}
 
-    get ID(): ImGuiID { return this.native.ID; }
-    get Flags():ImGuiWindowFlags {return this.native.Flags;}
-    set Flags(f:ImGuiWindowFlags) {this.native.Flags=f;}
+  get ID(): ImGuiID { return this.native.ID; }
+  get Flags(): ImGuiWindowFlags { return this.native.Flags; }
+  set Flags(f: ImGuiWindowFlags) { this.native.Flags = f; }
 
-    get Pos(): Bind.interface_ImVec2 { return this.native.Pos; }
-    set Pos(v: Bind.interface_ImVec2) {this.native.Pos.Set(v.x, v.y);}
+  get Pos(): Bind.interface_ImVec2 { return this.native.Pos; }
+  set Pos(v: Bind.interface_ImVec2) { this.native.Pos.Set(v.x, v.y); }
 
-    get Size(): Bind.interface_ImVec2 { return this.native.Size; }
-    set Size(v:Bind.interface_ImVec2) {this.native.Size.Set(v.x, v.y);}
+  get Size(): Bind.interface_ImVec2 { return this.native.Size; }
+  set Size(v: Bind.interface_ImVec2) { this.native.Size.Set(v.x, v.y); }
 
-    get SizeFull(): Bind.interface_ImVec2 { return this.native.SizeFull; }
-    set SizeFull(v:Bind.interface_ImVec2) {this.native.SizeFull.Set(v.x, v.y);}
+  get SizeFull(): Bind.interface_ImVec2 { return this.native.SizeFull; }
+  set SizeFull(v: Bind.interface_ImVec2) { this.native.SizeFull.Set(v.x, v.y); }
 
-    get ContentSize(): Bind.interface_ImVec2 { return this.native.ContentSize; }
-    set ContentSize(v:Bind.interface_ImVec2) {this.native.ContentSize.Set(v.x, v.y);}
+  get ContentSize(): Bind.interface_ImVec2 { return this.native.ContentSize; }
+  set ContentSize(v: Bind.interface_ImVec2) { this.native.ContentSize.Set(v.x, v.y); }
 
-    get ContentSizeIdeal(): Bind.interface_ImVec2 { return this.native.ContentSizeIdeal; }
-    set ContentSizeIdeal(v:Bind.interface_ImVec2) {this.native.ContentSizeIdeal.Set(v.x, v.y);}
+  get ContentSizeIdeal(): Bind.interface_ImVec2 { return this.native.ContentSizeIdeal; }
+  set ContentSizeIdeal(v: Bind.interface_ImVec2) { this.native.ContentSizeIdeal.Set(v.x, v.y); }
 
-    get ContentSizeExplicit(): Bind.interface_ImVec2 { return this.native.ContentSizeExplicit; }
-    set ContentSizeExplicit(v:Bind.interface_ImVec2) {this.native.ContentSizeExplicit.Set(v.x, v.y);}
+  get ContentSizeExplicit(): Bind.interface_ImVec2 { return this.native.ContentSizeExplicit; }
+  set ContentSizeExplicit(v: Bind.interface_ImVec2) { this.native.ContentSizeExplicit.Set(v.x, v.y); }
 
-    get WindowPadding(): Bind.interface_ImVec2 { return this.native.WindowPadding; }
-    set WindowPadding(v:Bind.interface_ImVec2) {this.native.WindowPadding.Set(v.x, v.y);}
+  get WindowPadding(): Bind.interface_ImVec2 { return this.native.WindowPadding; }
+  set WindowPadding(v: Bind.interface_ImVec2) { this.native.WindowPadding.Set(v.x, v.y); }
 
-    get WindowRounding():number {return this.native.WindowRounding;}
-    set WindowRounding(v:number) {this.native.WindowRounding=v;}
-    get WindowBorderSize():number {return this.native.WindowBorderSize;}
-    set WindowBorderSize(v:number) {this.native.WindowBorderSize=v;}
+  get WindowRounding(): number { return this.native.WindowRounding; }
+  set WindowRounding(v: number) { this.native.WindowRounding = v; }
+  get WindowBorderSize(): number { return this.native.WindowBorderSize; }
+  set WindowBorderSize(v: number) { this.native.WindowBorderSize = v; }
 
-    get Scroll(): Bind.interface_ImVec2 { return this.native.Scroll; }
-    set Scroll(v:Bind.interface_ImVec2) {this.native.Scroll.Set(v.x, v.y);}
+  get Scroll(): Bind.interface_ImVec2 { return this.native.Scroll; }
+  set Scroll(v: Bind.interface_ImVec2) { this.native.Scroll.Set(v.x, v.y); }
 
-    get ScrollMax(): Bind.interface_ImVec2 { return this.native.ScrollMax; }
-    set ScrollMax(v:Bind.interface_ImVec2) {this.native.ScrollMax.Set(v.x, v.y);}
+  get ScrollMax(): Bind.interface_ImVec2 { return this.native.ScrollMax; }
+  set ScrollMax(v: Bind.interface_ImVec2) { this.native.ScrollMax.Set(v.x, v.y); }
 
-    get ScrollTarget(): Bind.interface_ImVec2 { return this.native.ScrollTarget; }
-    set ScrollTarget(v:Bind.interface_ImVec2) {this.native.ScrollTarget.Set(v.x, v.y);}
+  get ScrollTarget(): Bind.interface_ImVec2 { return this.native.ScrollTarget; }
+  set ScrollTarget(v: Bind.interface_ImVec2) { this.native.ScrollTarget.Set(v.x, v.y); }
 
-    get ScrollTargetCenterRatio(): Bind.interface_ImVec2 { return this.native.ScrollTargetCenterRatio; }
-    set ScrollTargetCenterRatio(v:Bind.interface_ImVec2) {this.native.ScrollTargetCenterRatio.Set(v.x, v.y);}
+  get ScrollTargetCenterRatio(): Bind.interface_ImVec2 { return this.native.ScrollTargetCenterRatio; }
+  set ScrollTargetCenterRatio(v: Bind.interface_ImVec2) { this.native.ScrollTargetCenterRatio.Set(v.x, v.y); }
 
-    get ScrollTargetEdgeSnapDist(): Bind.interface_ImVec2 { return this.native.ScrollTargetEdgeSnapDist; }
-    set ScrollTargetEdgeSnapDist(v:Bind.interface_ImVec2) {this.native.ScrollTargetEdgeSnapDist.Set(v.x, v.y);}
+  get ScrollTargetEdgeSnapDist(): Bind.interface_ImVec2 { return this.native.ScrollTargetEdgeSnapDist; }
+  set ScrollTargetEdgeSnapDist(v: Bind.interface_ImVec2) { this.native.ScrollTargetEdgeSnapDist.Set(v.x, v.y); }
 
-    get ScrollbarSizes(): Bind.interface_ImVec2 { return this.native.ScrollbarSizes; }
-    set ScrollbarSizes(v:Bind.interface_ImVec2) {this.native.ScrollbarSizes.Set(v.x, v.y);}
+  get ScrollbarSizes(): Bind.interface_ImVec2 { return this.native.ScrollbarSizes; }
+  set ScrollbarSizes(v: Bind.interface_ImVec2) { this.native.ScrollbarSizes.Set(v.x, v.y); }
 
-    get ScrollbarX():boolean {return this.native.ScrollbarX;}
-    get ScrollbarY():boolean {return this.native.ScrollbarY;}
-    get Active():boolean {return this.native.Active;}
-    get WasActive():boolean {return this.native.WasActive;}
+  get ScrollbarX(): boolean { return this.native.ScrollbarX; }
+  get ScrollbarY(): boolean { return this.native.ScrollbarY; }
+  get Active(): boolean { return this.native.Active; }
+  get WasActive(): boolean { return this.native.WasActive; }
 
-    get ItemWidthDefault():number {return this.native.ItemWidthDefault;}
-    set ItemWidthDefault(v:number) {this.native.ItemWidthDefault=v;}
+  get ItemWidthDefault(): number { return this.native.ItemWidthDefault; }
+  set ItemWidthDefault(v: number) { this.native.ItemWidthDefault = v; }
 
-    get ParentWindow():ImGuiWindow {return this.native.ParentWindow?new ImGuiWindow(this.native.ParentWindow):null;}
-    get RootWindow():ImGuiWindow {return this.native.RootWindow?new ImGuiWindow(this.native.RootWindow):null;}
-    get RootWindowForTitleBarHighlight():ImGuiWindow {return this.native.RootWindowForTitleBarHighlight?new ImGuiWindow(this.native.RootWindowForTitleBarHighlight):null;}
-    get RootWindowForNav():ImGuiWindow {return this.native.RootWindowForNav?new ImGuiWindow(this.native.RootWindowForNav):null;}
+  get ParentWindow(): ImGuiWindow { return this.native.ParentWindow ? new ImGuiWindow(this.native.ParentWindow) : null; }
+  get RootWindow(): ImGuiWindow { return this.native.RootWindow ? new ImGuiWindow(this.native.RootWindow) : null; }
+  get RootWindowForTitleBarHighlight(): ImGuiWindow { return this.native.RootWindowForTitleBarHighlight ? new ImGuiWindow(this.native.RootWindowForTitleBarHighlight) : null; }
+  get RootWindowForNav(): ImGuiWindow { return this.native.RootWindowForNav ? new ImGuiWindow(this.native.RootWindowForNav) : null; }
 }
 
-export { ImGuiInputTextState as InputTextState }
-export class ImGuiInputTextState
-{
-    constructor(public readonly native: Bind.reference_ImGuiInputTextState) {}
+export { ImGuiInputTextState as InputTextState };
+export class ImGuiInputTextState {
+  constructor(public readonly native: Bind.reference_ImGuiInputTextState) {}
 
-    get ID(): ImGuiID { return this.native.ID; }
-    get Flags():ImGuiInputTextFlags {return this.native.Flags;}
+  get ID(): ImGuiID { return this.native.ID; }
+  get Flags(): ImGuiInputTextFlags { return this.native.Flags; }
 
-    get FrameBB():Readonly<Bind.interface_ImRect> {return this.native.FrameBB;}
+  get FrameBB(): Readonly<Bind.interface_ImRect> { return this.native.FrameBB; }
 
-    get Text():string {return this.native.Text;}
-    set Text(t:string) {this.native.Text=t;}
+  get Text(): string { return this.native.Text; }
+  set Text(t: string) { this.native.Text = t; }
 }
 
 export function GetCurrentWindow(): ImGuiWindow { return new ImGuiWindow(bind.GetCurrentWindow()); }
-export function GetHoveredWindow(): ImGuiWindow { return bind.GetHoveredWindow()?new ImGuiWindow(bind.GetHoveredWindow()):null; }
-export function GetHoveredRootWindow(): ImGuiWindow { return bind.GetHoveredRootWindow()?new ImGuiWindow(bind.GetHoveredRootWindow()):null; }
-export function GetActiveWindow(): ImGuiWindow { return bind.GetActiveWindow()?new ImGuiWindow(bind.GetActiveWindow()):null; }
-
-export function GetHoveredId():ImGuiID {return bind.GetHoveredId();}
-export function GetHoveredIdPreviousFrame():ImGuiID {return bind.GetHoveredIdPreviousFrame();}
-export function GetActiveId():ImGuiID {return bind.GetActiveId();}
-export function GetActiveIdPreviousFrame():ImGuiID {return bind.GetActiveIdPreviousFrame();}
-export function SetActiveId(id:ImGuiID) {return bind.SetActiveId(id);}
-
-export function GetInputTextState(id:ImGuiID): ImGuiInputTextState { return new ImGuiInputTextState(bind.GetInputTextState(id)); }
-export function GetInputTextId():ImGuiID {return bind.GetInputTextId();}
-
-export function Vec4_toRGBA(col:ImVec4):string
-{
-    return "rgba("+col.x*255+","+col.y*255+","+col.z*255+","+col.w*255+")";
-}
-export function Font_toString(font:ImFont):string
-{
-    return font.FontStyle + " " + font.FontSize + "px " + font.FontName;
-}
-export function CreateFont(name:string, size:number, style?:string):ImFont
-{
-    const io=GetIO();
-    let font =io.Fonts.AddFontDefault();
-    font.FontStyle=style;
-    font.FontName=name;
-    font.FontSize=size;
-    return font;
+export function GetHoveredWindow(): ImGuiWindow { return bind.GetHoveredWindow() ? new ImGuiWindow(bind.GetHoveredWindow()) : null; }
+export function GetHoveredRootWindow(): ImGuiWindow { return bind.GetHoveredRootWindow() ? new ImGuiWindow(bind.GetHoveredRootWindow()) : null; }
+export function GetActiveWindow(): ImGuiWindow { return bind.GetActiveWindow() ? new ImGuiWindow(bind.GetActiveWindow()) : null; }
+
+export function GetHoveredId(): ImGuiID { return bind.GetHoveredId(); }
+export function GetHoveredIdPreviousFrame(): ImGuiID { return bind.GetHoveredIdPreviousFrame(); }
+export function GetActiveId(): ImGuiID { return bind.GetActiveId(); }
+export function GetActiveIdPreviousFrame(): ImGuiID { return bind.GetActiveIdPreviousFrame(); }
+export function SetActiveId(id: ImGuiID) { return bind.SetActiveId(id); }
+
+export function GetInputTextState(id: ImGuiID): ImGuiInputTextState { return new ImGuiInputTextState(bind.GetInputTextState(id)); }
+export function GetInputTextId(): ImGuiID { return bind.GetInputTextId(); }
+
+export function Vec4_toRGBA(col: ImVec4): string {
+  return "rgba(" + col.x * 255 + "," + col.y * 255 + "," + col.z * 255 + "," + col.w * 255 + ")";
+}
+export function Font_toString(font: ImFont): string {
+  return font.FontStyle + " " + font.FontSize + "px " + font.FontName;
+}
+export function CreateFont(name: string, size: number, style?: string): ImFont {
+  const io = GetIO();
+  let font = io.Fonts.AddFontDefault();
+  font.FontStyle = style;
+  font.FontName = name;
+  font.FontSize = size;
+  return font;
 }
diff --git a/node_modules/@zhobo63/imgui-ts/src/imgui_impl.ts b/node_modules/@zhobo63/imgui-ts/src/imgui_impl.ts
index 2a40847..cc3a4d0 100644
--- a/node_modules/@zhobo63/imgui-ts/src/imgui_impl.ts
+++ b/node_modules/@zhobo63/imgui-ts/src/imgui_impl.ts
@@ -1,3 +1,4 @@
+// @ts-nocheck
 import { Font } from "./font";
 import * as ImGui from "./imgui";
 import * as Input from "./input";
@@ -6,14 +7,14 @@ let clipboard_text: string = "";
 
 export let canvas: HTMLCanvasElement | null = null;
 
-export let canvas_scale:number=ImGui.isMobile.any()?1:window.devicePixelRatio;
-export let font_scale:number=Math.max(window.devicePixelRatio, 1.5);
+export let canvas_scale: number = ImGui.isMobile.any() ? 1 : window.devicePixelRatio;
+export let font_scale: number = Math.max(window.devicePixelRatio, 1.5);
 
-export function setCanvasScale(scale:number):void {
-    canvas_scale=scale;
+export function setCanvasScale(scale: number): void {
+  canvas_scale = scale;
 }
-export function setFontScale(scale:number):void {
-    font_scale=scale;
+export function setFontScale(scale: number): void {
+  font_scale = scale;
 }
 
 export let gl: WebGL2RenderingContext | WebGLRenderingContext | null = null;
@@ -28,131 +29,131 @@ let g_AttribLocationColor: GLint = -1;
 let g_VboHandle: WebGLBuffer | null = null;
 let g_ElementsHandle: WebGLBuffer | null = null;
 let g_FontTexture: WebGLTexture | null = null;
-const enable_vao:boolean=true;
-let g_vao:WebGLVertexArrayObject;
-let has_videoframe:boolean=typeof VideoFrame !== "undefined";
+const enable_vao: boolean = true;
+let g_vao: WebGLVertexArrayObject;
+let has_videoframe: boolean = typeof VideoFrame !== "undefined";
 
 export let ctx: CanvasRenderingContext2D | null = null;
 
 let prev_time: number = 0;
 
 function document_on_copy(event: ClipboardEvent): void {
-    if (event.clipboardData) {
-        event.clipboardData.setData("text/plain", clipboard_text);
-    }
-    // console.log(`${event.type}: "${clipboard_text}"`);
-    event.preventDefault();
+  if (event.clipboardData) {
+    event.clipboardData.setData("text/plain", clipboard_text);
+  }
+  // console.log(`${event.type}: "${clipboard_text}"`);
+  event.preventDefault();
 }
 
 function document_on_cut(event: ClipboardEvent): void {
-    if (event.clipboardData) {
-        event.clipboardData.setData("text/plain", clipboard_text);
-    }
-    // console.log(`${event.type}: "${clipboard_text}"`);
-    event.preventDefault();
+  if (event.clipboardData) {
+    event.clipboardData.setData("text/plain", clipboard_text);
+  }
+  // console.log(`${event.type}: "${clipboard_text}"`);
+  event.preventDefault();
 }
 
 function document_on_paste(event: ClipboardEvent): void {
-    if (event.clipboardData) {
-        clipboard_text = event.clipboardData.getData("text/plain");
-    }
-    // console.log(`${event.type}: "${clipboard_text}"`);
-    event.preventDefault();
+  if (event.clipboardData) {
+    clipboard_text = event.clipboardData.getData("text/plain");
+  }
+  // console.log(`${event.type}: "${clipboard_text}"`);
+  event.preventDefault();
 }
 
 function window_on_resize(): void {
-    if (canvas !== null) {
-        canvas.width = canvas.scrollWidth*canvas_scale;
-        canvas.height = canvas.scrollHeight*canvas_scale;
-        //canvas.width = canvas.scrollWidth;
-        //canvas.height = canvas.scrollHeight;
-    }
+  if (canvas !== null) {
+    canvas.width = canvas.scrollWidth * canvas_scale;
+    canvas.height = canvas.scrollHeight * canvas_scale;
+    //canvas.width = canvas.scrollWidth;
+    //canvas.height = canvas.scrollHeight;
+  }
 }
 
 function window_on_gamepadconnected(event: any /* GamepadEvent */): void {
-    console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
+  console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
     event.gamepad.index, event.gamepad.id,
     event.gamepad.buttons.length, event.gamepad.axes.length);
 }
 
 function window_on_gamepaddisconnected(event: any /* GamepadEvent */): void {
-    console.log("Gamepad disconnected at index %d: %s.",
+  console.log("Gamepad disconnected at index %d: %s.",
     event.gamepad.index, event.gamepad.id);
 }
 
 function canvas_on_blur(event: FocusEvent): void {
-    const io = ImGui.GetIO();
-    io.KeyCtrl = false;
-    io.KeyShift = false;
-    io.KeyAlt = false;
-    io.KeySuper = false;
-    for (let i = 0; i < io.KeysDown.length; ++i) {
-        io.KeysDown[i] = false;
-    }
-    for (let i = 0; i < io.MouseDown.length; ++i) {
-        io.MouseDown[i] = false;
-    }
-    console.log("canvas_on_blur");
+  const io = ImGui.GetIO();
+  io.KeyCtrl = false;
+  io.KeyShift = false;
+  io.KeyAlt = false;
+  io.KeySuper = false;
+  for (let i = 0; i < io.KeysDown.length; ++i) {
+    io.KeysDown[i] = false;
+  }
+  for (let i = 0; i < io.MouseDown.length; ++i) {
+    io.MouseDown[i] = false;
+  }
+  console.log("canvas_on_blur");
 }
 
 const key_code_to_index: Record<string, number> = {
-    "Tab":9,
-    "Enter":13,
-    "Escape":27,
-    "ArrowLeft":37,
-    "ArrowUp":38,
-    "ArrowRight":39,
-    "ArrowDown":40,
-    "NumpadEnter": 176,
+  "Tab": 9,
+  "Enter": 13,
+  "Escape": 27,
+  "ArrowLeft": 37,
+  "ArrowUp": 38,
+  "ArrowRight": 39,
+  "ArrowDown": 40,
+  "NumpadEnter": 176,
 };
 
 function canvas_on_keydown(event: KeyboardEvent): void {
-    const key_index: number = key_code_to_index[event.code] || event.key.charCodeAt(0);
-    //console.log(event.type, event.key, event.code, key_index);
-    const io = ImGui.GetIO();
-    io.KeyCtrl = event.ctrlKey;
-    io.KeyShift = event.shiftKey;
-    io.KeyAlt = event.altKey;
-    io.KeySuper = event.metaKey;
-    ImGui.ASSERT(key_index >= 0 && key_index < ImGui.ARRAYSIZE(io.KeysDown));
-    io.KeysDown[key_index] = true;
-    // forward to the keypress event
-    if (/*io.WantCaptureKeyboard ||*/ key_index == 9) {
-        event.preventDefault();
-    }
+  const key_index: number = key_code_to_index[event.code] || event.key.charCodeAt(0);
+  //console.log(event.type, event.key, event.code, key_index);
+  const io = ImGui.GetIO();
+  io.KeyCtrl = event.ctrlKey;
+  io.KeyShift = event.shiftKey;
+  io.KeyAlt = event.altKey;
+  io.KeySuper = event.metaKey;
+  ImGui.ASSERT(key_index >= 0 && key_index < ImGui.ARRAYSIZE(io.KeysDown));
+  io.KeysDown[key_index] = true;
+  // forward to the keypress event
+  if (/*io.WantCaptureKeyboard ||*/ key_index == 9) {
+    event.preventDefault();
+  }
 }
 
-function canvas_on_keyup(event: KeyboardEvent): void  {
-    const key_index: number = key_code_to_index[event.code] || event.key.charCodeAt(0);
-    //console.log(event.type, event.key, event.code, key_index);
-    const io = ImGui.GetIO();
-    io.KeyCtrl = event.ctrlKey;
-    io.KeyShift = event.shiftKey;
-    io.KeyAlt = event.altKey;
-    io.KeySuper = event.metaKey;
-    ImGui.ASSERT(key_index >= 0 && key_index < ImGui.ARRAYSIZE(io.KeysDown));
-    io.KeysDown[key_index] = false;
-    if (io.WantCaptureKeyboard || key_index == 9) {
-        event.preventDefault();
-    }
+function canvas_on_keyup(event: KeyboardEvent): void {
+  const key_index: number = key_code_to_index[event.code] || event.key.charCodeAt(0);
+  //console.log(event.type, event.key, event.code, key_index);
+  const io = ImGui.GetIO();
+  io.KeyCtrl = event.ctrlKey;
+  io.KeyShift = event.shiftKey;
+  io.KeyAlt = event.altKey;
+  io.KeySuper = event.metaKey;
+  ImGui.ASSERT(key_index >= 0 && key_index < ImGui.ARRAYSIZE(io.KeysDown));
+  io.KeysDown[key_index] = false;
+  if (io.WantCaptureKeyboard || key_index == 9) {
+    event.preventDefault();
+  }
 }
 
-function canvas_on_keypress(event: KeyboardEvent): void  {
-    //console.log(event);
-    const io = ImGui.GetIO();
-    io.AddInputCharacter(event.charCode);
-    if (io.WantCaptureKeyboard) {
-        event.preventDefault();
-    }
+function canvas_on_keypress(event: KeyboardEvent): void {
+  //console.log(event);
+  const io = ImGui.GetIO();
+  io.AddInputCharacter(event.charCode);
+  if (io.WantCaptureKeyboard) {
+    event.preventDefault();
+  }
 }
 
-function canvas_on_pointermove(event: PointerEvent): void  {
-    const io = ImGui.GetIO();
-    io.MousePos.x = event.offsetX;
-    io.MousePos.y = event.offsetY;
-    if (io.WantCaptureMouse) {
-        event.preventDefault();
-    }
+function canvas_on_pointermove(event: PointerEvent): void {
+  const io = ImGui.GetIO();
+  io.MousePos.x = event.offsetX;
+  io.MousePos.y = event.offsetY;
+  if (io.WantCaptureMouse) {
+    event.preventDefault();
+  }
 }
 
 // MouseEvent.button
@@ -162,1315 +163,1295 @@ function canvas_on_pointermove(event: PointerEvent): void  {
 // 2: Secondary button pressed, usually the right button
 // 3: Fourth button, typically the Browser Back button
 // 4: Fifth button, typically the Browser Forward button
-const mouse_button_map: number[] = [ 0, 2, 1, 3, 4 ];
-
-export function any_pointerdown():boolean
-{
-    const io = ImGui.GetIO();
-    for(let i=0;i<io.MouseDown.length;i++)  {
-        if(io.MouseDown[i])
-            return true;
-    }            
-    return false;
+const mouse_button_map: number[] = [0, 2, 1, 3, 4];
+
+export function any_pointerdown(): boolean {
+  const io = ImGui.GetIO();
+  for (let i = 0; i < io.MouseDown.length; i++) {
+    if (io.MouseDown[i])
+      return true;
+  }
+  return false;
 }
 
-function canvas_on_pointerdown(event: PointerEvent): void  {
-    if(event.target!=canvas)
-        return;
-    const io = ImGui.GetIO();
-    io.MousePos.x = event.offsetX;
-    io.MousePos.y = event.offsetY;
-    io.MouseDown[mouse_button_map[event.button]] = true;
-    // if (io.WantCaptureMouse) {
-    //     event.preventDefault();
-    // }
-    //console.log("canvas_on_pointerdown", event);
+function canvas_on_pointerdown(event: PointerEvent): void {
+  if (event.target != canvas)
+    return;
+  const io = ImGui.GetIO();
+  io.MousePos.x = event.offsetX;
+  io.MousePos.y = event.offsetY;
+  io.MouseDown[mouse_button_map[event.button]] = true;
+  // if (io.WantCaptureMouse) {
+  //     event.preventDefault();
+  // }
+  //console.log("canvas_on_pointerdown", event);
 }
-function canvas_on_contextmenu(event: Event): void  {
-    const io = ImGui.GetIO();
-    if (io.WantCaptureMouse) {
-        event.preventDefault();
-    }
+function canvas_on_contextmenu(event: Event): void {
+  const io = ImGui.GetIO();
+  if (io.WantCaptureMouse) {
+    event.preventDefault();
+  }
 }
 
-function canvas_on_pointerup(event: PointerEvent): void  {
-    const io = ImGui.GetIO();
-    io.MouseDown[mouse_button_map[event.button]] = false;
-    if (io.WantCaptureMouse) {
-        event.preventDefault();
-    }
-    //console.log("canvas_on_pointerup", event);
+function canvas_on_pointerup(event: PointerEvent): void {
+  const io = ImGui.GetIO();
+  io.MouseDown[mouse_button_map[event.button]] = false;
+  if (io.WantCaptureMouse) {
+    event.preventDefault();
+  }
+  //console.log("canvas_on_pointerup", event);
 }
 
-function canvas_on_wheel(event: WheelEvent): void  {
-    const io = ImGui.GetIO();
-    let scale: number = 1.0;
-    switch (event.deltaMode) {
-        case event.DOM_DELTA_PIXEL: scale = 0.01; break;
-        case event.DOM_DELTA_LINE: scale = 0.2; break;
-        case event.DOM_DELTA_PAGE: scale = 1.0; break;
-    }
-    io.MouseWheelH = event.deltaX * scale;
-    io.MouseWheel = -event.deltaY * scale; // Mouse wheel: 1 unit scrolls about 5 lines text.
-    if (io.WantCaptureMouse) {
-        event.preventDefault();
-    }
+function canvas_on_wheel(event: WheelEvent): void {
+  const io = ImGui.GetIO();
+  let scale: number = 1.0;
+  switch (event.deltaMode) {
+    case event.DOM_DELTA_PIXEL: scale = 0.01; break;
+    case event.DOM_DELTA_LINE: scale = 0.2; break;
+    case event.DOM_DELTA_PAGE: scale = 1.0; break;
+  }
+  io.MouseWheelH = event.deltaX * scale;
+  io.MouseWheel = -event.deltaY * scale; // Mouse wheel: 1 unit scrolls about 5 lines text.
+  if (io.WantCaptureMouse) {
+    event.preventDefault();
+  }
 }
 
-let touch_count:number=0;
-let touch_id:number;
-export class ITouch
-{
-    x:number;
-    y:number;
+let touch_count: number = 0;
+let touch_id: number;
+export class ITouch {
+  x: number;
+  y: number;
 }
-export let multi_touch:{[key:number]:ITouch}={};
-
-function canvas_on_touchstart(event: TouchEvent):void {
-    for(let i=0;i<event.changedTouches.length;i++)  {
-        let touch=event.changedTouches[i];
-        touch_id=touch.identifier;        
-        multi_touch[touch.identifier]={x:touch.clientX, y:touch.clientY};
-    }
-    let mtouch=multi_touch[touch_id];
-    let io=ImGui.GetIO();
-    io.MousePos.x=mtouch.x;
-    io.MousePos.y=mtouch.y;
-    io.MouseDown[0]=true;
+export let multi_touch: { [key: number]: ITouch } = {};
+
+function canvas_on_touchstart(event: TouchEvent): void {
+  for (let i = 0; i < event.changedTouches.length; i++) {
+    let touch = event.changedTouches[i];
+    touch_id = touch.identifier;
+    multi_touch[touch.identifier] = { x: touch.clientX, y: touch.clientY };
+  }
+  let mtouch = multi_touch[touch_id];
+  let io = ImGui.GetIO();
+  io.MousePos.x = mtouch.x;
+  io.MousePos.y = mtouch.y;
+  io.MouseDown[0] = true;
 }
-function canvas_on_touchmove(event: TouchEvent):void {
-    for(let i=0;i<event.changedTouches.length;i++)  {
-        let touch=event.changedTouches[i];
-        multi_touch[touch.identifier]={x:touch.clientX, y:touch.clientY};
-    }
-    let mtouch=multi_touch[touch_id];
-    let io=ImGui.GetIO();
-    io.MousePos.x=mtouch.x;
-    io.MousePos.y=mtouch.y;
+function canvas_on_touchmove(event: TouchEvent): void {
+  for (let i = 0; i < event.changedTouches.length; i++) {
+    let touch = event.changedTouches[i];
+    multi_touch[touch.identifier] = { x: touch.clientX, y: touch.clientY };
+  }
+  let mtouch = multi_touch[touch_id];
+  let io = ImGui.GetIO();
+  io.MousePos.x = mtouch.x;
+  io.MousePos.y = mtouch.y;
 }
-function canvas_on_touchend(event: TouchEvent):void {
-    let io=ImGui.GetIO();
-    for(let i=0;i<event.changedTouches.length;i++)  {
-        let touch=event.changedTouches[i];
-        if(touch.identifier==touch_id)  {
-            io.MouseDown[0]=false;
-        }
-        delete multi_touch[touch.identifier];
-    }
-    touch_count++;
-    if(touch_count>=200)    {
-        multi_touch={}
-    }
+function canvas_on_touchend(event: TouchEvent): void {
+  let io = ImGui.GetIO();
+  for (let i = 0; i < event.changedTouches.length; i++) {
+    let touch = event.changedTouches[i];
+    if (touch.identifier == touch_id) {
+      io.MouseDown[0] = false;
+    }
+    delete multi_touch[touch.identifier];
+  }
+  touch_count++;
+  if (touch_count >= 200) {
+    multi_touch = {}
+  }
 }
-function canvas_on_touchcancel(event: TouchEvent):void {
-    canvas_on_touchend(event);
+function canvas_on_touchcancel(event: TouchEvent): void {
+  canvas_on_touchend(event);
 }
 
-export let is_contextlost:boolean=false;
-export function add_key_event():void {
-    window.addEventListener("keydown", canvas_on_keydown);
-    window.addEventListener("keyup", canvas_on_keyup);
-    window.addEventListener("keypress", canvas_on_keypress);
+export let is_contextlost: boolean = false;
+export function add_key_event(): void {
+  window.addEventListener("keydown", canvas_on_keydown);
+  window.addEventListener("keyup", canvas_on_keyup);
+  window.addEventListener("keypress", canvas_on_keypress);
 }
-export function remove_key_event():void {
-    window.removeEventListener("keydown", canvas_on_keydown);
-    window.removeEventListener("keyup", canvas_on_keyup);
-    window.removeEventListener("keypress", canvas_on_keypress);
+export function remove_key_event(): void {
+  window.removeEventListener("keydown", canvas_on_keydown);
+  window.removeEventListener("keyup", canvas_on_keyup);
+  window.removeEventListener("keypress", canvas_on_keypress);
 }
 
-export function add_pointer_event():void {
-    if(canvas) {
-        canvas.addEventListener("pointermove", canvas_on_pointermove);
-        canvas.addEventListener("wheel", canvas_on_wheel);
-        //canvas.addEventListener("pointerdown", canvas_on_pointerdown);
-        //canvas.addEventListener("pointerup", canvas_on_pointerup);
-        canvas.addEventListener("touchstart", canvas_on_touchstart);
-        canvas.addEventListener("touchmove", canvas_on_touchmove);
-        canvas.addEventListener("touchend", canvas_on_touchend);
-        canvas.addEventListener("touchcancel", canvas_on_touchcancel);
-    }
-    window.addEventListener("pointerdown", canvas_on_pointerdown);
-    window.addEventListener("pointerup", canvas_on_pointerup);
+export function add_pointer_event(): void {
+  if (canvas) {
+    canvas.addEventListener("pointermove", canvas_on_pointermove);
+    canvas.addEventListener("wheel", canvas_on_wheel);
+    //canvas.addEventListener("pointerdown", canvas_on_pointerdown);
+    //canvas.addEventListener("pointerup", canvas_on_pointerup);
+    canvas.addEventListener("touchstart", canvas_on_touchstart);
+    canvas.addEventListener("touchmove", canvas_on_touchmove);
+    canvas.addEventListener("touchend", canvas_on_touchend);
+    canvas.addEventListener("touchcancel", canvas_on_touchcancel);
+  }
+  window.addEventListener("pointerdown", canvas_on_pointerdown);
+  window.addEventListener("pointerup", canvas_on_pointerup);
 }
 
-export function remove_pointer_event():void {
-    if(canvas) {
-        canvas.removeEventListener("pointermove", canvas_on_pointermove);
-        canvas.removeEventListener("wheel", canvas_on_wheel);
-        //canvas.removeEventListener("pointerdown", canvas_on_pointerdown);
-        //canvas.removeEventListener("pointerup", canvas_on_pointerup);
-        canvas.removeEventListener("touchstart", canvas_on_touchstart);
-        canvas.removeEventListener("touchmove", canvas_on_touchmove);
-        canvas.removeEventListener("touchend", canvas_on_touchend);
-        canvas.removeEventListener("touchcancel", canvas_on_touchcancel);
-    }
-    window.removeEventListener("pointerdown", canvas_on_pointerdown);
-    window.removeEventListener("pointerup", canvas_on_pointerup);
+export function remove_pointer_event(): void {
+  if (canvas) {
+    canvas.removeEventListener("pointermove", canvas_on_pointermove);
+    canvas.removeEventListener("wheel", canvas_on_wheel);
+    //canvas.removeEventListener("pointerdown", canvas_on_pointerdown);
+    //canvas.removeEventListener("pointerup", canvas_on_pointerup);
+    canvas.removeEventListener("touchstart", canvas_on_touchstart);
+    canvas.removeEventListener("touchmove", canvas_on_touchmove);
+    canvas.removeEventListener("touchend", canvas_on_touchend);
+    canvas.removeEventListener("touchcancel", canvas_on_touchcancel);
+  }
+  window.removeEventListener("pointerdown", canvas_on_pointerdown);
+  window.removeEventListener("pointerup", canvas_on_pointerup);
 
 }
 
-function canvas_on_contextlost(e:Event):void {
-    e.preventDefault();
-    console.log("canvas_on_contextlost");
-    is_contextlost=true;
+function canvas_on_contextlost(e: Event): void {
+  e.preventDefault();
+  console.log("canvas_on_contextlost");
+  is_contextlost = true;
 }
 
-function canvas_on_contextrestored(e:Event):void {
-    console.log("canvas_on_contextrestored");
-    Init(canvas);
-    is_contextlost=false;
+function canvas_on_contextrestored(e: Event): void {
+  console.log("canvas_on_contextrestored");
+  Init(canvas);
+  is_contextlost = false;
 }
 
 export function Init(value: HTMLCanvasElement | WebGL2RenderingContext | WebGLRenderingContext | CanvasRenderingContext2D | null): void {
-    const io = ImGui.GetIO();
-
-    if (typeof(window) !== "undefined") {
-        io.BackendPlatformName = "imgui_impl_browser";
-        ImGui.LoadIniSettingsFromMemory(window.localStorage.getItem("imgui.ini") || "");
-    }
-    else {
-        io.BackendPlatformName = "imgui_impl_console";
-    }
-
-    if (typeof(navigator) !== "undefined") {
-        io.ConfigMacOSXBehaviors = navigator.platform.match(/Mac/) !== null;
-    }
-
-    /*
-    if (typeof(document) !== "undefined") {
-        document.body.addEventListener("copy", document_on_copy);
-        document.body.addEventListener("cut", document_on_cut);
-        document.body.addEventListener("paste", document_on_paste);
-    }
-    */
-
-    io.SetClipboardTextFn = (user_data: any, text: string): void => {
-        clipboard_text = text;
-        // console.log(`set clipboard_text: "${clipboard_text}"`);
-        if (typeof navigator !== "undefined" && typeof (navigator as any).clipboard !== "undefined") {
-            // console.log(`clipboard.writeText: "${clipboard_text}"`);
-            (navigator as any).clipboard.writeText(clipboard_text).then((): void => {
-                // console.log(`clipboard.writeText: "${clipboard_text}" done.`);
-            });
-        }
-    };
-    io.GetClipboardTextFn = (user_data: any): string => {
-        // if (typeof navigator !== "undefined" && typeof (navigator as any).clipboard !== "undefined") {
-        //     console.log(`clipboard.readText: "${clipboard_text}"`);
-        //     (navigator as any).clipboard.readText().then((text: string): void => {
-        //         clipboard_text = text;
-        //         console.log(`clipboard.readText: "${clipboard_text}" done.`);
-        //     });
-        // }
-        // console.log(`get clipboard_text: "${clipboard_text}"`);
-        return clipboard_text;
-    };
-    io.ClipboardUserData = null;
-
-    if (typeof(window) !== "undefined") {
-        window.addEventListener("resize", window_on_resize);
-        window.addEventListener("gamepadconnected", window_on_gamepadconnected);
-        window.addEventListener("gamepaddisconnected", window_on_gamepaddisconnected);
-    }
-
-    if (typeof(window) !== "undefined") {
-        if (value instanceof(HTMLCanvasElement)) {
-            canvas = value;
-            value = canvas.getContext("webgl2", { alpha: false }) || canvas.getContext("webgl", { alpha: false }) || canvas.getContext("2d");
-        }
-        if (typeof WebGL2RenderingContext !== "undefined" && value instanceof(WebGL2RenderingContext)) {
-            io.BackendRendererName = "imgui_impl_webgl2";
-            canvas = canvas || value.canvas as HTMLCanvasElement;
-            gl = value;
-        }
-        else if (typeof WebGLRenderingContext !== "undefined" && value instanceof(WebGLRenderingContext)) {
-            io.BackendRendererName = "imgui_impl_webgl";
-            canvas = canvas || value.canvas as HTMLCanvasElement;
-            gl = value;
-        }
-        else if (typeof CanvasRenderingContext2D !== "undefined" && value instanceof(CanvasRenderingContext2D)) {
-            io.BackendRendererName = "imgui_impl_2d";
-            canvas = canvas || value.canvas;
-            ctx = value;
-        }
-    }
-
-    if (canvas !== null) {
-        window_on_resize();
-        canvas.style.touchAction = "none"; // Disable browser handling of all panning and zooming gestures.
-        canvas.addEventListener("blur", canvas_on_blur);
-        add_key_event();
-        add_pointer_event();
-        canvas.addEventListener("contextmenu", canvas_on_contextmenu);
-
-        canvas.addEventListener( 'webglcontextlost', canvas_on_contextlost, false );
-		canvas.addEventListener( 'webglcontextrestored', canvas_on_contextrestored, false);
-    }
-
-    // Setup back-end capabilities flags
-    io.BackendFlags |= ImGui.BackendFlags.HasMouseCursors;   // We can honor GetMouseCursor() values (optional)
-
-    // Keyboard mapping. ImGui will use those indices to peek into the io.KeyDown[] array.
-    io.KeyMap[ImGui.Key.Tab] = 9;
-    io.KeyMap[ImGui.Key.LeftArrow] = 37;
-    io.KeyMap[ImGui.Key.RightArrow] = 39;
-    io.KeyMap[ImGui.Key.UpArrow] = 38;
-    io.KeyMap[ImGui.Key.DownArrow] = 40;
-    io.KeyMap[ImGui.Key.PageUp] = 33;
-    io.KeyMap[ImGui.Key.PageDown] = 34;
-    io.KeyMap[ImGui.Key.Home] = 36;
-    io.KeyMap[ImGui.Key.End] = 35;
-    io.KeyMap[ImGui.Key.Insert] = 45;
-    io.KeyMap[ImGui.Key.Delete] = 46;
-    io.KeyMap[ImGui.Key.Backspace] = 8;
-    io.KeyMap[ImGui.Key.Space] = 32;
-    io.KeyMap[ImGui.Key.Enter] = 13;
-    io.KeyMap[ImGui.Key.Escape] = 27;
-    io.KeyMap[ImGui.Key.KeyPadEnter] = key_code_to_index["NumpadEnter"];
-    io.KeyMap[ImGui.Key.A] = 65;
-    io.KeyMap[ImGui.Key.C] = 67;
-    io.KeyMap[ImGui.Key.V] = 86;
-    io.KeyMap[ImGui.Key.X] = 88;
-    io.KeyMap[ImGui.Key.Y] = 89;
-    io.KeyMap[ImGui.Key.Z] = 90;
-
-    CreateDeviceObjects();
+  const io = ImGui.GetIO();
+
+  if (typeof (window) !== "undefined") {
+    io.BackendPlatformName = "imgui_impl_browser";
+    ImGui.LoadIniSettingsFromMemory(window.localStorage.getItem("imgui.ini") || "");
+  }
+  else {
+    io.BackendPlatformName = "imgui_impl_console";
+  }
+
+  if (typeof (navigator) !== "undefined") {
+    io.ConfigMacOSXBehaviors = navigator.platform.match(/Mac/) !== null;
+  }
+
+  /*
+  if (typeof(document) !== "undefined") {
+      document.body.addEventListener("copy", document_on_copy);
+      document.body.addEventListener("cut", document_on_cut);
+      document.body.addEventListener("paste", document_on_paste);
+  }
+  */
+
+  io.SetClipboardTextFn = (user_data: any, text: string): void => {
+    clipboard_text = text;
+    // console.log(`set clipboard_text: "${clipboard_text}"`);
+    if (typeof navigator !== "undefined" && typeof (navigator as any).clipboard !== "undefined") {
+      // console.log(`clipboard.writeText: "${clipboard_text}"`);
+      (navigator as any).clipboard.writeText(clipboard_text).then((): void => {
+        // console.log(`clipboard.writeText: "${clipboard_text}" done.`);
+      });
+    }
+  };
+  io.GetClipboardTextFn = (user_data: any): string => {
+    // if (typeof navigator !== "undefined" && typeof (navigator as any).clipboard !== "undefined") {
+    //     console.log(`clipboard.readText: "${clipboard_text}"`);
+    //     (navigator as any).clipboard.readText().then((text: string): void => {
+    //         clipboard_text = text;
+    //         console.log(`clipboard.readText: "${clipboard_text}" done.`);
+    //     });
+    // }
+    // console.log(`get clipboard_text: "${clipboard_text}"`);
+    return clipboard_text;
+  };
+  io.ClipboardUserData = null;
+
+  if (typeof (window) !== "undefined") {
+    window.addEventListener("resize", window_on_resize);
+    window.addEventListener("gamepadconnected", window_on_gamepadconnected);
+    window.addEventListener("gamepaddisconnected", window_on_gamepaddisconnected);
+  }
+
+  if (typeof (window) !== "undefined") {
+    if (value instanceof (HTMLCanvasElement)) {
+      canvas = value;
+      value = canvas.getContext("webgl2", { alpha: false }) || canvas.getContext("webgl", { alpha: false }) || canvas.getContext("2d");
+    }
+    if (typeof WebGL2RenderingContext !== "undefined" && value instanceof (WebGL2RenderingContext)) {
+      io.BackendRendererName = "imgui_impl_webgl2";
+      canvas = canvas || value.canvas as HTMLCanvasElement;
+      gl = value;
+    }
+    else if (typeof WebGLRenderingContext !== "undefined" && value instanceof (WebGLRenderingContext)) {
+      io.BackendRendererName = "imgui_impl_webgl";
+      canvas = canvas || value.canvas as HTMLCanvasElement;
+      gl = value;
+    }
+    else if (typeof CanvasRenderingContext2D !== "undefined" && value instanceof (CanvasRenderingContext2D)) {
+      io.BackendRendererName = "imgui_impl_2d";
+      canvas = canvas || value.canvas;
+      ctx = value;
+    }
+  }
+
+  if (canvas !== null) {
+    window_on_resize();
+    canvas.style.touchAction = "none"; // Disable browser handling of all panning and zooming gestures.
+    canvas.addEventListener("blur", canvas_on_blur);
+    add_key_event();
+    add_pointer_event();
+    canvas.addEventListener("contextmenu", canvas_on_contextmenu);
+
+    canvas.addEventListener('webglcontextlost', canvas_on_contextlost, false);
+    canvas.addEventListener('webglcontextrestored', canvas_on_contextrestored, false);
+  }
+
+  // Setup back-end capabilities flags
+  io.BackendFlags |= ImGui.BackendFlags.HasMouseCursors;   // We can honor GetMouseCursor() values (optional)
+
+  // Keyboard mapping. ImGui will use those indices to peek into the io.KeyDown[] array.
+  io.KeyMap[ImGui.Key.Tab] = 9;
+  io.KeyMap[ImGui.Key.LeftArrow] = 37;
+  io.KeyMap[ImGui.Key.RightArrow] = 39;
+  io.KeyMap[ImGui.Key.UpArrow] = 38;
+  io.KeyMap[ImGui.Key.DownArrow] = 40;
+  io.KeyMap[ImGui.Key.PageUp] = 33;
+  io.KeyMap[ImGui.Key.PageDown] = 34;
+  io.KeyMap[ImGui.Key.Home] = 36;
+  io.KeyMap[ImGui.Key.End] = 35;
+  io.KeyMap[ImGui.Key.Insert] = 45;
+  io.KeyMap[ImGui.Key.Delete] = 46;
+  io.KeyMap[ImGui.Key.Backspace] = 8;
+  io.KeyMap[ImGui.Key.Space] = 32;
+  io.KeyMap[ImGui.Key.Enter] = 13;
+  io.KeyMap[ImGui.Key.Escape] = 27;
+  io.KeyMap[ImGui.Key.KeyPadEnter] = key_code_to_index["NumpadEnter"];
+  io.KeyMap[ImGui.Key.A] = 65;
+  io.KeyMap[ImGui.Key.C] = 67;
+  io.KeyMap[ImGui.Key.V] = 86;
+  io.KeyMap[ImGui.Key.X] = 88;
+  io.KeyMap[ImGui.Key.Y] = 89;
+  io.KeyMap[ImGui.Key.Z] = 90;
+
+  CreateDeviceObjects();
 }
 
 export function Shutdown(): void {
-    DestroyDeviceObjects();
-
-    remove_key_event();
-    remove_pointer_event();
-    if (canvas !== null) {
-        canvas.removeEventListener("blur", canvas_on_blur);
-        canvas.removeEventListener("contextmenu", canvas_on_contextmenu);
-    }
-
-    gl = null;
-    ctx = null;
-    canvas = null;
-
-    if (typeof(window) !== "undefined") {
-        window.removeEventListener("resize", window_on_resize);
-        window.removeEventListener("gamepadconnected", window_on_gamepadconnected);
-        window.removeEventListener("gamepaddisconnected", window_on_gamepaddisconnected);
-    }
-
-    if (typeof(document) !== "undefined") {
-        document.body.removeEventListener("copy", document_on_copy);
-        document.body.removeEventListener("cut", document_on_cut);
-        document.body.removeEventListener("paste", document_on_paste);
-    }
+  DestroyDeviceObjects();
+
+  remove_key_event();
+  remove_pointer_event();
+  if (canvas !== null) {
+    canvas.removeEventListener("blur", canvas_on_blur);
+    canvas.removeEventListener("contextmenu", canvas_on_contextmenu);
+  }
+
+  gl = null;
+  ctx = null;
+  canvas = null;
+
+  if (typeof (window) !== "undefined") {
+    window.removeEventListener("resize", window_on_resize);
+    window.removeEventListener("gamepadconnected", window_on_gamepadconnected);
+    window.removeEventListener("gamepaddisconnected", window_on_gamepaddisconnected);
+  }
+
+  if (typeof (document) !== "undefined") {
+    document.body.removeEventListener("copy", document_on_copy);
+    document.body.removeEventListener("cut", document_on_cut);
+    document.body.removeEventListener("paste", document_on_paste);
+  }
 }
 
-export function ClearBuffer(color:ImGui.ImVec4, bufferBit:number = gl.COLOR_BUFFER_BIT)
-{
-    gl.clearColor(color.x, color.y, color.z, color.w);
-    gl.clear(bufferBit);
+export function ClearBuffer(color: ImGui.ImVec4, bufferBit: number = gl.COLOR_BUFFER_BIT) {
+  gl.clearColor(color.x, color.y, color.z, color.w);
+  gl.clear(bufferBit);
 }
 
 export function NewFrame(time: number): void {
-    const io = ImGui.GetIO();
-
-    if (io.WantSaveIniSettings) {
-        io.WantSaveIniSettings = false;
-        if (typeof(window) !== "undefined") {
-            window.localStorage.setItem("imgui.ini", ImGui.SaveIniSettingsToMemory());
+  const io = ImGui.GetIO();
+
+  if (io.WantSaveIniSettings) {
+    io.WantSaveIniSettings = false;
+    if (typeof (window) !== "undefined") {
+      window.localStorage.setItem("imgui.ini", ImGui.SaveIniSettingsToMemory());
+    }
+  }
+
+  const w: number = canvas && canvas.scrollWidth || 640;
+  const h: number = canvas && canvas.scrollHeight || 480;
+  const display_w: number = gl && gl.drawingBufferWidth || w;
+  const display_h: number = gl && gl.drawingBufferHeight || h;
+  io.DisplaySize.x = w;
+  io.DisplaySize.y = h;
+  io.DisplayFramebufferScale.x = w > 0 ? (display_w / w) : 0;
+  io.DisplayFramebufferScale.y = h > 0 ? (display_h / h) : 0;
+
+  const dt: number = time - prev_time;
+  prev_time = time;
+  io.DeltaTime = dt / 1000;
+
+  if (io.WantSetMousePos) {
+    console.log("TODO: MousePos", io.MousePos.x, io.MousePos.y);
+  }
+
+  if (typeof (document) !== "undefined") {
+    if (io.MouseDrawCursor) {
+      document.body.style.cursor = "none";
+    } else {
+      switch (ImGui.GetMouseCursor()) {
+        case ImGui.MouseCursor.None: document.body.style.cursor = "none"; break;
+        default: case ImGui.MouseCursor.Arrow: document.body.style.cursor = "default"; break;
+        case ImGui.MouseCursor.TextInput: document.body.style.cursor = "text"; break;         // When hovering over InputText, etc.
+        case ImGui.MouseCursor.ResizeAll: document.body.style.cursor = "all-scroll"; break;         // Unused
+        case ImGui.MouseCursor.ResizeNS: document.body.style.cursor = "ns-resize"; break;     // When hovering over an horizontal border
+        case ImGui.MouseCursor.ResizeEW: document.body.style.cursor = "ew-resize"; break;     // When hovering over a vertical border or a column
+        case ImGui.MouseCursor.ResizeNESW: document.body.style.cursor = "nesw-resize"; break; // When hovering over the bottom-left corner of a window
+        case ImGui.MouseCursor.ResizeNWSE: document.body.style.cursor = "nwse-resize"; break; // When hovering over the bottom-right corner of a window
+        case ImGui.MouseCursor.Hand: document.body.style.cursor = "move"; break;
+        case ImGui.MouseCursor.NotAllowed: document.body.style.cursor = "not-allowed"; break;
+      }
+    }
+  }
+
+  // Gamepad navigation mapping [BETA]
+  for (let i = 0; i < io.NavInputs.length; ++i) {
+    // TODO: This is currently causing an issue and I have no gamepad to test with.
+    //       The error is: ''set' on proxy: trap returned falsish for property '21'
+    //       I think that the NavInputs are zeroed out by ImGui at the start of each frame anyway
+    //       so I am not sure if the following is even necessary.
+    //io.NavInputs[i] = 0.0;
+  }
+  if (io.ConfigFlags & ImGui.ConfigFlags.NavEnableGamepad) {
+    // Update gamepad inputs
+    const gamepads: (Gamepad | null)[] = (typeof (navigator) !== "undefined" && typeof (navigator.getGamepads) === "function") ? navigator.getGamepads() : [];
+    for (let i = 0; i < gamepads.length; ++i) {
+      const gamepad: Gamepad | null = gamepads[i];
+      if (!gamepad) { continue; }
+      io.BackendFlags |= ImGui.BackendFlags.HasGamepad;
+      const buttons_count: number = gamepad.buttons.length;
+      const axes_count: number = gamepad.axes.length;
+
+      var MAP_BUTTON =
+        function MAP_BUTTON(NAV_NO: number, BUTTON_NO: number): void {
+          if (!gamepad) { return; }
+          if (buttons_count > BUTTON_NO && gamepad.buttons[BUTTON_NO].pressed)
+            io.NavInputs[NAV_NO] = 1.0;
         }
-    }
-
-    const w: number = canvas && canvas.scrollWidth || 640;
-    const h: number = canvas && canvas.scrollHeight || 480;
-    const display_w: number = gl && gl.drawingBufferWidth || w;
-    const display_h: number = gl && gl.drawingBufferHeight || h;
-    io.DisplaySize.x = w;
-    io.DisplaySize.y = h;
-    io.DisplayFramebufferScale.x = w > 0 ? (display_w / w) : 0;
-    io.DisplayFramebufferScale.y = h > 0 ? (display_h / h) : 0;
-
-    const dt: number = time - prev_time;
-    prev_time = time;
-    io.DeltaTime = dt / 1000;
-
-    if (io.WantSetMousePos) {
-        console.log("TODO: MousePos", io.MousePos.x, io.MousePos.y);
-    }
-
-    if (typeof(document) !== "undefined") {
-        if (io.MouseDrawCursor) {
-            document.body.style.cursor = "none";
-        } else {
-            switch (ImGui.GetMouseCursor()) {
-                case ImGui.MouseCursor.None: document.body.style.cursor = "none"; break;
-                default: case ImGui.MouseCursor.Arrow: document.body.style.cursor = "default"; break;
-                case ImGui.MouseCursor.TextInput: document.body.style.cursor = "text"; break;         // When hovering over InputText, etc.
-                case ImGui.MouseCursor.ResizeAll: document.body.style.cursor = "all-scroll"; break;         // Unused
-                case ImGui.MouseCursor.ResizeNS: document.body.style.cursor = "ns-resize"; break;     // When hovering over an horizontal border
-                case ImGui.MouseCursor.ResizeEW: document.body.style.cursor = "ew-resize"; break;     // When hovering over a vertical border or a column
-                case ImGui.MouseCursor.ResizeNESW: document.body.style.cursor = "nesw-resize"; break; // When hovering over the bottom-left corner of a window
-                case ImGui.MouseCursor.ResizeNWSE: document.body.style.cursor = "nwse-resize"; break; // When hovering over the bottom-right corner of a window
-                case ImGui.MouseCursor.Hand: document.body.style.cursor = "move"; break;
-                case ImGui.MouseCursor.NotAllowed: document.body.style.cursor = "not-allowed"; break;
-            }
+      var MAP_ANALOG =
+        function MAP_ANALOG(NAV_NO: number, AXIS_NO: number, V0: number, V1: number): void {
+          if (!gamepad) { return; }
+          let v: number = (axes_count > AXIS_NO) ? gamepad.axes[AXIS_NO] : V0;
+          v = (v - V0) / (V1 - V0);
+          if (v > 1.0) v = 1.0;
+          if (io.NavInputs[NAV_NO] < v) io.NavInputs[NAV_NO] = v;
         }
-    }
-
-    // Gamepad navigation mapping [BETA]
-    for (let i = 0; i < io.NavInputs.length; ++i) {
-        // TODO: This is currently causing an issue and I have no gamepad to test with.
-        //       The error is: ''set' on proxy: trap returned falsish for property '21'
-        //       I think that the NavInputs are zeroed out by ImGui at the start of each frame anyway
-        //       so I am not sure if the following is even necessary.
-        //io.NavInputs[i] = 0.0;
-    }
-    if (io.ConfigFlags & ImGui.ConfigFlags.NavEnableGamepad) {
-        // Update gamepad inputs
-        const gamepads: (Gamepad | null)[] = (typeof(navigator) !== "undefined" && typeof(navigator.getGamepads) === "function") ? navigator.getGamepads() : [];
-        for (let i = 0; i < gamepads.length; ++i) {
-            const gamepad: Gamepad | null = gamepads[i];
-            if (!gamepad) { continue; }
-            io.BackendFlags |= ImGui.BackendFlags.HasGamepad;
-            const buttons_count: number = gamepad.buttons.length;
-            const axes_count: number = gamepad.axes.length;
-            
-            var MAP_BUTTON=
-            function MAP_BUTTON(NAV_NO: number, BUTTON_NO: number): void {
-                if (!gamepad) { return; }
-                if (buttons_count > BUTTON_NO && gamepad.buttons[BUTTON_NO].pressed)
-                    io.NavInputs[NAV_NO] = 1.0;
-            }
-            var MAP_ANALOG=
-            function MAP_ANALOG(NAV_NO: number, AXIS_NO: number, V0: number, V1: number): void {
-                if (!gamepad) { return; }
-                let v: number = (axes_count > AXIS_NO) ? gamepad.axes[AXIS_NO] : V0;
-                v = (v - V0) / (V1 - V0);
-                if (v > 1.0) v = 1.0;
-                if (io.NavInputs[NAV_NO] < v) io.NavInputs[NAV_NO] = v;
-            }
-            // TODO: map input based on vendor and product id
-            // https://developer.mozilla.org/en-US/docs/Web/API/Gamepad/id
-            const match: RegExpMatchArray | null = gamepad.id.match(/^([0-9a-f]{4})-([0-9a-f]{4})-.*$/);
-            const match_chrome: RegExpMatchArray | null = gamepad.id.match(/^.*\(.*Vendor: ([0-9a-f]{4}) Product: ([0-9a-f]{4})\).*$/);
-            const vendor: string = (match && match[1]) || (match_chrome && match_chrome[1]) || "0000";
-            const product: string = (match && match[2]) || (match_chrome && match_chrome[2]) || "0000";
-            switch (vendor + product) {
-                case "046dc216": // Logitech Logitech Dual Action (Vendor: 046d Product: c216)
-                MAP_BUTTON(ImGui.NavInput.Activate,    1); // Cross / A
-                MAP_BUTTON(ImGui.NavInput.Cancel,      2); // Circle / B
-                MAP_BUTTON(ImGui.NavInput.Menu,        0); // Square / X
-                MAP_BUTTON(ImGui.NavInput.Input,       3); // Triangle / Y
-                MAP_ANALOG(ImGui.NavInput.DpadLeft,    4, -0.3, -0.9); // D-Pad Left
-                MAP_ANALOG(ImGui.NavInput.DpadRight,   4, +0.3, +0.9); // D-Pad Right
-                MAP_ANALOG(ImGui.NavInput.DpadUp,      5, -0.3, -0.9); // D-Pad Up
-                MAP_ANALOG(ImGui.NavInput.DpadDown,    5, +0.3, +0.9); // D-Pad Down
-                MAP_BUTTON(ImGui.NavInput.FocusPrev,   4); // L1 / LB
-                MAP_BUTTON(ImGui.NavInput.FocusNext,   5); // R1 / RB
-                MAP_BUTTON(ImGui.NavInput.TweakSlow,   6); // L2 / LT
-                MAP_BUTTON(ImGui.NavInput.TweakFast,   7); // R2 / RT
-                MAP_ANALOG(ImGui.NavInput.LStickLeft,  0, -0.3, -0.9);
-                MAP_ANALOG(ImGui.NavInput.LStickRight, 0, +0.3, +0.9);
-                MAP_ANALOG(ImGui.NavInput.LStickUp,    1, -0.3, -0.9);
-                MAP_ANALOG(ImGui.NavInput.LStickDown,  1, +0.3, +0.9);
-                break;
-                case "046dc21d": // Logitech Gamepad F310 (STANDARD GAMEPAD Vendor: 046d Product: c21d)
-                MAP_BUTTON(ImGui.NavInput.Activate,    0); // Cross / A
-                MAP_BUTTON(ImGui.NavInput.Cancel,      1); // Circle / B
-                MAP_BUTTON(ImGui.NavInput.Menu,        2); // Square / X
-                MAP_BUTTON(ImGui.NavInput.Input,       3); // Triangle / Y
-                MAP_BUTTON(ImGui.NavInput.DpadLeft,    14); // D-Pad Left
-                MAP_BUTTON(ImGui.NavInput.DpadRight,   15); // D-Pad Right
-                MAP_BUTTON(ImGui.NavInput.DpadUp,      12); // D-Pad Up
-                MAP_BUTTON(ImGui.NavInput.DpadDown,    13); // D-Pad Down
-                MAP_BUTTON(ImGui.NavInput.FocusPrev,   4); // L1 / LB
-                MAP_BUTTON(ImGui.NavInput.FocusNext,   5); // R1 / RB
-                MAP_ANALOG(ImGui.NavInput.TweakSlow,   6, +0.3, +0.9); // L2 / LT
-                MAP_ANALOG(ImGui.NavInput.TweakFast,   7, +0.3, +0.9); // R2 / RT
-                MAP_ANALOG(ImGui.NavInput.LStickLeft,  0, -0.3, -0.9);
-                MAP_ANALOG(ImGui.NavInput.LStickRight, 0, +0.3, +0.9);
-                MAP_ANALOG(ImGui.NavInput.LStickUp,    1, -0.3, -0.9);
-                MAP_ANALOG(ImGui.NavInput.LStickDown,  1, +0.3, +0.9);
-                break;
-                case "2dc86001": // 8Bitdo SN30 Pro  8Bitdo SN30 Pro (Vendor: 2dc8 Product: 6001)
-                case "2dc86101": // 8Bitdo SN30 Pro (Vendor: 2dc8 Product: 6101)
-                MAP_BUTTON(ImGui.NavInput.Activate,    1); // Cross / A
-                MAP_BUTTON(ImGui.NavInput.Cancel,      0); // Circle / B
-                MAP_BUTTON(ImGui.NavInput.Menu,        4); // Square / X
-                MAP_BUTTON(ImGui.NavInput.Input,       3); // Triangle / Y
-                MAP_ANALOG(ImGui.NavInput.DpadLeft,    6, -0.3, -0.9); // D-Pad Left
-                MAP_ANALOG(ImGui.NavInput.DpadRight,   6, +0.3, +0.9); // D-Pad Right
-                MAP_ANALOG(ImGui.NavInput.DpadUp,      7, -0.3, -0.9); // D-Pad Up
-                MAP_ANALOG(ImGui.NavInput.DpadDown,    7, +0.3, +0.9); // D-Pad Down
-                MAP_BUTTON(ImGui.NavInput.FocusPrev,   6); // L1 / LB
-                MAP_BUTTON(ImGui.NavInput.FocusNext,   7); // R1 / RB
-                MAP_BUTTON(ImGui.NavInput.TweakSlow,   8); // L2 / LT
-                MAP_BUTTON(ImGui.NavInput.TweakFast,   9); // R2 / RT
-                MAP_ANALOG(ImGui.NavInput.LStickLeft,  0, -0.3, -0.9);
-                MAP_ANALOG(ImGui.NavInput.LStickRight, 0, +0.3, +0.9);
-                MAP_ANALOG(ImGui.NavInput.LStickUp,    1, -0.3, -0.9);
-                MAP_ANALOG(ImGui.NavInput.LStickDown,  1, +0.3, +0.9);
-                break;
-                default: // standard gamepad: https://w3c.github.io/gamepad/#remapping
-                MAP_BUTTON(ImGui.NavInput.Activate,    0); // Cross / A
-                MAP_BUTTON(ImGui.NavInput.Cancel,      1); // Circle / B
-                MAP_BUTTON(ImGui.NavInput.Menu,        2); // Square / X
-                MAP_BUTTON(ImGui.NavInput.Input,       3); // Triangle / Y
-                MAP_BUTTON(ImGui.NavInput.DpadLeft,    14); // D-Pad Left
-                MAP_BUTTON(ImGui.NavInput.DpadRight,   15); // D-Pad Right
-                MAP_BUTTON(ImGui.NavInput.DpadUp,      12); // D-Pad Up
-                MAP_BUTTON(ImGui.NavInput.DpadDown,    13); // D-Pad Down
-                MAP_BUTTON(ImGui.NavInput.FocusPrev,   4); // L1 / LB
-                MAP_BUTTON(ImGui.NavInput.FocusNext,   5); // R1 / RB
-                MAP_BUTTON(ImGui.NavInput.TweakSlow,   6); // L2 / LT
-                MAP_BUTTON(ImGui.NavInput.TweakFast,   7); // R2 / RT
-                MAP_ANALOG(ImGui.NavInput.LStickLeft,  0, -0.3, -0.9);
-                MAP_ANALOG(ImGui.NavInput.LStickRight, 0, +0.3, +0.9);
-                MAP_ANALOG(ImGui.NavInput.LStickUp,    1, -0.3, -0.9);
-                MAP_ANALOG(ImGui.NavInput.LStickDown,  1, +0.3, +0.9);
-                break;
-            }
-        }
-    }
+      // TODO: map input based on vendor and product id
+      // https://developer.mozilla.org/en-US/docs/Web/API/Gamepad/id
+      const match: RegExpMatchArray | null = gamepad.id.match(/^([0-9a-f]{4})-([0-9a-f]{4})-.*$/);
+      const match_chrome: RegExpMatchArray | null = gamepad.id.match(/^.*\(.*Vendor: ([0-9a-f]{4}) Product: ([0-9a-f]{4})\).*$/);
+      const vendor: string = (match && match[1]) || (match_chrome && match_chrome[1]) || "0000";
+      const product: string = (match && match[2]) || (match_chrome && match_chrome[2]) || "0000";
+      switch (vendor + product) {
+        case "046dc216": // Logitech Logitech Dual Action (Vendor: 046d Product: c216)
+          MAP_BUTTON(ImGui.NavInput.Activate, 1); // Cross / A
+          MAP_BUTTON(ImGui.NavInput.Cancel, 2); // Circle / B
+          MAP_BUTTON(ImGui.NavInput.Menu, 0); // Square / X
+          MAP_BUTTON(ImGui.NavInput.Input, 3); // Triangle / Y
+          MAP_ANALOG(ImGui.NavInput.DpadLeft, 4, -0.3, -0.9); // D-Pad Left
+          MAP_ANALOG(ImGui.NavInput.DpadRight, 4, +0.3, +0.9); // D-Pad Right
+          MAP_ANALOG(ImGui.NavInput.DpadUp, 5, -0.3, -0.9); // D-Pad Up
+          MAP_ANALOG(ImGui.NavInput.DpadDown, 5, +0.3, +0.9); // D-Pad Down
+          MAP_BUTTON(ImGui.NavInput.FocusPrev, 4); // L1 / LB
+          MAP_BUTTON(ImGui.NavInput.FocusNext, 5); // R1 / RB
+          MAP_BUTTON(ImGui.NavInput.TweakSlow, 6); // L2 / LT
+          MAP_BUTTON(ImGui.NavInput.TweakFast, 7); // R2 / RT
+          MAP_ANALOG(ImGui.NavInput.LStickLeft, 0, -0.3, -0.9);
+          MAP_ANALOG(ImGui.NavInput.LStickRight, 0, +0.3, +0.9);
+          MAP_ANALOG(ImGui.NavInput.LStickUp, 1, -0.3, -0.9);
+          MAP_ANALOG(ImGui.NavInput.LStickDown, 1, +0.3, +0.9);
+          break;
+        case "046dc21d": // Logitech Gamepad F310 (STANDARD GAMEPAD Vendor: 046d Product: c21d)
+          MAP_BUTTON(ImGui.NavInput.Activate, 0); // Cross / A
+          MAP_BUTTON(ImGui.NavInput.Cancel, 1); // Circle / B
+          MAP_BUTTON(ImGui.NavInput.Menu, 2); // Square / X
+          MAP_BUTTON(ImGui.NavInput.Input, 3); // Triangle / Y
+          MAP_BUTTON(ImGui.NavInput.DpadLeft, 14); // D-Pad Left
+          MAP_BUTTON(ImGui.NavInput.DpadRight, 15); // D-Pad Right
+          MAP_BUTTON(ImGui.NavInput.DpadUp, 12); // D-Pad Up
+          MAP_BUTTON(ImGui.NavInput.DpadDown, 13); // D-Pad Down
+          MAP_BUTTON(ImGui.NavInput.FocusPrev, 4); // L1 / LB
+          MAP_BUTTON(ImGui.NavInput.FocusNext, 5); // R1 / RB
+          MAP_ANALOG(ImGui.NavInput.TweakSlow, 6, +0.3, +0.9); // L2 / LT
+          MAP_ANALOG(ImGui.NavInput.TweakFast, 7, +0.3, +0.9); // R2 / RT
+          MAP_ANALOG(ImGui.NavInput.LStickLeft, 0, -0.3, -0.9);
+          MAP_ANALOG(ImGui.NavInput.LStickRight, 0, +0.3, +0.9);
+          MAP_ANALOG(ImGui.NavInput.LStickUp, 1, -0.3, -0.9);
+          MAP_ANALOG(ImGui.NavInput.LStickDown, 1, +0.3, +0.9);
+          break;
+        case "2dc86001": // 8Bitdo SN30 Pro  8Bitdo SN30 Pro (Vendor: 2dc8 Product: 6001)
+        case "2dc86101": // 8Bitdo SN30 Pro (Vendor: 2dc8 Product: 6101)
+          MAP_BUTTON(ImGui.NavInput.Activate, 1); // Cross / A
+          MAP_BUTTON(ImGui.NavInput.Cancel, 0); // Circle / B
+          MAP_BUTTON(ImGui.NavInput.Menu, 4); // Square / X
+          MAP_BUTTON(ImGui.NavInput.Input, 3); // Triangle / Y
+          MAP_ANALOG(ImGui.NavInput.DpadLeft, 6, -0.3, -0.9); // D-Pad Left
+          MAP_ANALOG(ImGui.NavInput.DpadRight, 6, +0.3, +0.9); // D-Pad Right
+          MAP_ANALOG(ImGui.NavInput.DpadUp, 7, -0.3, -0.9); // D-Pad Up
+          MAP_ANALOG(ImGui.NavInput.DpadDown, 7, +0.3, +0.9); // D-Pad Down
+          MAP_BUTTON(ImGui.NavInput.FocusPrev, 6); // L1 / LB
+          MAP_BUTTON(ImGui.NavInput.FocusNext, 7); // R1 / RB
+          MAP_BUTTON(ImGui.NavInput.TweakSlow, 8); // L2 / LT
+          MAP_BUTTON(ImGui.NavInput.TweakFast, 9); // R2 / RT
+          MAP_ANALOG(ImGui.NavInput.LStickLeft, 0, -0.3, -0.9);
+          MAP_ANALOG(ImGui.NavInput.LStickRight, 0, +0.3, +0.9);
+          MAP_ANALOG(ImGui.NavInput.LStickUp, 1, -0.3, -0.9);
+          MAP_ANALOG(ImGui.NavInput.LStickDown, 1, +0.3, +0.9);
+          break;
+        default: // standard gamepad: https://w3c.github.io/gamepad/#remapping
+          MAP_BUTTON(ImGui.NavInput.Activate, 0); // Cross / A
+          MAP_BUTTON(ImGui.NavInput.Cancel, 1); // Circle / B
+          MAP_BUTTON(ImGui.NavInput.Menu, 2); // Square / X
+          MAP_BUTTON(ImGui.NavInput.Input, 3); // Triangle / Y
+          MAP_BUTTON(ImGui.NavInput.DpadLeft, 14); // D-Pad Left
+          MAP_BUTTON(ImGui.NavInput.DpadRight, 15); // D-Pad Right
+          MAP_BUTTON(ImGui.NavInput.DpadUp, 12); // D-Pad Up
+          MAP_BUTTON(ImGui.NavInput.DpadDown, 13); // D-Pad Down
+          MAP_BUTTON(ImGui.NavInput.FocusPrev, 4); // L1 / LB
+          MAP_BUTTON(ImGui.NavInput.FocusNext, 5); // R1 / RB
+          MAP_BUTTON(ImGui.NavInput.TweakSlow, 6); // L2 / LT
+          MAP_BUTTON(ImGui.NavInput.TweakFast, 7); // R2 / RT
+          MAP_ANALOG(ImGui.NavInput.LStickLeft, 0, -0.3, -0.9);
+          MAP_ANALOG(ImGui.NavInput.LStickRight, 0, +0.3, +0.9);
+          MAP_ANALOG(ImGui.NavInput.LStickUp, 1, -0.3, -0.9);
+          MAP_ANALOG(ImGui.NavInput.LStickDown, 1, +0.3, +0.9);
+          break;
+      }
+    }
+  }
 }
 
-function toRgba(col:number):string
-{
-    const r=(col>>>24);
-    const g=(col>>16)&0xFF;
-    const b=(col>>8)&0xFF;
-    const a=(col&0xFF);
-    return 'rgba('+r+','+g+','+b+','+a+')';    
+function toRgba(col: number): string {
+  const r = (col >>> 24);
+  const g = (col >> 16) & 0xFF;
+  const b = (col >> 8) & 0xFF;
+  const a = (col & 0xFF);
+  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
 }
 
-export let dom_font:Font=null;
-
-async function font_update(io:ImGui.IO) {
-    if(!dom_font)   {
-        dom_font=new Font;
-    }
-    io.Fonts.Fonts.forEach(font=>{
-        let glyph=font.GlyphToCreate;
-        while(glyph)   {
-            glyph=dom_font.Create(glyph, font);
-            font.GlyphCreated(glyph);
-            glyph=font.GlyphToCreate;
-        }
-    });
-    dom_font.UpdateTexture();    
+export let dom_font: Font = null;
+
+async function font_update(io: ImGui.IO) {
+  if (!dom_font) {
+    dom_font = new Font;
+  }
+  io.Fonts.Fonts.forEach(font => {
+    let glyph = font.GlyphToCreate;
+    while (glyph) {
+      glyph = dom_font.Create(glyph, font);
+      font.GlyphCreated(glyph);
+      glyph = font.GlyphToCreate;
+    }
+  });
+  dom_font.UpdateTexture();
 }
 
-let current_window_id:ImGui.ImGuiID=0;
-export let scroll_acc:ImGui.ImVec2=new ImGui.ImVec2(0,0);
-let mouse_first_down:boolean=false;
-
-function scroll_update(io:ImGui.IO) {
-    const hoveredWin= ImGui.GetHoveredWindow();
-    const hoveredId= ImGui.GetHoveredId();
-    if(hoveredWin && hoveredId==0)  {
-        if(current_window_id!=hoveredWin.ID)    {
-            current_window_id=hoveredWin.ID;
-            scroll_acc.Set(0,0);
-            mouse_first_down=true;
+let current_window_id: ImGui.ImGuiID = 0;
+export let scroll_acc: ImGui.ImVec2 = new ImGui.ImVec2(0, 0);
+let mouse_first_down: boolean = false;
+
+function scroll_update(io: ImGui.IO) {
+  const hoveredWin = ImGui.GetHoveredWindow();
+  const hoveredId = ImGui.GetHoveredId();
+  if (hoveredWin && hoveredId == 0) {
+    if (current_window_id != hoveredWin.ID) {
+      current_window_id = hoveredWin.ID;
+      scroll_acc.Set(0, 0);
+      mouse_first_down = true;
+    }
+
+    if (hoveredWin.Flags & ImGui.ImGuiWindowFlags.NoMove) {
+
+      let first_down = false;
+      if (io.MouseDown[0]) {
+        first_down = mouse_first_down;
+        mouse_first_down = false;
+      } else {
+        mouse_first_down = true;
+      }
+
+      let scroll = new ImGui.ImVec2(hoveredWin.Scroll.x, hoveredWin.Scroll.y);
+      if (hoveredWin.ScrollbarY) {
+        if (io.MouseDown[0] && !first_down) {
+          scroll.y -= io.MouseDelta.y;
+          scroll_acc.y = io.MouseDelta.y;
+        } else if (Math.abs(scroll_acc.y) > 1) {
+          scroll.y -= scroll_acc.y;
+          scroll_acc.y *= 0.8;
         }
-
-        if(hoveredWin.Flags & ImGui.ImGuiWindowFlags.NoMove)    {
-
-            let first_down=false;
-            if(io.MouseDown[0]) {
-                first_down=mouse_first_down;
-                mouse_first_down=false;
-            }else {
-                mouse_first_down=true;
-            }
-            
-            let scroll=new ImGui.ImVec2(hoveredWin.Scroll.x, hoveredWin.Scroll.y);
-            if(hoveredWin.ScrollbarY)   {                
-                if(io.MouseDown[0] && !first_down) {
-                    scroll.y-=io.MouseDelta.y;
-                    scroll_acc.y=io.MouseDelta.y;
-                }else if(Math.abs(scroll_acc.y)>1) {
-                    scroll.y-=scroll_acc.y;
-                    scroll_acc.y*=0.8;
-                }
-                if(scroll.y<0) scroll.y=0;
-                else if(scroll.y>hoveredWin.ScrollMax.y)    {
-                    scroll.y=hoveredWin.ScrollMax.y;
-                }
-                hoveredWin.Scroll=scroll;
-            }
-            if(hoveredWin.ScrollbarX)   {
-                if(io.MouseDown[0]) {
-                    scroll.x-=io.MouseDelta.x;
-                    scroll_acc.x=io.MouseDelta.x;
-                }
-                if(scroll.x<0) scroll.x=0;
-                else if(scroll.x>hoveredWin.ScrollMax.x)    {
-                    scroll.x=hoveredWin.ScrollMax.x;
-                }
-                hoveredWin.Scroll=scroll;
-            }
+        if (scroll.y < 0) scroll.y = 0;
+        else if (scroll.y > hoveredWin.ScrollMax.y) {
+          scroll.y = hoveredWin.ScrollMax.y;
         }
-    }
-}
-
-let dom_input:Input.Input;
-let current_input_id:ImGui.ImGuiID=0;
-let current_input_text:string;
-
-function input_text_update(io:ImGui.IO):void {
-    const activeId=ImGui.GetActiveId();
-    const inpId=ImGui.GetInputTextId();
-    if(!activeId || activeId!=inpId)    {
-        current_input_id=0;
-        return;
-    }
-    if(current_input_id !=activeId) {
-        dom_input=null;
-    }
-
-    current_input_id=activeId;
-    let inpState=ImGui.GetInputTextState(activeId);
-    let inp:Input.Input=dom_input;
-    if(!inp)  {
-        let textCol=ImGui.Vec4_toRGBA(ImGui.GetStyleColorVec4(ImGui.ImGuiCol.Text));
-        let textBg=ImGui.Vec4_toRGBA(ImGui.GetStyleColorVec4(ImGui.ImGuiCol.WindowBg));
-
-        if(inpState.Flags & ImGui.ImGuiInputTextFlags.Multiline)    {
-            inp=Input.GetInput(Input.EType.eMultiLine, textCol, textBg);
-        }
-        else if(inpState.Flags & ImGui.ImGuiInputTextFlags.Password)    {
-            inp=Input.GetInput(Input.EType.ePassword, textCol, textBg);
-        }else {
-            inp=Input.GetInput(Input.EType.eInput, textCol, textBg);
+        hoveredWin.Scroll = scroll;
+      }
+      if (hoveredWin.ScrollbarX) {
+        if (io.MouseDown[0]) {
+          scroll.x -= io.MouseDelta.x;
+          scroll_acc.x = io.MouseDelta.x;
         }
-        current_input_text=inpState.Text;
-        inp.on_visible=b=>{
-            if(b)   {
-                remove_key_event();
-                io.KeysDown[9]=false;
-            }else {
-                add_key_event();
-                if(inp.isTab)   {
-                    io.KeysDown[9]=true;
-                }
-            }
+        if (scroll.x < 0) scroll.x = 0;
+        else if (scroll.x > hoveredWin.ScrollMax.x) {
+          scroll.x = hoveredWin.ScrollMax.x;
         }
-        inp.setText(current_input_text, activeId, io.Fonts.CurrentFont);
-        dom_input=inp;
-    }
-    let framebb=inpState.FrameBB;
-    inp.setRect(framebb.Min.x, framebb.Min.y, framebb.Max.x-framebb.Min.x, framebb.Max.y-framebb.Min.y);
-    if(current_input_text!==inp.Text) {
-        current_input_text=inp.Text;
-        inpState.Text=inp.Text;
-        //console.log(inp.Text);
-    }
-    if(!inp.isVisible)  {
-        ImGui.SetActiveId(0);
+        hoveredWin.Scroll = scroll;
+      }
     }
+  }
 }
 
-function BindState()
-{
-    gl && gl.enable(gl.BLEND);
-    gl && gl.blendEquation(gl.FUNC_ADD);
-    gl && gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
-    gl && gl.disable(gl.CULL_FACE);
-    gl && gl.disable(gl.DEPTH_TEST);
-    gl && gl.enable(gl.SCISSOR_TEST);
+let dom_input: Input.Input;
+let current_input_id: ImGui.ImGuiID = 0;
+let current_input_text: string;
+
+function input_text_update(io: ImGui.IO): void {
+  const activeId = ImGui.GetActiveId();
+  const inpId = ImGui.GetInputTextId();
+  if (!activeId || activeId != inpId) {
+    current_input_id = 0;
+    return;
+  }
+  if (current_input_id != activeId) {
+    dom_input = null;
+  }
+
+  current_input_id = activeId;
+  let inpState = ImGui.GetInputTextState(activeId);
+  let inp: Input.Input = dom_input;
+  if (!inp) {
+    let textCol = ImGui.Vec4_toRGBA(ImGui.GetStyleColorVec4(ImGui.ImGuiCol.Text));
+    let textBg = ImGui.Vec4_toRGBA(ImGui.GetStyleColorVec4(ImGui.ImGuiCol.WindowBg));
+
+    if (inpState.Flags & ImGui.ImGuiInputTextFlags.Multiline) {
+      inp = Input.GetInput(Input.EType.eMultiLine, textCol, textBg);
+    }
+    else if (inpState.Flags & ImGui.ImGuiInputTextFlags.Password) {
+      inp = Input.GetInput(Input.EType.ePassword, textCol, textBg);
+    } else {
+      inp = Input.GetInput(Input.EType.eInput, textCol, textBg);
+    }
+    current_input_text = inpState.Text;
+    inp.on_visible = b => {
+      if (b) {
+        remove_key_event();
+        io.KeysDown[9] = false;
+      } else {
+        add_key_event();
+        if (inp.isTab) {
+          io.KeysDown[9] = true;
+        }
+      }
+    }
+    inp.setText(current_input_text, activeId, io.Fonts.CurrentFont);
+    dom_input = inp;
+  }
+  let framebb = inpState.FrameBB;
+  inp.setRect(framebb.Min.x, framebb.Min.y, framebb.Max.x - framebb.Min.x, framebb.Max.y - framebb.Min.y);
+  if (current_input_text !== inp.Text) {
+    current_input_text = inp.Text;
+    inpState.Text = inp.Text;
+    //console.log(inp.Text);
+  }
+  if (!inp.isVisible) {
+    ImGui.SetActiveId(0);
+  }
 }
 
-function BindShader(ortho_projection:Float32Array)
-{
-    gl && gl.useProgram(g_ShaderHandle);
-    gl && gl.uniform1i(g_AttribLocationTex, 0);
-    gl && g_AttribLocationProjMtx && gl.uniformMatrix4fv(g_AttribLocationProjMtx, false, ortho_projection);
+function BindState() {
+  gl && gl.enable(gl.BLEND);
+  gl && gl.blendEquation(gl.FUNC_ADD);
+  gl && gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
+  gl && gl.disable(gl.CULL_FACE);
+  gl && gl.disable(gl.DEPTH_TEST);
+  gl && gl.enable(gl.SCISSOR_TEST);
 }
-function BindMesh()
-{
-    const gl2: WebGL2RenderingContext | null = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext && gl || null;
-    const gl_vao: OES_vertex_array_object | null = gl && gl.getExtension("OES_vertex_array_object") || null;
-
-    if(enable_vao) {
-        if(!g_vao)  {
-            g_vao = gl2 && gl2.createVertexArray();   // || gl_vao && gl_vao.createVertexArrayOES();
-        }
-        gl2 && gl2.bindVertexArray(g_vao);
-        //gl_vao && gl_vao.bindVertexArrayOES(vertex_array_object);
-    }
-
-    gl && gl.bindBuffer(gl.ARRAY_BUFFER, g_VboHandle);
-    gl && gl.enableVertexAttribArray(g_AttribLocationPosition);
-    gl && gl.enableVertexAttribArray(g_AttribLocationUV);
-    gl && gl.enableVertexAttribArray(g_AttribLocationColor);
 
-    gl && gl.vertexAttribPointer(g_AttribLocationPosition, 2, gl.FLOAT, false, ImGui.DrawVertSize, ImGui.DrawVertPosOffset);
-    gl && gl.vertexAttribPointer(g_AttribLocationUV, 2, gl.FLOAT, false, ImGui.DrawVertSize, ImGui.DrawVertUVOffset);
-    gl && gl.vertexAttribPointer(g_AttribLocationColor, 4, gl.UNSIGNED_BYTE, true, ImGui.DrawVertSize, ImGui.DrawVertColOffset);
+function BindShader(ortho_projection: Float32Array) {
+  gl && gl.useProgram(g_ShaderHandle);
+  gl && gl.uniform1i(g_AttribLocationTex, 0);
+  gl && g_AttribLocationProjMtx && gl.uniformMatrix4fv(g_AttribLocationProjMtx, false, ortho_projection);
+}
+function BindMesh() {
+  const gl2: WebGL2RenderingContext | null = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext && gl || null;
+  const gl_vao: OES_vertex_array_object | null = gl && gl.getExtension("OES_vertex_array_object") || null;
+
+  if (enable_vao) {
+    if (!g_vao) {
+      g_vao = gl2 && gl2.createVertexArray();   // || gl_vao && gl_vao.createVertexArrayOES();
+    }
+    gl2 && gl2.bindVertexArray(g_vao);
+    //gl_vao && gl_vao.bindVertexArrayOES(vertex_array_object);
+  }
+
+  gl && gl.bindBuffer(gl.ARRAY_BUFFER, g_VboHandle);
+  gl && gl.enableVertexAttribArray(g_AttribLocationPosition);
+  gl && gl.enableVertexAttribArray(g_AttribLocationUV);
+  gl && gl.enableVertexAttribArray(g_AttribLocationColor);
+
+  gl && gl.vertexAttribPointer(g_AttribLocationPosition, 2, gl.FLOAT, false, ImGui.DrawVertSize, ImGui.DrawVertPosOffset);
+  gl && gl.vertexAttribPointer(g_AttribLocationUV, 2, gl.FLOAT, false, ImGui.DrawVertSize, ImGui.DrawVertUVOffset);
+  gl && gl.vertexAttribPointer(g_AttribLocationColor, 4, gl.UNSIGNED_BYTE, true, ImGui.DrawVertSize, ImGui.DrawVertColOffset);
 }
 
-function UnbindMesh()
-{
-    const gl2: WebGL2RenderingContext | null = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext && gl || null;
-    if(enable_vao) {
-        gl2 && gl2.bindVertexArray(null);
-        //gl2 && gl2.deleteVertexArray(vertex_array_object);
-        //gl_vao && gl_vao.deleteVertexArrayOES(vertex_array_object);
-    }else {
-        gl && gl.bindBuffer(gl.ARRAY_BUFFER, null);
-        gl && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
-    }
+function UnbindMesh() {
+  const gl2: WebGL2RenderingContext | null = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext && gl || null;
+  if (enable_vao) {
+    gl2 && gl2.bindVertexArray(null);
+    //gl2 && gl2.deleteVertexArray(vertex_array_object);
+    //gl_vao && gl_vao.deleteVertexArrayOES(vertex_array_object);
+  } else {
+    gl && gl.bindBuffer(gl.ARRAY_BUFFER, null);
+    gl && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
+  }
 }
 
 export function RenderDrawData(draw_data: ImGui.DrawData | null = ImGui.GetDrawData()): void {
-    const io = ImGui.GetIO();
-
-    font_update(io);
-    scroll_update(io);    
-    input_text_update(io);
-
-    if (draw_data === null) { throw new Error(); }
-
-    gl || ctx || console.log(draw_data);
-
-    // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
-    const fb_width: number = io.DisplaySize.x * io.DisplayFramebufferScale.x;
-    const fb_height: number = io.DisplaySize.y * io.DisplayFramebufferScale.y;
-    if (fb_width === 0 || fb_height === 0) {
-        return;
-    }
-    draw_data.ScaleClipRects(io.DisplayFramebufferScale);
-
-    const gl2: WebGL2RenderingContext | null = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext && gl || null;
-    const gl_vao: OES_vertex_array_object | null = gl && gl.getExtension("OES_vertex_array_object") || null;
-
-    // Backup GL state
-    
-        //const last_active_texture: GLenum | null = gl && gl.getParameter(gl.ACTIVE_TEXTURE) || null;
-        //const last_program: WebGLProgram | null = gl && gl.getParameter(gl.CURRENT_PROGRAM) || null;
-        //const last_texture: WebGLTexture | null = gl && gl.getParameter(gl.TEXTURE_BINDING_2D) || null;
-        //const last_array_buffer: WebGLBuffer | null = gl && gl.getParameter(gl.ARRAY_BUFFER_BINDING) || null;
-        //const last_element_array_buffer: WebGLBuffer | null = gl && gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING) || null;
-        //const last_vertex_array_object: WebGLVertexArrayObject | WebGLVertexArrayObjectOES | null = gl2 && gl2.getParameter(gl2.VERTEX_ARRAY_BINDING) || gl && gl_vao && gl.getParameter(gl_vao.VERTEX_ARRAY_BINDING_OES) || null;
-        // GLint last_polygon_mode[2]; glGetIntegerv(GL_POLYGON_MODE, last_polygon_mode);
-        //const last_viewport: Int32Array | null = gl && gl.getParameter(gl.VIEWPORT) || null;
-        //const last_scissor_box: Int32Array | null = gl && gl.getParameter(gl.SCISSOR_BOX) || null;
-        //const last_blend_src_rgb: GLenum | null = gl && gl.getParameter(gl.BLEND_SRC_RGB) || null;
-        //const last_blend_dst_rgb: GLenum | null = gl && gl.getParameter(gl.BLEND_DST_RGB) || null;
-        //const last_blend_src_alpha: GLenum | null = gl && gl.getParameter(gl.BLEND_SRC_ALPHA) || null;
-        //const last_blend_dst_alpha: GLenum | null = gl && gl.getParameter(gl.BLEND_DST_ALPHA) || null;
-        //const last_blend_equation_rgb: GLenum | null = gl && gl.getParameter(gl.BLEND_EQUATION_RGB) || null;
-        //const last_blend_equation_alpha: GLenum | null = gl && gl.getParameter(gl.BLEND_EQUATION_ALPHA) || null;
-        //const last_enable_blend: GLboolean | null = gl && gl.getParameter(gl.BLEND) || null;
-        //const last_enable_cull_face: GLboolean | null = gl && gl.getParameter(gl.CULL_FACE) || null;
-        //const last_enable_depth_test: GLboolean | null = gl && gl.getParameter(gl.DEPTH_TEST) || null;
-        //const last_enable_scissor_test: GLboolean | null = gl && gl.getParameter(gl.SCISSOR_TEST) || null;
-        const last_enable_scissor_test: GLboolean =false;
-
-        // Setup desired GL state
-    // Recreate the VAO every time (this is to easily allow multiple GL contexts to be rendered to. VAO are not shared among GL contexts)
-    // The renderer would actually work without any VAO bound, but then our VertexAttrib calls would overwrite the default one currently bound.
-
-    // Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled, polygon fill
-    BindState();
-    // glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
-
-    // Setup viewport, orthographic projection matrix
-    // Our visible imgui space lies from draw_data->DisplayPps (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right). DisplayMin is typically (0,0) for single viewport apps.
-    gl && gl.viewport(0, 0, fb_width, fb_height);
-    const L: number = draw_data.DisplayPos.x;
-    const R: number = draw_data.DisplayPos.x + draw_data.DisplaySize.x;
-    const T: number = draw_data.DisplayPos.y;
-    const B: number = draw_data.DisplayPos.y + draw_data.DisplaySize.y;
-    const ortho_projection: Float32Array = new Float32Array([
-        2.0 / (R - L),     0.0,                0.0, 0.0,
-        0.0,               2.0 / (T - B),      0.0, 0.0,
-        0.0,               0.0,               -1.0, 0.0,
-        (R + L) / (L - R), (T + B) / (B - T),  0.0, 1.0,
-    ]);
-    BindShader(ortho_projection);
-    BindMesh();
-    // Draw
-    const pos = draw_data.DisplayPos;
-    let idx_buffer_type: GLenum;
-    draw_data.IterateDrawLists((draw_list: ImGui.DrawList): void => {           
-        gl || ctx || console.log(draw_list);
-        gl || ctx || console.log("VtxBuffer.length", draw_list.VtxBuffer.length);
-        gl || ctx || console.log("IdxBuffer.length", draw_list.IdxBuffer.length);
-            
-        let idx_buffer_offset: number = 0;
-        const vx=draw_list.VtxBuffer;
-        const ix=draw_list.IdxBuffer;
-        let ixU:Uint8Array|Uint16Array|Uint32Array=null;
-        switch(ImGui.DrawIdxSize)   {
-        case 1:
-            ixU=new Uint8Array(ix.buffer.slice(ix.byteOffset, ix.byteOffset+ix.byteLength));
-            idx_buffer_type=gl.UNSIGNED_BYTE;
-            break;
-        case 2:
-            ixU=new Uint16Array(ix.buffer.slice(ix.byteOffset, ix.byteOffset+ix.byteLength));
-            idx_buffer_type=gl.UNSIGNED_SHORT;
-            break;
-        case 4:
-            ixU=new Uint32Array(ix.buffer.slice(ix.byteOffset, ix.byteOffset+ix.byteLength));
-            idx_buffer_type=gl.UNSIGNED_INT;
-            break;
-        }
-
-        if(vx) {
-            gl && gl.bindBuffer(gl.ARRAY_BUFFER, g_VboHandle);
-            gl && gl.bufferData(gl.ARRAY_BUFFER, vx, gl.STREAM_DRAW);
-        }
-        if(ixU) {
-            gl && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, g_ElementsHandle);
-            gl && gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, ixU, gl.STREAM_DRAW);
+  const io = ImGui.GetIO();
+
+  font_update(io);
+  scroll_update(io);
+  input_text_update(io);
+
+  if (draw_data === null) { throw new Error(); }
+
+  gl || ctx || console.log(draw_data);
+
+  // Avoid rendering when minimized, scale coordinates for retina displays (screen coordinates != framebuffer coordinates)
+  const fb_width: number = io.DisplaySize.x * io.DisplayFramebufferScale.x;
+  const fb_height: number = io.DisplaySize.y * io.DisplayFramebufferScale.y;
+  if (fb_width === 0 || fb_height === 0) {
+    return;
+  }
+  draw_data.ScaleClipRects(io.DisplayFramebufferScale);
+
+  const gl2: WebGL2RenderingContext | null = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext && gl || null;
+  const gl_vao: OES_vertex_array_object | null = gl && gl.getExtension("OES_vertex_array_object") || null;
+
+  // Backup GL state
+
+  //const last_active_texture: GLenum | null = gl && gl.getParameter(gl.ACTIVE_TEXTURE) || null;
+  //const last_program: WebGLProgram | null = gl && gl.getParameter(gl.CURRENT_PROGRAM) || null;
+  //const last_texture: WebGLTexture | null = gl && gl.getParameter(gl.TEXTURE_BINDING_2D) || null;
+  //const last_array_buffer: WebGLBuffer | null = gl && gl.getParameter(gl.ARRAY_BUFFER_BINDING) || null;
+  //const last_element_array_buffer: WebGLBuffer | null = gl && gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING) || null;
+  //const last_vertex_array_object: WebGLVertexArrayObject | WebGLVertexArrayObjectOES | null = gl2 && gl2.getParameter(gl2.VERTEX_ARRAY_BINDING) || gl && gl_vao && gl.getParameter(gl_vao.VERTEX_ARRAY_BINDING_OES) || null;
+  // GLint last_polygon_mode[2]; glGetIntegerv(GL_POLYGON_MODE, last_polygon_mode);
+  //const last_viewport: Int32Array | null = gl && gl.getParameter(gl.VIEWPORT) || null;
+  //const last_scissor_box: Int32Array | null = gl && gl.getParameter(gl.SCISSOR_BOX) || null;
+  //const last_blend_src_rgb: GLenum | null = gl && gl.getParameter(gl.BLEND_SRC_RGB) || null;
+  //const last_blend_dst_rgb: GLenum | null = gl && gl.getParameter(gl.BLEND_DST_RGB) || null;
+  //const last_blend_src_alpha: GLenum | null = gl && gl.getParameter(gl.BLEND_SRC_ALPHA) || null;
+  //const last_blend_dst_alpha: GLenum | null = gl && gl.getParameter(gl.BLEND_DST_ALPHA) || null;
+  //const last_blend_equation_rgb: GLenum | null = gl && gl.getParameter(gl.BLEND_EQUATION_RGB) || null;
+  //const last_blend_equation_alpha: GLenum | null = gl && gl.getParameter(gl.BLEND_EQUATION_ALPHA) || null;
+  //const last_enable_blend: GLboolean | null = gl && gl.getParameter(gl.BLEND) || null;
+  //const last_enable_cull_face: GLboolean | null = gl && gl.getParameter(gl.CULL_FACE) || null;
+  //const last_enable_depth_test: GLboolean | null = gl && gl.getParameter(gl.DEPTH_TEST) || null;
+  //const last_enable_scissor_test: GLboolean | null = gl && gl.getParameter(gl.SCISSOR_TEST) || null;
+  const last_enable_scissor_test: GLboolean = false;
+
+  // Setup desired GL state
+  // Recreate the VAO every time (this is to easily allow multiple GL contexts to be rendered to. VAO are not shared among GL contexts)
+  // The renderer would actually work without any VAO bound, but then our VertexAttrib calls would overwrite the default one currently bound.
+
+  // Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled, polygon fill
+  BindState();
+  // glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+
+  // Setup viewport, orthographic projection matrix
+  // Our visible imgui space lies from draw_data->DisplayPps (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right). DisplayMin is typically (0,0) for single viewport apps.
+  gl && gl.viewport(0, 0, fb_width, fb_height);
+  const L: number = draw_data.DisplayPos.x;
+  const R: number = draw_data.DisplayPos.x + draw_data.DisplaySize.x;
+  const T: number = draw_data.DisplayPos.y;
+  const B: number = draw_data.DisplayPos.y + draw_data.DisplaySize.y;
+  const ortho_projection: Float32Array = new Float32Array([
+    2.0 / (R - L), 0.0, 0.0, 0.0,
+    0.0, 2.0 / (T - B), 0.0, 0.0,
+    0.0, 0.0, -1.0, 0.0,
+    (R + L) / (L - R), (T + B) / (B - T), 0.0, 1.0,
+  ]);
+  BindShader(ortho_projection);
+  BindMesh();
+  // Draw
+  const pos = draw_data.DisplayPos;
+  let idx_buffer_type: GLenum;
+  draw_data.IterateDrawLists((draw_list: ImGui.DrawList): void => {
+    gl || ctx || console.log(draw_list);
+    gl || ctx || console.log("VtxBuffer.length", draw_list.VtxBuffer.length);
+    gl || ctx || console.log("IdxBuffer.length", draw_list.IdxBuffer.length);
+
+    let idx_buffer_offset: number = 0;
+    const vx = draw_list.VtxBuffer;
+    const ix = draw_list.IdxBuffer;
+    let ixU: Uint8Array | Uint16Array | Uint32Array = null;
+    switch (ImGui.DrawIdxSize) {
+      case 1:
+        ixU = new Uint8Array(ix.buffer.slice(ix.byteOffset, ix.byteOffset + ix.byteLength));
+        idx_buffer_type = gl.UNSIGNED_BYTE;
+        break;
+      case 2:
+        ixU = new Uint16Array(ix.buffer.slice(ix.byteOffset, ix.byteOffset + ix.byteLength));
+        idx_buffer_type = gl.UNSIGNED_SHORT;
+        break;
+      case 4:
+        ixU = new Uint32Array(ix.buffer.slice(ix.byteOffset, ix.byteOffset + ix.byteLength));
+        idx_buffer_type = gl.UNSIGNED_INT;
+        break;
+    }
+
+    if (vx) {
+      gl && gl.bindBuffer(gl.ARRAY_BUFFER, g_VboHandle);
+      gl && gl.bufferData(gl.ARRAY_BUFFER, vx, gl.STREAM_DRAW);
+    }
+    if (ixU) {
+      gl && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, g_ElementsHandle);
+      gl && gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, ixU, gl.STREAM_DRAW);
+    }
+    draw_list.IterateDrawCmds((draw_cmd: ImGui.DrawCmd): void => {
+      gl || ctx || console.log(draw_cmd);
+      gl || ctx || console.log("ElemCount", draw_cmd.ElemCount);
+      gl || ctx || console.log("ClipRect", draw_cmd.ClipRect.x, fb_height - draw_cmd.ClipRect.w, draw_cmd.ClipRect.z - draw_cmd.ClipRect.x, draw_cmd.ClipRect.w - draw_cmd.ClipRect.y);
+      gl || ctx || console.log("TextureId", draw_cmd.TextureId);
+      if (!gl && !ctx) {
+        console.log("i: pos.x pos.y uv.x uv.y col");
+        for (let i = 0; i < Math.min(3, draw_cmd.ElemCount); ++i) {
+          const view: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i * ImGui.DrawVertSize);
+          console.log(`${i}: ${view.pos[0].toFixed(2)} ${view.pos[1].toFixed(2)} ${view.uv[0].toFixed(5)} ${view.uv[1].toFixed(5)} ${("00000000" + view.col[0].toString(16)).substr(-8)}`);
         }
-        draw_list.IterateDrawCmds((draw_cmd: ImGui.DrawCmd): void => {
-            gl || ctx || console.log(draw_cmd);
-            gl || ctx || console.log("ElemCount", draw_cmd.ElemCount);
-            gl || ctx || console.log("ClipRect", draw_cmd.ClipRect.x, fb_height - draw_cmd.ClipRect.w, draw_cmd.ClipRect.z - draw_cmd.ClipRect.x, draw_cmd.ClipRect.w - draw_cmd.ClipRect.y);
-            gl || ctx || console.log("TextureId", draw_cmd.TextureId);
-            if (!gl && !ctx) {
-                console.log("i: pos.x pos.y uv.x uv.y col");
-                for (let i = 0; i < Math.min(3, draw_cmd.ElemCount); ++i) {
-                    const view: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i * ImGui.DrawVertSize);
-                    console.log(`${i}: ${view.pos[0].toFixed(2)} ${view.pos[1].toFixed(2)} ${view.uv[0].toFixed(5)} ${view.uv[1].toFixed(5)} ${("00000000" + view.col[0].toString(16)).substr(-8)}`);
-                }
-            }
-            
-            if (draw_cmd.UserCallback !== null) {
-                // User callback (registered via ImDrawList::AddCallback)
-                UnbindMesh();
-                draw_cmd.UserCallback(draw_list, draw_cmd);
-                BindState();
-                BindShader(ortho_projection);
-                BindMesh();
-            } else {
-                const clip_rect = new ImGui.Vec4(draw_cmd.ClipRect.x - pos.x, draw_cmd.ClipRect.y - pos.y, draw_cmd.ClipRect.z - pos.x, draw_cmd.ClipRect.w - pos.y);
-                if (clip_rect.x < fb_width && clip_rect.y < fb_height && clip_rect.z >= 0.0 && clip_rect.w >= 0.0) {
-                    // Apply scissor/clipping rectangle
-                    gl && gl.scissor(clip_rect.x, fb_height - clip_rect.w, clip_rect.z - clip_rect.x, clip_rect.w - clip_rect.y);
-
-                    // Bind texture, Draw
-                    gl && gl.activeTexture(gl.TEXTURE0);
-                    gl && gl.bindTexture(gl.TEXTURE_2D, draw_cmd.TextureId);
-                    gl && gl.drawElements(gl.TRIANGLES, draw_cmd.ElemCount, idx_buffer_type, idx_buffer_offset);
-
-                    if (ctx) {
-                        ctx.save();
-                        ctx.beginPath();
-                        ctx.rect(clip_rect.x, clip_rect.y, clip_rect.z - clip_rect.x, clip_rect.w - clip_rect.y);
-                        ctx.clip();
-                        const idx = ImGui.DrawIdxSize === 4 ? 
-                            new Uint32Array(draw_list.IdxBuffer.buffer, draw_list.IdxBuffer.byteOffset + idx_buffer_offset) : 
-                            new Uint16Array(draw_list.IdxBuffer.buffer, draw_list.IdxBuffer.byteOffset + idx_buffer_offset);
-                        for (let i = 0; i < draw_cmd.ElemCount; i += 3) {
-                            const i0: number = idx[i + 0];
-                            const i1: number = idx[i + 1];
-                            const i2: number = idx[i + 2];
-                            const v0: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i0 * ImGui.DrawVertSize);
-                            const v1: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i1 * ImGui.DrawVertSize);
-                            const v2: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i2 * ImGui.DrawVertSize);
-                            const i3: number = idx[i + 3];
-                            const i4: number = idx[i + 4];
-                            const i5: number = idx[i + 5];
-                            const v3: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i3 * ImGui.DrawVertSize);
-                            const v4: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i4 * ImGui.DrawVertSize);
-                            const v5: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i5 * ImGui.DrawVertSize);
-                            let quad = true;
-                            let minmin: ImGui.DrawVert = v0;
-                            let minmax: ImGui.DrawVert = v0;
-                            let maxmin: ImGui.DrawVert = v0;
-                            let maxmax: ImGui.DrawVert = v0;
-                            for (const v of [ v1, v2, v3, v4, v5 ]) {
-                                let found = false;
-                                if (v.pos[0] <= minmin.pos[0] && v.pos[1] <= minmin.pos[1]) { minmin = v; found = true; }
-                                if (v.pos[0] <= minmax.pos[0] && v.pos[1] >= minmax.pos[1]) { minmax = v; found = true; }
-                                if (v.pos[0] >= maxmin.pos[0] && v.pos[1] <= maxmin.pos[1]) { maxmin = v; found = true; }
-                                if (v.pos[0] >= maxmax.pos[0] && v.pos[1] >= maxmax.pos[1]) { maxmax = v; found = true; }
-                                if (!found) { quad = false; }
-                            }
-                            quad = quad && (minmin.pos[0] === minmax.pos[0]);
-                            quad = quad && (maxmin.pos[0] === maxmax.pos[0]);
-                            quad = quad && (minmin.pos[1] === maxmin.pos[1]);
-                            quad = quad && (minmax.pos[1] === maxmax.pos[1]);
-                            if (quad) {
-                                if (minmin.uv[0] === maxmax.uv[0] || minmin.uv[1] === maxmax.uv[1]) {
-                                    // one vertex color
-                                    ctx.beginPath();
-                                    ctx.rect(minmin.pos[0], minmin.pos[1], maxmax.pos[0] - minmin.pos[0], maxmax.pos[1] - minmin.pos[1]);
-                                    ctx.fillStyle = `rgba(${v0.col[0] >> 0 & 0xff}, ${v0.col[0] >> 8 & 0xff}, ${v0.col[0] >> 16 & 0xff}, ${(v0.col[0] >> 24 & 0xff) / 0xff})`;
-                                    ctx.fill();
-                                } else {
-                                    // no vertex color
-                                    const image = draw_cmd.TextureId as CanvasImageSource; // HACK
-                                    let width:number=0;
-                                    let height:number=0;
-                                    if(image instanceof HTMLVideoElement)   {
-                                        width=image.videoWidth;
-                                        height=image.videoHeight;
-                                    }
-                                    else if(has_videoframe && image instanceof VideoFrame)   {
-                                        width=image.displayWidth;
-                                        height=image.displayHeight;
-                                    }
-                                    else {
-                                        let src=image as HTMLCanvasElement | OffscreenCanvas|ImageBitmap|HTMLOrSVGImageElement;
-                                        width=src.width as number;
-                                        height=src.height as number;
-                                    }
-                                    
-                                    image && ctx.drawImage(image,
-                                        minmin.uv[0] * width, minmin.uv[1] * height,
-                                        (maxmax.uv[0] - minmin.uv[0]) * width, (maxmax.uv[1] - minmin.uv[1]) * height,
-                                        minmin.pos[0], minmin.pos[1], 
-                                        maxmax.pos[0] - minmin.pos[0], maxmax.pos[1] - minmin.pos[1]);
-                                    // ctx.beginPath();
-                                    // ctx.rect(minmin.pos[0], minmin.pos[1], maxmax.pos[0] - minmin.pos[0], maxmax.pos[1] - minmin.pos[1]);
-                                    // ctx.strokeStyle = "yellow";
-                                    // ctx.stroke();
-                                }
-                                i += 3;
-                            } else {
-                                // one vertex color, no texture
-                                ctx.beginPath();
-                                ctx.moveTo(v0.pos[0], v0.pos[1]);
-                                ctx.lineTo(v1.pos[0], v1.pos[1]);
-                                ctx.lineTo(v2.pos[0], v2.pos[1]);
-                                ctx.closePath();
-                                ctx.fillStyle = `rgba(${v0.col[0] >> 0 & 0xff}, ${v0.col[0] >> 8 & 0xff}, ${v0.col[0] >> 16 & 0xff}, ${(v0.col[0] >> 24 & 0xff) / 0xff})`;
-                                ctx.fill();
-                            }
-                        }
-                        ctx.restore();
-                    }
+      }
+
+      if (draw_cmd.UserCallback !== null) {
+        // User callback (registered via ImDrawList::AddCallback)
+        UnbindMesh();
+        draw_cmd.UserCallback(draw_list, draw_cmd);
+        BindState();
+        BindShader(ortho_projection);
+        BindMesh();
+      } else {
+        const clip_rect = new ImGui.Vec4(draw_cmd.ClipRect.x - pos.x, draw_cmd.ClipRect.y - pos.y, draw_cmd.ClipRect.z - pos.x, draw_cmd.ClipRect.w - pos.y);
+        if (clip_rect.x < fb_width && clip_rect.y < fb_height && clip_rect.z >= 0.0 && clip_rect.w >= 0.0) {
+          // Apply scissor/clipping rectangle
+          gl && gl.scissor(clip_rect.x, fb_height - clip_rect.w, clip_rect.z - clip_rect.x, clip_rect.w - clip_rect.y);
+
+          // Bind texture, Draw
+          gl && gl.activeTexture(gl.TEXTURE0);
+          gl && gl.bindTexture(gl.TEXTURE_2D, draw_cmd.TextureId);
+          gl && gl.drawElements(gl.TRIANGLES, draw_cmd.ElemCount, idx_buffer_type, idx_buffer_offset);
+
+          if (ctx) {
+            ctx.save();
+            ctx.beginPath();
+            ctx.rect(clip_rect.x, clip_rect.y, clip_rect.z - clip_rect.x, clip_rect.w - clip_rect.y);
+            ctx.clip();
+            const idx = ImGui.DrawIdxSize === 4 ?
+              new Uint32Array(draw_list.IdxBuffer.buffer, draw_list.IdxBuffer.byteOffset + idx_buffer_offset) :
+              new Uint16Array(draw_list.IdxBuffer.buffer, draw_list.IdxBuffer.byteOffset + idx_buffer_offset);
+            for (let i = 0; i < draw_cmd.ElemCount; i += 3) {
+              const i0: number = idx[i + 0];
+              const i1: number = idx[i + 1];
+              const i2: number = idx[i + 2];
+              const v0: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i0 * ImGui.DrawVertSize);
+              const v1: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i1 * ImGui.DrawVertSize);
+              const v2: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i2 * ImGui.DrawVertSize);
+              const i3: number = idx[i + 3];
+              const i4: number = idx[i + 4];
+              const i5: number = idx[i + 5];
+              const v3: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i3 * ImGui.DrawVertSize);
+              const v4: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i4 * ImGui.DrawVertSize);
+              const v5: ImGui.DrawVert = new ImGui.DrawVert(draw_list.VtxBuffer.buffer, draw_list.VtxBuffer.byteOffset + i5 * ImGui.DrawVertSize);
+              let quad = true;
+              let minmin: ImGui.DrawVert = v0;
+              let minmax: ImGui.DrawVert = v0;
+              let maxmin: ImGui.DrawVert = v0;
+              let maxmax: ImGui.DrawVert = v0;
+              for (const v of [v1, v2, v3, v4, v5]) {
+                let found = false;
+                if (v.pos[0] <= minmin.pos[0] && v.pos[1] <= minmin.pos[1]) { minmin = v; found = true; }
+                if (v.pos[0] <= minmax.pos[0] && v.pos[1] >= minmax.pos[1]) { minmax = v; found = true; }
+                if (v.pos[0] >= maxmin.pos[0] && v.pos[1] <= maxmin.pos[1]) { maxmin = v; found = true; }
+                if (v.pos[0] >= maxmax.pos[0] && v.pos[1] >= maxmax.pos[1]) { maxmax = v; found = true; }
+                if (!found) { quad = false; }
+              }
+              quad = quad && (minmin.pos[0] === minmax.pos[0]);
+              quad = quad && (maxmin.pos[0] === maxmax.pos[0]);
+              quad = quad && (minmin.pos[1] === maxmin.pos[1]);
+              quad = quad && (minmax.pos[1] === maxmax.pos[1]);
+              if (quad) {
+                if (minmin.uv[0] === maxmax.uv[0] || minmin.uv[1] === maxmax.uv[1]) {
+                  // one vertex color
+                  ctx.beginPath();
+                  ctx.rect(minmin.pos[0], minmin.pos[1], maxmax.pos[0] - minmin.pos[0], maxmax.pos[1] - minmin.pos[1]);
+                  ctx.fillStyle = `rgba(${v0.col[0] >> 0 & 0xff}, ${v0.col[0] >> 8 & 0xff}, ${v0.col[0] >> 16 & 0xff}, ${(v0.col[0] >> 24 & 0xff) / 0xff})`;
+                  ctx.fill();
+                } else {
+                  // no vertex color
+                  const image = draw_cmd.TextureId as CanvasImageSource; // HACK
+                  let width: number = 0;
+                  let height: number = 0;
+                  if (image instanceof HTMLVideoElement) {
+                    width = image.videoWidth;
+                    height = image.videoHeight;
+                  }
+                  else if (has_videoframe && image instanceof VideoFrame) {
+                    width = image.displayWidth;
+                    height = image.displayHeight;
+                  }
+                  else {
+                    let src = image as HTMLCanvasElement | OffscreenCanvas | ImageBitmap | HTMLOrSVGImageElement;
+                    width = src.width as number;
+                    height = src.height as number;
+                  }
+
+                  image && ctx.drawImage(image,
+                    minmin.uv[0] * width, minmin.uv[1] * height,
+                    (maxmax.uv[0] - minmin.uv[0]) * width, (maxmax.uv[1] - minmin.uv[1]) * height,
+                    minmin.pos[0], minmin.pos[1],
+                    maxmax.pos[0] - minmin.pos[0], maxmax.pos[1] - minmin.pos[1]);
+                  // ctx.beginPath();
+                  // ctx.rect(minmin.pos[0], minmin.pos[1], maxmax.pos[0] - minmin.pos[0], maxmax.pos[1] - minmin.pos[1]);
+                  // ctx.strokeStyle = "yellow";
+                  // ctx.stroke();
                 }
+                i += 3;
+              } else {
+                // one vertex color, no texture
+                ctx.beginPath();
+                ctx.moveTo(v0.pos[0], v0.pos[1]);
+                ctx.lineTo(v1.pos[0], v1.pos[1]);
+                ctx.lineTo(v2.pos[0], v2.pos[1]);
+                ctx.closePath();
+                ctx.fillStyle = `rgba(${v0.col[0] >> 0 & 0xff}, ${v0.col[0] >> 8 & 0xff}, ${v0.col[0] >> 16 & 0xff}, ${(v0.col[0] >> 24 & 0xff) / 0xff})`;
+                ctx.fill();
+              }
             }
+            ctx.restore();
+          }
+        }
+      }
 
-            idx_buffer_offset += draw_cmd.ElemCount * ImGui.DrawIdxSize;
-        });
+      idx_buffer_offset += draw_cmd.ElemCount * ImGui.DrawIdxSize;
     });
-
-    // Destroy the temporary VAO
-    UnbindMesh();
-    // Restore modified GL state
-    
-        //gl && (last_program !== null) && gl.useProgram(last_program);
-        //gl && (last_texture !== null) && gl.bindTexture(gl.TEXTURE_2D, last_texture);
-        //gl && (last_active_texture !== null) && gl.activeTexture(last_active_texture);
-        //gl2 && gl2.bindVertexArray(last_vertex_array_object);
-        //gl_vao && gl_vao.bindVertexArrayOES(last_vertex_array_object);
-        //gl && (last_array_buffer !== null) && gl.bindBuffer(gl.ARRAY_BUFFER, last_array_buffer);
-        //gl && (last_element_array_buffer !== null) && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, last_element_array_buffer);
-        //gl && (last_blend_equation_rgb !== null && last_blend_equation_alpha !== null) && gl.blendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);
-        //gl && (last_blend_src_rgb !== null && last_blend_src_alpha !== null && last_blend_dst_rgb !== null && last_blend_dst_alpha !== null) && gl.blendFuncSeparate(last_blend_src_rgb, last_blend_src_alpha, last_blend_dst_rgb, last_blend_dst_alpha);
-        //gl && (last_enable_blend ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND));
-        //gl && (last_enable_cull_face ? gl.enable(gl.CULL_FACE) : gl.disable(gl.CULL_FACE));
-        //gl && (last_enable_depth_test ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST));
-        gl && (last_enable_scissor_test ? gl.enable(gl.SCISSOR_TEST) : gl.disable(gl.SCISSOR_TEST));
-        // glPolygonMode(GL_FRONT_AND_BACK, (GLenum)last_polygon_mode[0]);
-        //gl && (last_viewport !== null) && gl.viewport(last_viewport[0], last_viewport[1], last_viewport[2], last_viewport[3]);
-        //gl && (last_scissor_box !== null) && gl.scissor(last_scissor_box[0], last_scissor_box[1], last_scissor_box[2], last_scissor_box[3]);
+  });
+
+  // Destroy the temporary VAO
+  UnbindMesh();
+  // Restore modified GL state
+
+  //gl && (last_program !== null) && gl.useProgram(last_program);
+  //gl && (last_texture !== null) && gl.bindTexture(gl.TEXTURE_2D, last_texture);
+  //gl && (last_active_texture !== null) && gl.activeTexture(last_active_texture);
+  //gl2 && gl2.bindVertexArray(last_vertex_array_object);
+  //gl_vao && gl_vao.bindVertexArrayOES(last_vertex_array_object);
+  //gl && (last_array_buffer !== null) && gl.bindBuffer(gl.ARRAY_BUFFER, last_array_buffer);
+  //gl && (last_element_array_buffer !== null) && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, last_element_array_buffer);
+  //gl && (last_blend_equation_rgb !== null && last_blend_equation_alpha !== null) && gl.blendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);
+  //gl && (last_blend_src_rgb !== null && last_blend_src_alpha !== null && last_blend_dst_rgb !== null && last_blend_dst_alpha !== null) && gl.blendFuncSeparate(last_blend_src_rgb, last_blend_src_alpha, last_blend_dst_rgb, last_blend_dst_alpha);
+  //gl && (last_enable_blend ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND));
+  //gl && (last_enable_cull_face ? gl.enable(gl.CULL_FACE) : gl.disable(gl.CULL_FACE));
+  //gl && (last_enable_depth_test ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST));
+  gl && (last_enable_scissor_test ? gl.enable(gl.SCISSOR_TEST) : gl.disable(gl.SCISSOR_TEST));
+  // glPolygonMode(GL_FRONT_AND_BACK, (GLenum)last_polygon_mode[0]);
+  //gl && (last_viewport !== null) && gl.viewport(last_viewport[0], last_viewport[1], last_viewport[2], last_viewport[3]);
+  //gl && (last_scissor_box !== null) && gl.scissor(last_scissor_box[0], last_scissor_box[1], last_scissor_box[2], last_scissor_box[3]);
 }
 
 export function CreateFontsTexture(): void {
-    const io = ImGui.GetIO();    
-
-    // Backup GL state
-    const last_texture: WebGLTexture | null = gl && gl.getParameter(gl.TEXTURE_BINDING_2D);
-
-    // Build texture atlas
-    // const width: number = 256;
-    // const height: number = 256;
-    // const pixels: Uint8Array = new Uint8Array(4 * width * height).fill(0xff);
-    
-    //const { width, height, pixels } = io.Fonts.GetTexDataAsRGBA32();   // Load as RGBA 32-bits (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.
-    const { width, height, pixels } = io.Fonts.GetTexDataAsAlpha8();
-    if(width && height && pixels) {
-        let rgba4:Uint16Array=new Uint16Array(width*height);
-        let i=0;
-        pixels.forEach(p=>{
-            rgba4[i]=0xFFF0|(p>>4);
-            i++;
-        })
-        
-        // Upload texture to graphics system
-        g_FontTexture = gl && gl.createTexture();
-        gl && gl.bindTexture(gl.TEXTURE_2D, g_FontTexture);
-        gl && gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
-        gl && gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
-        // gl && gl.pixelStorei(gl.UNPACK_ROW_LENGTH); // WebGL2
-        gl && gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_SHORT_4_4_4_4, rgba4);
-        //gl && gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
-
-        // Store our identifier
-        io.Fonts.TexID = g_FontTexture || { foo: "bar" };
-        // console.log("font texture id", g_FontTexture);
-    }
-    if (ctx) {
-        const image_canvas: HTMLCanvasElement = document.createElement("canvas");
-        image_canvas.width = width;
-        image_canvas.height = height;
-        const image_ctx = image_canvas.getContext("2d");
-        if (image_ctx === null) { throw new Error(); }
-        const image_data = image_ctx.getImageData(0, 0, width, height);
-        image_data.data.set(pixels);
-        image_ctx.putImageData(image_data, 0, 0);
-        io.Fonts.TexID = image_canvas;
-    }
-
-    // Restore modified GL state
-    gl && last_texture && gl.bindTexture(gl.TEXTURE_2D, last_texture);
+  const io = ImGui.GetIO();
+
+  // Backup GL state
+  const last_texture: WebGLTexture | null = gl && gl.getParameter(gl.TEXTURE_BINDING_2D);
+
+  // Build texture atlas
+  // const width: number = 256;
+  // const height: number = 256;
+  // const pixels: Uint8Array = new Uint8Array(4 * width * height).fill(0xff);
+
+  //const { width, height, pixels } = io.Fonts.GetTexDataAsRGBA32();   // Load as RGBA 32-bits (75% of the memory is wasted, but default font is so small) because it is more likely to be compatible with user's existing shaders. If your ImTextureId represent a higher-level concept than just a GL texture id, consider calling GetTexDataAsAlpha8() instead to save on GPU memory.
+  const { width, height, pixels } = io.Fonts.GetTexDataAsAlpha8();
+  if (width && height && pixels) {
+    let rgba4: Uint16Array = new Uint16Array(width * height);
+    let i = 0;
+    pixels.forEach(p => {
+      rgba4[i] = 0xFFF0 | (p >> 4);
+      i++;
+    })
+
+    // Upload texture to graphics system
+    g_FontTexture = gl && gl.createTexture();
+    gl && gl.bindTexture(gl.TEXTURE_2D, g_FontTexture);
+    gl && gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
+    gl && gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
+    // gl && gl.pixelStorei(gl.UNPACK_ROW_LENGTH); // WebGL2
+    gl && gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_SHORT_4_4_4_4, rgba4);
+    //gl && gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
+
+    // Store our identifier
+    io.Fonts.TexID = g_FontTexture || { foo: "bar" };
+    // console.log("font texture id", g_FontTexture);
+  }
+  if (ctx) {
+    const image_canvas: HTMLCanvasElement = document.createElement("canvas");
+    image_canvas.width = width;
+    image_canvas.height = height;
+    const image_ctx = image_canvas.getContext("2d");
+    if (image_ctx === null) { throw new Error(); }
+    const image_data = image_ctx.getImageData(0, 0, width, height);
+    image_data.data.set(pixels);
+    image_ctx.putImageData(image_data, 0, 0);
+    io.Fonts.TexID = image_canvas;
+  }
+
+  // Restore modified GL state
+  gl && last_texture && gl.bindTexture(gl.TEXTURE_2D, last_texture);
 }
 
 export function DestroyFontsTexture(): void {
-    const io = ImGui.GetIO();
-    io.Fonts.TexID = null;
-    gl && gl.deleteTexture(g_FontTexture); g_FontTexture = null;
-    if(dom_font)    {
-        dom_font.Destroy();
-        dom_font=null;
-    }
+  const io = ImGui.GetIO();
+  io.Fonts.TexID = null;
+  gl && gl.deleteTexture(g_FontTexture); g_FontTexture = null;
+  if (dom_font) {
+    dom_font.Destroy();
+    dom_font = null;
+  }
 }
 
 export function CreateDeviceObjects(): void {
-    const vertex_shader: string[] = [
-        "uniform mat4 ProjMtx;",
-        "attribute vec2 Position;",
-        "attribute vec2 UV;",
-        "attribute vec4 Color;",
-        "varying vec2 Frag_UV;",
-        "varying vec4 Frag_Color;",
-        "void main() {",
-        "	Frag_UV = UV;",
-        "	Frag_Color = Color;",
-        "	gl_Position = ProjMtx * vec4(Position.xy,0,1);",
-        "}",
-    ];
-
-    const fragment_shader: string[] = [
-        "precision mediump float;", // WebGL requires precision specifiers
-        "uniform sampler2D Texture;",
-        "varying vec2 Frag_UV;",
-        "varying vec4 Frag_Color;",
-        "void main() {",
-        "	gl_FragColor = Frag_Color * texture2D(Texture, Frag_UV);",
-        "}",
-    ];
-
-    g_ShaderHandle = gl && gl.createProgram();
-    g_VertHandle = gl && gl.createShader(gl.VERTEX_SHADER);
-    g_FragHandle = gl && gl.createShader(gl.FRAGMENT_SHADER);
-    gl && gl.shaderSource(g_VertHandle as WebGLShader, vertex_shader.join("\n"));
-    gl && gl.shaderSource(g_FragHandle as WebGLShader, fragment_shader.join("\n"));
-    gl && gl.compileShader(g_VertHandle as WebGLShader);
-    gl && gl.compileShader(g_FragHandle as WebGLShader);
-    gl && gl.attachShader(g_ShaderHandle as WebGLProgram, g_VertHandle as WebGLShader);
-    gl && gl.attachShader(g_ShaderHandle as WebGLProgram, g_FragHandle as WebGLShader);
-    gl && gl.linkProgram(g_ShaderHandle as WebGLProgram);
-
-    g_AttribLocationTex = gl && gl.getUniformLocation(g_ShaderHandle as WebGLProgram, "Texture");
-    g_AttribLocationProjMtx = gl && gl.getUniformLocation(g_ShaderHandle as WebGLProgram, "ProjMtx");
-    g_AttribLocationPosition = gl && gl.getAttribLocation(g_ShaderHandle as WebGLProgram, "Position") || 0;
-    g_AttribLocationUV = gl && gl.getAttribLocation(g_ShaderHandle as WebGLProgram, "UV") || 0;
-    g_AttribLocationColor = gl && gl.getAttribLocation(g_ShaderHandle as WebGLProgram, "Color") || 0;
-
-    g_VboHandle = gl && gl.createBuffer();
-    g_ElementsHandle = gl && gl.createBuffer();
-
-    CreateFontsTexture();
+  const vertex_shader: string[] = [
+    "uniform mat4 ProjMtx;",
+    "attribute vec2 Position;",
+    "attribute vec2 UV;",
+    "attribute vec4 Color;",
+    "varying vec2 Frag_UV;",
+    "varying vec4 Frag_Color;",
+    "void main() {",
+    "	Frag_UV = UV;",
+    "	Frag_Color = Color;",
+    "	gl_Position = ProjMtx * vec4(Position.xy,0,1);",
+    "}",
+  ];
+
+  const fragment_shader: string[] = [
+    "precision mediump float;", // WebGL requires precision specifiers
+    "uniform sampler2D Texture;",
+    "varying vec2 Frag_UV;",
+    "varying vec4 Frag_Color;",
+    "void main() {",
+    "	gl_FragColor = Frag_Color * texture2D(Texture, Frag_UV);",
+    "}",
+  ];
+
+  g_ShaderHandle = gl && gl.createProgram();
+  g_VertHandle = gl && gl.createShader(gl.VERTEX_SHADER);
+  g_FragHandle = gl && gl.createShader(gl.FRAGMENT_SHADER);
+  gl && gl.shaderSource(g_VertHandle as WebGLShader, vertex_shader.join("\n"));
+  gl && gl.shaderSource(g_FragHandle as WebGLShader, fragment_shader.join("\n"));
+  gl && gl.compileShader(g_VertHandle as WebGLShader);
+  gl && gl.compileShader(g_FragHandle as WebGLShader);
+  gl && gl.attachShader(g_ShaderHandle as WebGLProgram, g_VertHandle as WebGLShader);
+  gl && gl.attachShader(g_ShaderHandle as WebGLProgram, g_FragHandle as WebGLShader);
+  gl && gl.linkProgram(g_ShaderHandle as WebGLProgram);
+
+  g_AttribLocationTex = gl && gl.getUniformLocation(g_ShaderHandle as WebGLProgram, "Texture");
+  g_AttribLocationProjMtx = gl && gl.getUniformLocation(g_ShaderHandle as WebGLProgram, "ProjMtx");
+  g_AttribLocationPosition = gl && gl.getAttribLocation(g_ShaderHandle as WebGLProgram, "Position") || 0;
+  g_AttribLocationUV = gl && gl.getAttribLocation(g_ShaderHandle as WebGLProgram, "UV") || 0;
+  g_AttribLocationColor = gl && gl.getAttribLocation(g_ShaderHandle as WebGLProgram, "Color") || 0;
+
+  g_VboHandle = gl && gl.createBuffer();
+  g_ElementsHandle = gl && gl.createBuffer();
+
+  CreateFontsTexture();
 }
 
 export function DestroyDeviceObjects(): void {
-    DestroyFontsTexture();
-
-    const gl2: WebGL2RenderingContext | null = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext && gl || null;
-    if(g_vao) {
-        gl2 && gl2.deleteVertexArray(g_vao);
-    }
-    gl && gl.deleteBuffer(g_VboHandle); g_VboHandle = null;
-    gl && gl.deleteBuffer(g_ElementsHandle); g_ElementsHandle = null;
-
-    g_AttribLocationTex = null;
-    g_AttribLocationProjMtx = null;
-    g_AttribLocationPosition = -1;
-    g_AttribLocationUV = -1;
-    g_AttribLocationColor = -1;
-
-    gl && gl.deleteProgram(g_ShaderHandle); g_ShaderHandle = null;
-    gl && gl.deleteShader(g_VertHandle); g_VertHandle = null;
-    gl && gl.deleteShader(g_FragHandle); g_FragHandle = null;
+  DestroyFontsTexture();
+
+  const gl2: WebGL2RenderingContext | null = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext && gl || null;
+  if (g_vao) {
+    gl2 && gl2.deleteVertexArray(g_vao);
+  }
+  gl && gl.deleteBuffer(g_VboHandle); g_VboHandle = null;
+  gl && gl.deleteBuffer(g_ElementsHandle); g_ElementsHandle = null;
+
+  g_AttribLocationTex = null;
+  g_AttribLocationProjMtx = null;
+  g_AttribLocationPosition = -1;
+  g_AttribLocationUV = -1;
+  g_AttribLocationColor = -1;
+
+  gl && gl.deleteProgram(g_ShaderHandle); g_ShaderHandle = null;
+  gl && gl.deleteShader(g_VertHandle); g_VertHandle = null;
+  gl && gl.deleteShader(g_FragHandle); g_FragHandle = null;
 }
 
-export interface ITextureParam
-{
-    internalFormat?:number;
-    srcFormat?:number;
-    srcType?:number;
-    width?:number;
-    height?:number;
-    level?:number;
+export interface ITextureParam {
+  internalFormat?: number;
+  srcFormat?: number;
+  srcType?: number;
+  width?: number;
+  height?: number;
+  level?: number;
 }
 
-export class Texture
-{
-    public _texture:WebGLTexture;
-    public _internalFormat:number=gl.RGBA;
-    public _srcFormat:number=gl.RGBA;
-    public _srcType:number=gl.UNSIGNED_BYTE;
-    public _wrapS:number=gl.CLAMP_TO_EDGE;
-    public _wrapT:number=gl.CLAMP_TO_EDGE;
-    public _minFilter:number=gl.LINEAR;
-    public _magFilter:number=gl.LINEAR;
-    public _width:number=1;
-    public _height:number=1;
-
-    constructor(param?: ITextureParam)
-    {
-
-    }
-    public Destroy():void {
-        if(this._texture)   {
-            gl && gl.deleteTexture(this._texture); 
-            this._texture = null;
-        }
-    }
-    public Bind(index:number=gl.TEXTURE0):void {
-        gl.activeTexture(index);
-        gl.bindTexture(gl.TEXTURE_2D, this._texture);
-    }
-
-    public Update(src:TexImageSource|Uint8Array|Uint16Array|null, param?:any):void {
-        let w, h;
-        if(src==null)   {
-            if(param) {
-                w=param.width;
-                h=param.height;
-            }
-        }
-        else if(src instanceof HTMLVideoElement) {
-            let srcVideo=src as HTMLVideoElement;
-            if(srcVideo)    {
-                w=srcVideo.videoWidth;
-                h=srcVideo.videoHeight;
-            }
-        }
-        else if(has_videoframe && src instanceof VideoFrame) {
-            w=src.displayWidth;
-            h=src.displayHeight;
-        }
-        else if(src instanceof Uint8Array||src instanceof Uint16Array) 
-        {
-            if(param) {
-                w=param.width;
-                h=param.height;
-            }else {
-                w=this._width;
-                h=this._height;
-            }
-        }else {
-            let s=src as HTMLCanvasElement|OffscreenCanvas|ImageBitmap|ImageData|HTMLImageElement;
-            w=s.width;
-            h=s.height;    
-        }
-        if(!this._texture)  {
-            this._texture=gl.createTexture();
-            gl.bindTexture(gl.TEXTURE_2D, this._texture);
-            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);
-            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);
-            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);                        
-        }
-        const level = param? param.level ? param.level : 0 : 0;
-        gl.bindTexture(gl.TEXTURE_2D, this._texture);
-        gl && gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._minFilter);
-        gl && gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._magFilter);    
-        if(w!=this._width||h!=this._height) {
-            if(src==null) {
-                const data:ArrayBufferView=null;
-                gl.texImage2D(gl.TEXTURE_2D, level, this._internalFormat, 
-                    w,h,0,this._srcFormat, this._srcType, data);
-            }
-            else if(src instanceof Uint8Array||src instanceof Uint16Array) {
-                gl.texImage2D(gl.TEXTURE_2D, level, this._internalFormat, 
-                    w,h,0,this._srcFormat, this._srcType, src);
-            }else {
-                gl.texImage2D(gl.TEXTURE_2D, level, this._internalFormat,
-                    this._srcFormat, this._srcType, src);    
-            }
-            this._width=w;
-            this._height=h;
-        }else {
-            if(src instanceof Uint8Array||src instanceof Uint16Array) {
-                gl.texSubImage2D(gl.TEXTURE_2D, level, 0, 0, w, h, this._srcFormat, this._srcType, src);
-            }else {
-                gl.texSubImage2D(gl.TEXTURE_2D, level, 0, 0, this._srcFormat, this._srcType, src);
-            }
-        }
-    }
+export class Texture {
+  public _texture: WebGLTexture;
+  public _internalFormat: number = gl.RGBA;
+  public _srcFormat: number = gl.RGBA;
+  public _srcType: number = gl.UNSIGNED_BYTE;
+  public _wrapS: number = gl.CLAMP_TO_EDGE;
+  public _wrapT: number = gl.CLAMP_TO_EDGE;
+  public _minFilter: number = gl.LINEAR;
+  public _magFilter: number = gl.LINEAR;
+  public _width: number = 1;
+  public _height: number = 1;
+
+  constructor(param?: ITextureParam) {
+
+  }
+  public Destroy(): void {
+    if (this._texture) {
+      gl && gl.deleteTexture(this._texture);
+      this._texture = null;
+    }
+  }
+  public Bind(index: number = gl.TEXTURE0): void {
+    gl.activeTexture(index);
+    gl.bindTexture(gl.TEXTURE_2D, this._texture);
+  }
+
+  public Update(src: TexImageSource | Uint8Array | Uint16Array | null, param?: any): void {
+    let w, h;
+    if (src == null) {
+      if (param) {
+        w = param.width;
+        h = param.height;
+      }
+    }
+    else if (src instanceof HTMLVideoElement) {
+      let srcVideo = src as HTMLVideoElement;
+      if (srcVideo) {
+        w = srcVideo.videoWidth;
+        h = srcVideo.videoHeight;
+      }
+    }
+    else if (has_videoframe && src instanceof VideoFrame) {
+      w = src.displayWidth;
+      h = src.displayHeight;
+    }
+    else if (src instanceof Uint8Array || src instanceof Uint16Array) {
+      if (param) {
+        w = param.width;
+        h = param.height;
+      } else {
+        w = this._width;
+        h = this._height;
+      }
+    } else {
+      let s = src as HTMLCanvasElement | OffscreenCanvas | ImageBitmap | ImageData | HTMLImageElement;
+      w = s.width;
+      h = s.height;
+    }
+    if (!this._texture) {
+      this._texture = gl.createTexture();
+      gl.bindTexture(gl.TEXTURE_2D, this._texture);
+      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);
+      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);
+      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
+    }
+    const level = param ? param.level ? param.level : 0 : 0;
+    gl.bindTexture(gl.TEXTURE_2D, this._texture);
+    gl && gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._minFilter);
+    gl && gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._magFilter);
+    if (w != this._width || h != this._height) {
+      if (src == null) {
+        const data: ArrayBufferView = null;
+        gl.texImage2D(gl.TEXTURE_2D, level, this._internalFormat,
+          w, h, 0, this._srcFormat, this._srcType, data);
+      }
+      else if (src instanceof Uint8Array || src instanceof Uint16Array) {
+        gl.texImage2D(gl.TEXTURE_2D, level, this._internalFormat,
+          w, h, 0, this._srcFormat, this._srcType, src);
+      } else {
+        gl.texImage2D(gl.TEXTURE_2D, level, this._internalFormat,
+          this._srcFormat, this._srcType, src);
+      }
+      this._width = w;
+      this._height = h;
+    } else {
+      if (src instanceof Uint8Array || src instanceof Uint16Array) {
+        gl.texSubImage2D(gl.TEXTURE_2D, level, 0, 0, w, h, this._srcFormat, this._srcType, src);
+      } else {
+        gl.texSubImage2D(gl.TEXTURE_2D, level, 0, 0, this._srcFormat, this._srcType, src);
+      }
+    }
+  }
 
 }
 
-export class TextureCache
-{
-    public constructor() 
-    {
-    }
-
-    public Destroy():void {
-        Object.entries(this.cache).forEach(([key, value])=>{
-            value.Destroy();            
-        });
-        this.cache={};
-    }
+export class TextureCache {
+  public constructor() {
+  }
 
-    public async Load(name:string, src:string) :Promise<Texture>
-    {
-        var tex: Texture =new Texture();
-        var image=new Image();
-        image.crossOrigin="anonymous";
-        image.src=src;
-        image.onload=()=>{
-            tex.Update(image);
-        }
-        this.cache[name]=tex;
-        return tex;
-    }
-
-    public cache:{[key:string]:Texture}={};
+  public Destroy(): void {
+    Object.entries(this.cache).forEach(([key, value]) => {
+      value.Destroy();
+    });
+    this.cache = {};
+  }
+
+  public async Load(name: string, src: string): Promise<Texture> {
+    var tex: Texture = new Texture();
+    var image = new Image();
+    image.crossOrigin = "anonymous";
+    image.src = src;
+    image.onload = () => {
+      tex.Update(image);
+    }
+    this.cache[name] = tex;
+    return tex;
+  }
+
+  public cache: { [key: string]: Texture } = {};
 }
 
-export class FrameBufferObject
-{
-    public constructor() 
-    {
-    }
-
-    public Destroy():void 
-    {
-        if(this._target)    {
-            this._target.Destroy();
-            this._target=null;
-        }
-        if(this._depth) {
-            gl.deleteRenderbuffer(this._depth);
-            this._depth=null;
-        }
-        if(this._fbo)   {
-            gl.deleteFramebuffer(this._fbo);
-            this._fbo=null;
-        }
-    }
-
-    public Create(width:number, height:number, format:number=gl.RGB, depth:number=gl.DEPTH_COMPONENT16):void {
-        this.width=width;
-        this.height=height;
-        this.format=format;
-        this.depth_format=depth;
-    }
-
-    public Bind(use:boolean=true):void {
-        if(use) {
-            if(!this._target)   {
-                let target=new Texture();
-                target._srcFormat=target._internalFormat=this.format;
-                target.Update(null, {width:this.width, height:this.height});
-                this._target=target;
-            }
-            if(this.depth_format && !this._depth)   {
-                let depth=gl.createRenderbuffer();
-                gl.bindRenderbuffer(gl.RENDERBUFFER, depth);
-                gl.renderbufferStorage(gl.RENDERBUFFER, this.depth_format, this.width, this.height);                
-                this._depth=depth;
-            }
-            if(!this._fbo)  {
-                let fbo=gl.createFramebuffer();
-                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
-                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
-                    gl.TEXTURE_2D, this._target._texture, 0);
-                if(this._depth) {
-                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
-                        gl.RENDERBUFFER, this._depth);
-                }
-                this._fbo=fbo;
-            }
-            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
-            gl.viewport(0,0,this.width, this.height);
-        }else {
-            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
+export class FrameBufferObject {
+  public constructor() {
+  }
+
+  public Destroy(): void {
+    if (this._target) {
+      this._target.Destroy();
+      this._target = null;
+    }
+    if (this._depth) {
+      gl.deleteRenderbuffer(this._depth);
+      this._depth = null;
+    }
+    if (this._fbo) {
+      gl.deleteFramebuffer(this._fbo);
+      this._fbo = null;
+    }
+  }
+
+  public Create(width: number, height: number, format: number = gl.RGB, depth: number = gl.DEPTH_COMPONENT16): void {
+    this.width = width;
+    this.height = height;
+    this.format = format;
+    this.depth_format = depth;
+  }
+
+  public Bind(use: boolean = true): void {
+    if (use) {
+      if (!this._target) {
+        let target = new Texture();
+        target._srcFormat = target._internalFormat = this.format;
+        target.Update(null, { width: this.width, height: this.height });
+        this._target = target;
+      }
+      if (this.depth_format && !this._depth) {
+        let depth = gl.createRenderbuffer();
+        gl.bindRenderbuffer(gl.RENDERBUFFER, depth);
+        gl.renderbufferStorage(gl.RENDERBUFFER, this.depth_format, this.width, this.height);
+        this._depth = depth;
+      }
+      if (!this._fbo) {
+        let fbo = gl.createFramebuffer();
+        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
+        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
+          gl.TEXTURE_2D, this._target._texture, 0);
+        if (this._depth) {
+          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
+            gl.RENDERBUFFER, this._depth);
         }
-    }
-    public get_texture():WebGLTexture {
-        return this._target?this._target._texture:null;
-    }
-
-    private _fbo: WebGLFramebuffer;
-    private _target:Texture;
-    private _depth:WebGLRenderbuffer;
-    public width:number;
-    public height:number;
-    public format:number;
-    public depth_format:number;
+        this._fbo = fbo;
+      }
+      gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo);
+      gl.viewport(0, 0, this.width, this.height);
+    } else {
+      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
+    }
+  }
+  public get_texture(): WebGLTexture {
+    return this._target ? this._target._texture : null;
+  }
+
+  private _fbo: WebGLFramebuffer;
+  private _target: Texture;
+  private _depth: WebGLRenderbuffer;
+  public width: number;
+  public height: number;
+  public format: number;
+  public depth_format: number;
 }
 
-export class Shader
-{
-    constructor()
-    {
-
-    }
-    public Destroy():void {
-        if(this._program)   {
-            gl && gl.deleteProgram(this._program);
-            this._program = null;
-        }
-        if(this._vs)   {
-            gl && gl.deleteShader(this._vs);
-            this._vs = null;
-        }
-        if(this._ps) {
-            gl && gl.deleteShader(this._ps);
-            this._ps = null;        
-        }
-    }
-    public Create(vsCode:string[], psCode:string[]):void {
-        let vs;
-        if(vsCode)  {
-            vs=gl && gl.createShader(gl.VERTEX_SHADER);
-            gl && gl.shaderSource(vs as WebGLShader, vsCode.join("\n"));
-            gl && gl.compileShader(vs as WebGLShader);
-            if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
-                console.log('VertexShader compile failed: ' + gl.getShaderInfoLog(vs));
-            }
-            this._vs=vs;
-        }else {
-            vs=g_VertHandle;
-        }
-    
-        let ps;
-        if(psCode)  {
-            ps = gl && gl.createShader(gl.FRAGMENT_SHADER);
-            gl && gl.shaderSource(ps as WebGLShader, psCode.join("\n"));
-            gl && gl.compileShader(ps as WebGLShader);
-            if(!gl.getShaderParameter(ps, gl.COMPILE_STATUS)) {
-                console.log('FragmentShader compile failed: ' + gl.getShaderInfoLog(ps));
-            }
-            this._ps=ps;
-        }else {
-            ps=g_FragHandle;
-        }
-
-        let program = gl && gl.createProgram();
-        gl && gl.attachShader(program, vs as WebGLShader);
-        gl && gl.attachShader(program, ps as WebGLShader);
-        gl && gl.linkProgram(program);
-    
-        if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
-            console.log('linkProgram failed: ' + gl.getProgramInfoLog(program));
-        }
-        this._program=program;
-    }
-
-    private _program:WebGLProgram;
-    private _vs:WebGLShader;
-    private _ps:WebGLShader;
+export class Shader {
+  constructor() {
+
+  }
+  public Destroy(): void {
+    if (this._program) {
+      gl && gl.deleteProgram(this._program);
+      this._program = null;
+    }
+    if (this._vs) {
+      gl && gl.deleteShader(this._vs);
+      this._vs = null;
+    }
+    if (this._ps) {
+      gl && gl.deleteShader(this._ps);
+      this._ps = null;
+    }
+  }
+  public Create(vsCode: string[], psCode: string[]): void {
+    let vs;
+    if (vsCode) {
+      vs = gl && gl.createShader(gl.VERTEX_SHADER);
+      gl && gl.shaderSource(vs as WebGLShader, vsCode.join("\n"));
+      gl && gl.compileShader(vs as WebGLShader);
+      if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
+        console.log('VertexShader compile failed: ' + gl.getShaderInfoLog(vs));
+      }
+      this._vs = vs;
+    } else {
+      vs = g_VertHandle;
+    }
+
+    let ps;
+    if (psCode) {
+      ps = gl && gl.createShader(gl.FRAGMENT_SHADER);
+      gl && gl.shaderSource(ps as WebGLShader, psCode.join("\n"));
+      gl && gl.compileShader(ps as WebGLShader);
+      if (!gl.getShaderParameter(ps, gl.COMPILE_STATUS)) {
+        console.log('FragmentShader compile failed: ' + gl.getShaderInfoLog(ps));
+      }
+      this._ps = ps;
+    } else {
+      ps = g_FragHandle;
+    }
+
+    let program = gl && gl.createProgram();
+    gl && gl.attachShader(program, vs as WebGLShader);
+    gl && gl.attachShader(program, ps as WebGLShader);
+    gl && gl.linkProgram(program);
+
+    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
+      console.log('linkProgram failed: ' + gl.getProgramInfoLog(program));
+    }
+    this._program = program;
+  }
+
+  private _program: WebGLProgram;
+  private _vs: WebGLShader;
+  private _ps: WebGLShader;
 }
diff --git a/node_modules/@zhobo63/imgui-ts/src/input.ts b/node_modules/@zhobo63/imgui-ts/src/input.ts
index 3a00ac2..a806b79 100644
--- a/node_modules/@zhobo63/imgui-ts/src/input.ts
+++ b/node_modules/@zhobo63/imgui-ts/src/input.ts
@@ -1,124 +1,116 @@
+// @ts-nocheck
+
 import { ImFont } from "./imgui";
-import {ImGui} from "./index";
+import { ImGui } from "./index";
 
-export enum EType
-{
-    eInput,
-    eMultiLine, 
-    ePassword,
-    eMax,
+export enum EType {
+  eInput,
+  eMultiLine,
+  ePassword,
+  eMax,
 }
 
-export class Input
-{
-    constructor(type:EType, textCol:string, textBg:string)
-    {
-        let input;
-        switch(type)    {
-        case EType.eInput:
-            input=document.createElement('input');
-            input.type='text';
-            break;
-        case EType.eMultiLine:
-            input=document.createElement('textarea');
-            input.style.resize='none';
-            break;
-        case EType.ePassword:
-            input=document.createElement('input');
-            input.type='password';
-            break;
-        }
-        input.style.position='fixed';
-        input.style.top=0 + 'px';
-        input.style.left=0 + 'px';
-        input.style.borderWidth='0';
-        input.style.borderStyle='none';
-        input.style.zIndex='999';
-        input.style.backgroundColor=textBg;
-        input.style.color=textCol;
-        input.value="123";
+export class Input {
+  constructor(type: EType, textCol: string, textBg: string) {
+    let input;
+    switch (type) {
+      case EType.eInput:
+        input = document.createElement('input');
+        input.type = 'text';
+        break;
+      case EType.eMultiLine:
+        input = document.createElement('textarea');
+        input.style.resize = 'none';
+        break;
+      case EType.ePassword:
+        input = document.createElement('input');
+        input.type = 'password';
+        break;
+    }
+    input.style.position = 'fixed';
+    input.style.top = 0 + 'px';
+    input.style.left = 0 + 'px';
+    input.style.borderWidth = '0';
+    input.style.borderStyle = 'none';
+    input.style.zIndex = '999';
+    input.style.backgroundColor = textBg;
+    input.style.color = textCol;
+    input.value = "123";
 
-        input.addEventListener('blur', (e)=>{this.onLostFocus(e)})
-        input.addEventListener('keydown', (e)=>{this.onKeydown(e as KeyboardEvent)})
+    input.addEventListener('blur', (e) => { this.onLostFocus(e) })
+    input.addEventListener('keydown', (e) => { this.onKeydown(e as KeyboardEvent) })
 
-        document.body.appendChild(input);
-        this._dom_input=input;
-        this.setVisible(false);
-    }
+    document.body.appendChild(input);
+    this._dom_input = input;
+    this.setVisible(false);
+  }
 
-    public on_input: ((this: Input, text: string) => any) | null; 
-    public on_visible: ((this: Input, visible: boolean) => any) | null; 
+  public on_input: ((this: Input, text: string) => any) | null;
+  public on_visible: ((this: Input, visible: boolean) => any) | null;
 
-    private onLostFocus(e:Event)
-    {
-        if(this.on_input)   {
-            this.on_input(this._dom_input.value);
-        }
-        this.setVisible(false);        
+  private onLostFocus(e: Event) {
+    if (this.on_input) {
+      this.on_input(this._dom_input.value);
     }
-    onKeydown(e:KeyboardEvent)
-    {
-        if(e.key=="Tab")    {
-            this.isTab=true;
-            e.preventDefault();
-            this.setVisible(false);
-        }
+    this.setVisible(false);
+  }
+  onKeydown(e: KeyboardEvent) {
+    if (e.key == "Tab") {
+      this.isTab = true;
+      e.preventDefault();
+      this.setVisible(false);
     }
+  }
 
-    public isMe(id:ImGui.ImGuiID):boolean {
-        return this.isVisible && this._id==id;
-    }
+  public isMe(id: ImGui.ImGuiID): boolean {
+    return this.isVisible && this._id == id;
+  }
 
-    public get Text():string {
-        return this._dom_input.value;
+  public get Text(): string {
+    return this._dom_input.value;
+  }
+  public setRect(x: number, y: number, w: number, h: number) {
+    let input = this._dom_input;
+    input.style.left = x + 'px';
+    input.style.top = y + 'px';
+    input.style.width = w - 5 + 'px';
+    input.style.height = h - 5 + 'px';
+  }
+  public setText(text: string, id: ImGui.ImGuiID, font: ImFont) {
+    this._id = id;
+    let input = this._dom_input;
+    input.style.font = ImGui.Font_toString(font);
+    input.value = text;
+    this.setVisible(true);
+  }
+  public setVisible(b: boolean) {
+    let input = this._dom_input;
+    if (b) {
+      this.isTab = false;
+      input.style.display = 'inline-block';
+      input.focus();
+    } else {
+      input.style.display = 'none';
     }
-    public setRect(x:number, y:number, w:number, h:number)
-    {
-        let input=this._dom_input;
-        input.style.left=x + 'px';
-        input.style.top=y + 'px';
-        input.style.width=w -5 + 'px';
-        input.style.height=h -5 + 'px';
-    }
-    public setText(text:string, id:ImGui.ImGuiID, font:ImFont)
-    {
-        this._id=id;
-        let input=this._dom_input;
-        input.style.font=ImGui.Font_toString(font);
-        input.value=text;
-        this.setVisible(true);
-    }
-    public setVisible(b:boolean)
-    {
-        let input=this._dom_input;
-        if(b) {
-            this.isTab=false;
-            input.style.display='inline-block';
-            input.focus();
-        }else {
-            input.style.display='none';
-        }
-        this.isVisible=b;
-        if(this.on_visible) {
-            this.on_visible(b);
-        }
+    this.isVisible = b;
+    if (this.on_visible) {
+      this.on_visible(b);
     }
+  }
 
-    public _dom_input:HTMLInputElement|HTMLTextAreaElement;
-    private _id:ImGui.ImGuiID;
-    public isVisible:boolean=false;
-    public isTab:boolean=false;
+  public _dom_input: HTMLInputElement | HTMLTextAreaElement;
+  private _id: ImGui.ImGuiID;
+  public isVisible: boolean = false;
+  public isTab: boolean = false;
 }
 
-export let dom_input:any={}
+export let dom_input: any = {}
 
-export function GetInput(type:EType, textColor:string, textBgColor:string):Input
-{
-    let inp=dom_input[type];
-    if(!inp)    {
-        inp=new Input(type, textColor, textBgColor);
-        dom_input[type]=inp;
-    }
-    return inp;
+export function GetInput(type: EType, textColor: string, textBgColor: string): Input {
+  let inp = dom_input[type];
+  if (!inp) {
+    inp = new Input(type, textColor, textBgColor);
+    dom_input[type] = inp;
+  }
+  return inp;
 }
-
